
-------------- ROTATION --------------

First issue, rotation of the triangle. Firstly I attempted a solution by calculating the vectors from the
shape's origin to the clicked point, and did calculations using the dot product of those vectors. This worked
in some cases but had issues.
I then decided to instead use atan to calculate the angle from the x axis, and save the previous rotation and
rotate by the difference between them. This required modification to get the angle in the 0 to 360 range.


-------------- SOLUTION --------------

	public float getAngle(float x, float y) {
		float rx = x - polygon.getOriginX();
		float ry = y - polygon.getOriginY();
		float rot = (float) Math.toDegrees(Math.atan(ry / rx));
		if (rot < 0)
			rot += 180;
		if (ry < 0)
			rot += 180;
		return rot;
	}
	
	
-------------- OLD SOLUTION --------------

	public void rotate(float x1, float y1, float x2, float y2) {
		
		int neg = 1;
		if (x1 < x2 && y2 > polygon.getOriginY()) 
			neg = -1;
		if (x1 > x2 && y2 < polygon.getOriginY())
			neg = -1;
		
		
		Vector2 vec1 = new Vector2(x1, y1);
		Vector2 vec2 = new Vector2(x2, y2);
		Vector2 origin = new Vector2(polygon.getOriginX(), polygon.getOriginY());
		vec1.sub(origin);
		vec2.sub(origin);
		float theta = (float) Math.toDegrees( Math.acos( vec1.dot(vec2) / ( vec1.len() * vec2.len() ) ) );
		polygon.rotate(neg * theta);
	}
	
--------------------------------------------------------------------------------------------------------------


-------------- TRANSLATION --------------

Translation does not apply properly if a rotation has been performed. The position and origin are correctly
transformed, but the polygon itself is not.

Solution? :
Use getRotation to find and then reverse the rotation, perform the translate and then re-rotate.

Doesn't work. Also getRotation() doesn't stay within 0-360.

Issue is fixed when the origin is not also shifted.


----- 17.08.13 -----

To fix, ended up sticking to 90 degree rotations.

-------------- SOLUTION --------------						

	public void rotate90() {
		float x = polygon.getX();
		float y = polygon.getY();
		polygon.rotate(90);
		polygon.setPosition(x, y);
	}
	
	
-------------- CORRECTION --------------

Actually needs to be 45 degrees ...

	public void rotate45() {
		float x = polygon.getX();
		float y = polygon.getY();
		polygon.rotate(45);
		polygon.setPosition(x, y);
	}
	
--------------------------------------------------------------------------------------------------------------


-------------- COLLISION DETECTION -------------

Implemented collision with boundaries of the screen, using the following code.		
(Where the screen stretches from (0, 0) to (683, 683))


-------------- SOLUTION --------------

	private static final Polygon LEFT = new Polygon(new float[] {0, -100, 0, 783, -100, 783, -100, -100} );
	private static final Polygon RIGHT = new Polygon(new float[] {683, -100, 683, 783, 783, 783, 783, -100} );
	private static final Polygon TOP = new Polygon(new float[] {-100, 683, 783, 683, 783, 783, -100, 783} );
	private static final Polygon BOTTOM = new Polygon(new float[] {-100, 0, 783, 0, 783, -100, -100, -100} );

	if(Intersector.overlapConvexPolygons(polygon, LEFT) || Intersector.overlapConvexPolygons(polygon, RIGHT) ||
				Intersector.overlapConvexPolygons(polygon, TOP) || Intersector.overlapConvexPolygons(polygon, BOTTOM))
			*THEN UNDO TRANSLATE/ROTATE* 
			

----- 19.08.13 -----

Poor solution to implement collision detection with other shapes too, very similar for rotation.

	public void translate(float x, float y) {
		polygon.translate(x, y);
		if(Intersector.overlapConvexPolygons(polygon, LEFT) || Intersector.overlapConvexPolygons(polygon, RIGHT) ||
				Intersector.overlapConvexPolygons(polygon, TOP) || Intersector.overlapConvexPolygons(polygon, BOTTOM))
			polygon.translate(-x, -y);
		
		
		else {
			Iterator<Piece> iter = World.pieces.iterator();
			while (iter.hasNext()) {
				q = iter.next();
				if (this != q)
					if (Intersector.overlapConvexPolygons(polygon, q.get()))
						polygon.translate(-x, -y);
			}		
		}	
		
		
	}			
	
			
Instead of World.pieces, we could keep pieces as a static in the Piece class, and add to it every time a new piece is created.			
	*Implemented*
	Seems like poor programming, since World and WorldRenderer need access.
	
	
----- 20.08.13 -----

-------***------- SNAP TO GRID -------***-------

First attempt, only works for unrotated Triangle and only snaps to the bottom left corner.

		
	if (dragging.getX() + dragging.getOriginX() - 33 < 10 && dragging.getY() + dragging.getOriginY() -33 < 10)
		dragging.setPosition(-dragging.getOriginX() + (float) 100/3, -dragging.getOriginY() + (float) 100/3);
		
		
-------------- STATES --------------		
	
	States which decide how and where 'snap-to's should happen.	
		
	@Override
	public void rotate45() {
		super.rotate45();
		float rot = polygon.getRotation();
		
		if (rot % 180 == 0)
			setState(State.RHO0);
		
		if (rot % 180 == 45)
			setState(State.RHO1);
			
		if (rot % 180 == 90)
			setState(State.RHO2);
			
		if (rot % 180 == 135)
			setState(State.RHO3);
	}
	
	
	@Override
	public void rotate45() {
		super.rotate45();
		float rot = polygon.getRotation();
		
		if (rot == 0)
			setState(State.TRI0);
		
		if (rot == 45)
			setState(State.TRI1);
		
		if (rot == 90)
			setState(State.TRI2);
		
		if (rot == 135)
			setState(State.TRI3);
		
		if (rot == 180)
			setState(State.TRI4);
		
		if (rot == 225)
			setState(State.TRI5);
		
		if (rot == 270)
			setState(State.TRI6);
		
		if (rot == 315)
			setState(State.TRI7);
	}
	
	
	
	
	Snaps a triangle in state TRI0 to any corners with possible placement.
	
	private void tri0(Piece piece) {
		float x0 = - piece.getOriginX() + (float) 100/3;
		float y0 = - piece.getOriginY() + (float) 100/3;

		float x = piece.getX() - x0;
		float y = piece.getY() - y0;
		float x2 = x;
		float y2 = y + 100;
		float x3 = x + 100;
		float y3 = y;
		
		if (x < 10 && y < 10) {
			piece.setPosition(x0, y0);
			return;
		}
		
		if (x2 < 10 && y2 > 673) {
			piece.setPosition(x0, y0 + 583);
			return;
		}
		
		if (x3 > 673 && y3 < 10) {
			piece.setPosition(x0 + 583, y0);
			return;
		}
	}
	
	
----- 23.08.13 -----

Corner snapping completed and contained in class SnapTo with static method corner(Piece piece);



----- 27.08.13 -----

Edge to edge snapping implemented (for triangles so far), method is SnapTo.edges(Piece piece, Iterator<Piece> pieces)
This compares a piece to all other pieces and snaps to the first appropriate edge found.

It is called (by InputHandler) before snapping to the corner, as corner snapping takes priority as one might expect:

				SnapTo.edges(dragging, Piece.getIterator());
				SnapTo.corner(dragging, dragging.getState());
				
				
-------------- SOLUTION --------------

	public static void edges(Piece piece, Iterator<Piece> pieces) {
		// is a rhombus
		boolean ru, r = false;
		boolean snapped = false;
		Piece u;
		float[] us, vs = piece.getVerts();
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2();
		v0.x = vs[0]; v0.y = vs[1];
		v1.x = vs[2]; v1.y = vs[3];
		v2.x = vs[4]; v2.y = vs[5];
		if (vs.length > 7) {
			r = true;
			v3.x = vs[6]; v3.y = vs[7];
		}
		
		while (pieces.hasNext()) {
			u = pieces.next();
			if (u != piece) {	
				ru = false;
				us = u.getVerts();
				u0.x = us[0]; u0.y = us[1];
				u1.x = us[2]; u1.y = us[3];
				u2.x = us[4]; u2.y = us[5];
				if (us.length > 7) {
					ru = true;
					u3.x = us[6]; u3.y = us[7];
				}
				if (r && ru) {
					edgeRRU(v0, v1, v2, v3, u0, u1, u2, u3, snapped);
				}
				else if (r) {
					edgeR(v0, v1, v2, v3, u0, u1, u2, snapped);
				}
				else if (ru) {
					edgeRU(v0, v1, v2, u0, u1, u2, u3, snapped);
				}
				else {
					edge(v0, v1, v2, u0, u1, u2, piece, snapped);
				}
			}
		}
	}
			
			
			
	private static void edge(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 u0,
			Vector2 u1, Vector2 u2, Piece piece, boolean snapped) {
		
		// some optimisation possible here, but with loss of clarity
		
				
		if (v0.dst(u0) < 15 && v1.dst(u1) < 15)
			piece.translateWOC(u0.x - v0.x, u0.y - v0.y);
		
		else if (v0.dst(u0) < 15 && v1.dst(u2) < 15)
			piece.translateWOC(u0.x - v0.x, u0.y - v0.y);
		
		
		else if (v0.dst(u1) < 15 && v1.dst(u0) < 15)
			piece.translateWOC(u1.x - v0.x, u1.y - v0.y);
		
		else if (v0.dst(u1) < 15 && v1.dst(u2) < 15)
			piece.translateWOC(u1.x - v0.x, u1.y - v0.y);
		
		
		else if (v0.dst(u2) < 15 && v1.dst(u0) < 15)
			piece.translateWOC(u2.x - v0.x, u2.y - v0.y);
		
		else if (v0.dst(u2) < 15 && v1.dst(u1) < 15)
			piece.translateWOC(u2.x - v0.x, u2.y - v0.y);
		
		
		
		
		else if (v0.dst(u0) < 15 && v2.dst(u1) < 15)
			piece.translateWOC(u0.x - v0.x, u0.y - v0.y);
		
		else if (v0.dst(u0) < 15 && v2.dst(u2) < 15)
			piece.translateWOC(u0.x - v0.x, u0.y - v0.y);
		
		
		else if (v0.dst(u1) < 15 && v2.dst(u0) < 15)
			piece.translateWOC(u1.x - v0.x, u1.y - v0.y);
		
		else if (v0.dst(u1) < 15 && v2.dst(u2) < 15)
			piece.translateWOC(u1.x - v0.x, u1.y - v0.y);
		
		
		else if (v0.dst(u2) < 15 && v2.dst(u0) < 15)
			piece.translateWOC(u2.x - v0.x, u2.y - v0.y);
		
		else if (v0.dst(u2) < 15 && v2.dst(u1) < 15)
			piece.translateWOC(u2.x - v0.x, u2.y - v0.y);
		
		
		
		
		else if (v1.dst(u0) < 15 && v2.dst(u1) < 15)
			piece.translateWOC(u0.x - v1.x, u0.y - v1.y);
		
		else if (v1.dst(u0) < 15 && v2.dst(u2) < 15)
			piece.translateWOC(u0.x - v1.x, u0.y - v1.y);
		
		
		else if (v1.dst(u1) < 15 && v2.dst(u0) < 15)
			piece.translateWOC(u1.x - v1.x, u1.y - v1.y);
		
		else if (v1.dst(u1) < 15 && v2.dst(u2) < 15)
			piece.translateWOC(u1.x - v1.x, u1.y - v1.y);
		
		
		else if (v1.dst(u2) < 15 && v2.dst(u0) < 15)
			piece.translateWOC(u2.x - v1.x, u2.y - v1.y);
		
		else if (v1.dst(u2) < 15 && v2.dst(u1) < 15)
			piece.translateWOC(u2.x - v1.x, u2.y - v1.y);
	}
	
	

----- 27.08.13 -----

Edge snapping now implemented for all cases, some slight changes in code.


-------------- SOLUTION --------------

	public static void edges(Piece piece, Iterator<Piece> pieces) {
		// is a rhombus
		boolean ru, r = false;
		boolean snapped = false;
		Piece u;
		float[] us, vs = piece.getVerts();
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2();
		v0.x = vs[0]; v0.y = vs[1];
		v1.x = vs[2]; v1.y = vs[3];
		v2.x = vs[4]; v2.y = vs[5];
		if (vs.length > 7) {
			r = true;
			v3.x = vs[6]; v3.y = vs[7];
		}
		
		while (pieces.hasNext() && !snapped) {
			u = pieces.next();
			if (u != piece) {	
				ru = false;
				us = u.getVerts();
				u0.x = us[0]; u0.y = us[1];
				u1.x = us[2]; u1.y = us[3];
				u2.x = us[4]; u2.y = us[5];
				if (us.length > 7) {
					ru = true;
					u3.x = us[6]; u3.y = us[7];
				}
				
				snapped = edge(v0, v1, v2, u0, u1, u2, piece);

				if (!snapped && r)
					snapped = edgeR(v0, v1, v2, v3, u0, u1, u2, piece);

				if (!snapped && ru) {
					snapped = edgeRU(v0, v1, v2, u0, u1, u2, u3, piece);
					if (!snapped && r)
						snapped = edgeRRU(v0, v1, v2, v3, u0, u1, u2, u3, piece);
				}
			}
		}
	}


-------------- PROBLEM --------------

Although corner snapping is supposed to be applied after edge snapping, this doesn't seem to be happening in practice.


-------------- SOLUTION --------------

I will change the method of corner snapping to the same as edge snapping, and most likely combine the methods.

I combined the corner snapping and edge snapping into one static method called snap as shown below.

	private static Vector2 bl = new Vector2(0,0);
	private static Vector2 tl = new Vector2(0,683);
	private static Vector2 tr = new Vector2(683,683);
	private static Vector2 br = new Vector2(683,0);


	public static void snap(Piece piece, Iterator<Piece> pieces) {
				
		// is a rhombus
		boolean ru, r = false;
		boolean snapped = false;
		Piece u;
		float[] us, vs = piece.getVerts();
		// Initialise vectors, with the u vectors initially set as the corners of the screen
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2();
		v0.x = vs[0]; v0.y = vs[1];
		v1.x = vs[2]; v1.y = vs[3];
		v2.x = vs[4]; v2.y = vs[5];
		
		snapped = corner(v0, v1, v2, piece);

		if (!snapped && vs.length > 7) {
			r = true;
			v3.x = vs[6]; v3.y = vs[7];
			
			snapped = cornerR(v3, piece);
		}
		
		
		while (pieces.hasNext() && !snapped) {
			u = pieces.next();
			if (u != piece) {	
				ru = false;
				us = u.getVerts();
				u0.x = us[0]; u0.y = us[1];
				u1.x = us[2]; u1.y = us[3];
				u2.x = us[4]; u2.y = us[5];
				if (us.length > 7) {
					ru = true;
					u3.x = us[6]; u3.y = us[7];
				}
				
				snapped = edge(v0, v1, v2, u0, u1, u2, piece);

				if (!snapped && r)
					snapped = edgeR(v0, v1, v2, v3, u0, u1, u2, piece);

				if (!snapped && ru) {
					snapped = edgeRU(v0, v1, v2, u0, u1, u2, u3, piece);
					if (!snapped && r)
						snapped = edgeRRU(v0, v1, v2, v3, u0, u1, u2, u3, piece);
				}
			}
		}
	}
	
	
	
	private static boolean cornerR(Vector2 v3, Piece piece) {
		
		if (v3.dst(bl) < 15)
			piece.translateWOC(bl.x - v3.x, bl.y - v3.y);
		
		else if (v3.dst(tl) < 15)
			piece.translateWOC(tl.x - v3.x, tl.y - v3.y);
		
		else if (v3.dst(tr) < 15)
			piece.translateWOC(tr.x - v3.x, tr.y - v3.y);
		
		else if (v3.dst(br) < 15)
			piece.translateWOC(br.x - v3.x, br.y - v3.y);		
		
		else return false;
		
		return true;
	}

	
	private static boolean corner(Vector2 v0, Vector2 v1, Vector2 v2, Piece piece) {
		
		if (v0.dst(bl) < 15)
			piece.translateWOC(bl.x - v0.x, bl.y - v0.y);
		
		else if (v0.dst(tl) < 15)
			piece.translateWOC(tl.x - v0.x, tl.y - v0.y);
		
		else if (v0.dst(tr) < 15)
			piece.translateWOC(tr.x - v0.x, tr.y - v0.y);
		
		else if (v0.dst(br) < 15)
			piece.translateWOC(br.x - v0.x, br.y - v0.y);
		
		
		
		else if (v1.dst(bl) < 15)
			piece.translateWOC(bl.x - v1.x, bl.y - v1.y);
		
		else if (v1.dst(tl) < 15)
			piece.translateWOC(tl.x - v1.x, tl.y - v1.y);
		
		else if (v1.dst(tr) < 15)
			piece.translateWOC(tr.x - v1.x, tr.y - v1.y);
		
		else if (v1.dst(br) < 15)
			piece.translateWOC(br.x - v1.x, br.y - v1.y);
		
		
		
		else if (v2.dst(bl) < 15)
			piece.translateWOC(bl.x - v2.x, bl.y - v2.y);
		
		else if (v2.dst(tl) < 15)
			piece.translateWOC(tl.x - v2.x, tl.y - v2.y);
		
		else if (v2.dst(tr) < 15)
			piece.translateWOC(tr.x - v2.x, tr.y - v2.y);
		
		else if (v2.dst(br) < 15)
			piece.translateWOC(br.x - v2.x, br.y - v2.y);
		
		else return false;
		
		return true;
	}
	
	
	
-------------- DRAGGING CHANGE --------------

When dragging a piece you instead drag a semi-transparent version of the piece, which can be dragged anywhere, and on release the actual piece is translated.


-------------- SOLUTION --------------

First we have new constructors and we have clone methods for Triangle and Rhombus.

	public Triangle(float[] coords, float rot, Color color, float oX, float oY) {
		super(coords, rot, color);
		polygon.setOrigin(oX, oY);
	}

	@Override
	public Piece clone() {
		Color c = color.cpy();
		c.a = 0.5f;
		Triangle triangle = new Triangle(polygon.getTransformedVertices(), 0, c, polygon.getOriginX(), polygon.getOriginY());
		return triangle;
	}
	
	
	public Rhombus(float[] coords, float rot, Color color, float oX, float oY) {
		super(coords, rot, color);
		polygon.setOrigin(oX, oY);
		
		//setState(State.TRI0);
		
		//System.out.println((this.getX() + this.getOriginX()) + "," + (this.getY() + this.getOriginY()));
	}
	
	@Override
	public Piece clone() {
		Color c = color.cpy();
		c.a = 0.5f;
		Rhombus rhombus = new Rhombus(polygon.getTransformedVertices(), 0, c, polygon.getOriginX(), polygon.getOriginY());
		return rhombus;
	}
	
	
And we have a delete method in the Piece class.

	public void delete() {
		pieces.removeValue(this, true);
	}
	
	
And finally we have the updated InputHandler code:

	@Override
	public boolean touchDown(int screenX, int screenY, int pointer, int button) {
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCamera().unproject(touch);
			touchX = touch.x; touchY = touch.y;
			dragging = world.underMouse(touchX, touchY);
			initX = touchX; initY = touchY;
			drag = dragging.clone();
		}
		.....
	}
	
	@Override
	public boolean touchUp(int screenX, int screenY, int pointer, int button) {
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCamera().unproject(touch);
			float x = touch.x; float y = touch.y;
			if (dragging != null) {				
				drag.delete();
				dragging.translate(x - initX, y - initY);							
				SnapTo.snap(dragging, Piece.getIterator());
				dragging = null;			
			}
		}
		return true;
	}
	
	@Override
	public boolean touchDragged(int screenX, int screenY, int pointer) {
		touch.set(screenX, screenY, 0);
		world.getRenderer().getCamera().unproject(touch);
		float x = touch.x; float y = touch.y;
		if (dragging != null) {
			drag.translateWOC(x - touchX, y - touchY);
			touchX = x; touchY = y;
		}
		return true;
	} 



----- 01.10.13 -----

-------------- DRAGGING CHANGE --------------

Dragging now allows the transparent shape to be overlapping the shape that will be snapped to.

	
-------------- SOLUTION --------------

Changed SnapTo.snap() to return the boolean 'snapped'.

Updated TouchUp() to use this change to snap overlapping shapes together:
(Also shown here is the fix for overlapping shapes, starting with the line
 // If a snap has occurred, ... and ending with the end of the else clause)

	@Override
	public boolean touchUp(int screenX, int screenY, int pointer, int button) {
		...
			if (dragging != null) {
				
				drag.delete();
				
				// Allows for overlapping shapes to snap together
				dragging.translateWOC(x - initX, y - initY);	
				
				// Prevents overlapping shapes if no snap-to takes place
				if (!SnapTo.snap(dragging, Piece.getIterator())) {
					dragging.translateWOC(initX - x, initY - y);
					SnapTo.snap(dragging, Piece.getIterator());
					
					// Attempts a translation with overlapping checks, in case shape is moved to 'empty space'
					dragging.translate(x - initX, y - initY);
				}
				
				// If a snap has occurred, check for 'third party' overlaps
				else {
					if (dragging.overlaps()) {
						dragging.translateWOC(initX - x, initY - y);
						
						// Necessary if the piece was originally bordering another shape, but may
						// cause 'new snaps' to take place, although in theory this should not happen
						SnapTo.snap(dragging, Piece.getIterator());
					}
				}				
							
				dragging = null;			
		...
	}
	
	
To prevent overlapping with 'third party' shapes after a snap-to from an overlapping transparent shape, I created
a method in Piece, overlaps(), to check for any unwanted overlaps. Check above for the updated touchUp() code.

	public boolean overlaps() {
		
		Array<MinimumTranslationVector> mtvs = new Array<MinimumTranslationVector>(false, MozaicPlayer.PIECES + 4);
		
		mtv = new MinimumTranslationVector();
		Intersector.overlapConvexPolygons(polygon, LEFT, mtv);
		mtvs.add(mtv);
		mtv = new MinimumTranslationVector();
		Intersector.overlapConvexPolygons(polygon, RIGHT, mtv);
		mtvs.add(mtv);
		mtv = new MinimumTranslationVector();		
		Intersector.overlapConvexPolygons(polygon, TOP, mtv);
		mtvs.add(mtv);
		mtv = new MinimumTranslationVector();		
		Intersector.overlapConvexPolygons(polygon, BOTTOM, mtv);
		mtvs.add(mtv);
		
		Iterator<Piece> iter = pieces.iterator();
		while (iter.hasNext()) {
			q = iter.next();
			if (this != q)
				mtv = new MinimumTranslationVector();
				Intersector.overlapConvexPolygons(polygon, q.get(), mtv);
				mtvs.add(mtv);
		}
		
		max = 0;
		for (int i = 0; i < mtvs.size; i++) {
			mtv = mtvs.get(i);
			// If we have already checked all values
			if (mtv == null)
				break;
			// If pieces are snapped, a depth of ~ 70.71 is found for unknown reasons
			if (mtv.depth < 70)
				max = Math.max(max, mtv.depth);
		}
		if (max > 1)
			return true;
		else return false;
	}	
	

-------------- BUG FIX --------------

Clicking on a black area of the screen resulted in a crash.
The solution was to change the touchDown() method to check if dragging was null:

	@Override
	public boolean touchDown(int screenX, int screenY, int pointer, int button) {
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCamera().unproject(touch);
			touchX = touch.x; touchY = touch.y;
			dragging = world.underMouse(touchX, touchY);
			initX = touchX; initY = touchY;
			if (dragging != null)
				drag = dragging.clone();
		}
		...
	}			

		
		
----- 02.10.13 -----

-------------- SOUND EFFECTS --------------

Dragging a shape now plays sound, a successful drag and an unsuccessful drag play different sounds.
	
-------------- SOLUTION --------------		
		
Changed the translate() method in Piece to return whether or not the translation was successful.

Updated the TouchUp() code to play sounds as follows:

				// Prevents overlapping shapes if no snap-to takes place
				if (!SnapTo.snap(dragging, Piece.getIterator())) {
					dragging.translateWOC(initX - x, initY - y);
					
					// Necessary if the piece was originally bordering another shape, but may
					// cause 'new snaps' to take place, although in theory this should not happen
					SnapTo.snap(dragging, Piece.getIterator());
					
					// Attempts a translation with overlapping checks, in case shape is moved to 'empty space'
					if (dragging.translate(x - initX, y - initY))
						MozaicAudio.successfulDrag();
					else MozaicAudio.unsuccessfulDrag();
				}
				
				// If a snap has occurred, check for 'third party' overlaps
				else {
					if (dragging.overlaps()) {
						dragging.translateWOC(initX - x, initY - y);
						
						// Necessary if the piece was originally bordering another shape, but may
						// cause 'new snaps' to take place, although in theory this should not happen
						SnapTo.snap(dragging, Piece.getIterator());
						
						MozaicAudio.unsuccessfulDrag();
					}
					else MozaicAudio.successfulDrag();
				}		
		

-------------- BUG FIX --------------

The method for checking for overlaps only works sometimes.

The error was in the overlap() method in the Piece class, brackets were missing from an if statement.
This meant that the polygon was comparing against itself and changing the previous depth to the current depth,
(since the mtvs were the same object) giving 2 identical depths of ~ 70.71.

Here is the code with the added brackets:

		while (iter.hasNext()) {
			q = iter.next();
						
			if (this != q) {
				mtv = new MinimumTranslationVector();
				Intersector.overlapConvexPolygons(polygon, q.get(), mtv);
				mtvs.add(mtv);
			}
		}
		

-------------- SOUND EFFECTS --------------

Created a sound in bfxr called clink, which is played when a successful	snap occurs. I will create 2 more sound effects, one for
generic successful drags and one for all unsuccessful drags.

Here is the updated MozaicAudio class:		

----- ADDED: 22.10.13 -----

public class MozaicAudio {

	private MozaicAudio() {}
		
	public static Music song = Gdx.audio.newMusic(Gdx.files.internal("data/determination.mp3"));
	public static Sound fail = Gdx.audio.newSound(Gdx.files.internal("data/fail.wav"));
	public static Sound clink = Gdx.audio.newSound(Gdx.files.internal("data/clink.wav"));
	public static Sound swish = Gdx.audio.newSound(Gdx.files.internal("data/swish.wav"));
	public static Sound trash = Gdx.audio.newSound(Gdx.files.internal("data/trash.wav"));
	public static Sound success = Gdx.audio.newSound(Gdx.files.internal("data/success.wav"));
	
	public static void playMusic(boolean looping) {
		song.setLooping(looping);
		song.play();
	}
	
	public static void stopMusic(){
		song.stop();
	}
	
	public static void dispose() {
		song.dispose();
		fail.dispose();
		clink.dispose();
		swish.dispose();
		trash.dispose();
		success.dispose();
	}

	public static void dragSnap() {
		clink.play();		
	}

	public static void dragFail() {
		fail.play();
	}
	
	public static void drag() {
		success.play();
	}
	
	public static void delete() {
		trash.play();
	}
	
	public static void rotate() {
		swish.play();
	}
}

----- END OF ADDITION -----

And the touchUp() code in InputHandler is updated as follows:

				// Prevents overlapping shapes if no snap-to takes place
				if (!SnapTo.snap(dragging, Piece.getIterator())) {
					dragging.translateWOC(initX - x, initY - y);
					
					// Necessary if the piece was originally bordering another shape, but may
					// cause 'new snaps' to take place, although in theory this should not happen
					SnapTo.snap(dragging, Piece.getIterator());
					
					// Attempts a translation with overlapping checks, in case shape is moved to 'empty space'
					if (dragging.translate(x - initX, y - initY))
						MozaicAudio.drag();
					else MozaicAudio.dragFail();
				}
				
				// If a snap has occurred, check for 'third party' overlaps
				else {
					if (dragging.overlaps()) {
						dragging.translateWOC(initX - x, initY - y);
						
						// Necessary if the piece was originally bordering another shape, but may
						// cause 'new snaps' to take place, although in theory this should not happen
						SnapTo.snap(dragging, Piece.getIterator());
						
						MozaicAudio.dragFail();
					}
					else MozaicAudio.dragSnap();
				}
								
----- UPDATED: 22.10.13 -----						
				
public boolean touchUp(int screenX, int screenY, int pointer, int button) {
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCamera().unproject(touch);
			float x = touch.x; float y = touch.y;
						
			if (dragging != null) {
				
				drag.delete();
				
				
				if (y < MozaicPlayer.trans && isNew) {
					dragging.rotate45WOC();
					MozaicAudio.rotate();
					isNew = false;
					return true;
				}
				
				if (y < MozaicPlayer.trans && !isNew) {
					int id = dragging.getID();
					if (count[id] == 0) {
						count[id]+=2;
						replace(id);
					}
					else count[id]++;
					dragging.delete();
					MozaicAudio.delete();
					return true;
				}

			
				// Allows for overlapping shapes to snap together
				dragging.translateWOC(x - initX, y - initY);	
				
				// Prevents overlapping shapes if no snap-to takes place
				if (!SnapTo.snap(dragging, Piece.getIterator())) {
					dragging.translateWOC(initX - x, initY - y);
					
					// Necessary if the piece was originally bordering another shape, but may
					// cause 'new snaps' to take place, although in theory this should not happen
					SnapTo.snap(dragging, Piece.getIterator());
					
					// Attempts a translation with overlapping checks, in case shape is moved to 'empty space'
					if (dragging.translate(x - initX, y - initY)) {
												
						if(isNew)
							replace(dragging.getID());
						
						MozaicAudio.drag();						
					}
					else {
						MozaicAudio.dragFail();
					}
				}
				
				// If a snap has occurred, check for 'third party' overlaps
				else {
					if (dragging.overlaps()) {
						dragging.translateWOC(initX - x, initY - y);
						
						if(isNew) {
							// somehow force to original position
						}
						else {
						// Necessary if the piece was originally bordering another shape, but may
						// cause 'new snaps' to take place, although in theory this should not happen
						SnapTo.snap(dragging, Piece.getIterator());
						}
						
						MozaicAudio.dragFail();
					}
					else {
						
						if(isNew)
							replace(dragging.getID());
						
						MozaicAudio.dragSnap();
					}
				}
								
				dragging = null;
				isNew = false;			
			}
		}
		
----- END OF UPDATE -----		


----- 17.10.13 -----
				
-------------- SCALING --------------
						
The screen and shapes now scale to fit different devices, the following code snippets were added/modified.			
				
MozaicPlayer.java:				
				
	public static final int assumeX = 683;
	public static final int assumeY = 683;		
	public static int width;
	public static int height;
	public static int size;
	public static float scale;
	public static int trans;
	
	@Override
	public void create() {
		width = Gdx.graphics.getWidth();
		height = Gdx.graphics.getHeight();
		size = Math.min(width, height);
		scale = size/assumeWidth;
		trans = Math.max(width, height) - size;
		
		log = new FPSLogger();
		//MozaicAudio.playMusic(true);
		//setScreen(new SplashScreen(this));
		setScreen(new GameScreen(this));
	}
	
	
SnapTo.java:	
	
	private static final Vector2 bl = new Vector2(0, MozaicPlayer.trans);
	private static final Vector2 tl = new Vector2(0, MozaicPlayer.height);
	private static final Vector2 tr = new Vector2(MozaicPlayer.size, MozaicPlayer.height);
	private static final Vector2 br = new Vector2(MozaicPlayer.size, MozaicPlayer.trans);
	
	
Piece.java:
	
	private static final int bottom1 = MozaicPlayer.trans;
	private static final int bottom2 = bottom1 - 100;
	private static final int left1 = 0;
	private static final int left2 = -100;
	private static final int right1 = MozaicPlayer.size;
	private static final int right2 = right1 + 100;
	private static final int top1 = MozaicPlayer.height;
	private static final int top2 = top1 + 100;
	
	private static final Polygon LEFT = new Polygon(new float[] {left1, bottom2, left1, top2, left2, top2, left2, bottom2} );
	private static final Polygon RIGHT = new Polygon(new float[] {right1, bottom2, right1, top2, right2, top2, right2, bottom2} );
	private static final Polygon TOP = new Polygon(new float[] {left2, top1, right2, top1, right2, top2, left2, top2} );
	private static final Polygon BOTTOM = new Polygon(new float[] {left2, bottom1, right2, bottom1, right2, bottom2, left2, bottom2} );
	

RhombusFactory.java:

	private static final float HEIGHT = (float) (MozaicPlayer.scale * (100 / Math.sqrt(2)));
	private static float WIDTH = (float) (MozaicPlayer.scale * 100);
	private static float SLIDE = HEIGHT;			
	
	
TriangleFactory.java:

	private static final float HEIGHT = (float) (MozaicPlayer.scale * 100);
	private static final float WIDTH = HEIGHT;
	

Rectangle at the bottom of screen for shape 'creation'
	
	sr.begin(ShapeType.FilledRectangle);
	sr.setColor(Color.WHITE);
	sr.filledRect(0, 0, MozaicPlayer.size, MozaicPlayer.trans);
	sr.end();   	
	

-------------- ANDROID FRIENDLY SHAPE 'CREATION' --------------

Lots of small edits to code:
Pieces now have a protected integer value called id, representing the type of shape for recreation purposes.
Rhombus and Triangle Factories now have methods that allow an id to be chosen, and methods for creating new shapes
based on a given id. This is used to replace the shapes that are dragged out of the white area.

	
	public static Triangle create(float x, float y, float rot, Color color, int id) {
		Triangle triangle = new Triangle(new float[] {x, y, x + WIDTH, y, x, y + HEIGHT}, rot, color);
		triangle.id = id;
		return triangle;
	}
	
	public static Triangle create(int id) {
		if (id == 1)
			return TriangleFactory.create(50, 50, 0, Color.RED, id);
		
		else return TriangleFactory.create(200, 50, 0, Color.MAGENTA, id);
	}
	
	
	public static Rhombus create(float x, float y, float rot, Color color, int id) {
		Rhombus rhombus = new Rhombus(new float[] {x, y, x + SLIDE, y + HEIGHT, x + SLIDE + WIDTH, y + HEIGHT, x + WIDTH, y}, rot, color);
		rhombus.id = id;
		return rhombus;
	}
	
	public static Rhombus create(int id) {
		if (id == 3)
			return RhombusFactory.create(350, 50, 0, Color.BLUE, id);
		
		else return RhombusFactory.create(500, 50, 0, Color.GREEN, id);

	}
	
	
Because of these additions, the code in World that initialises the shapes has been changed to:
		
		TriangleFactory.create(1);
		TriangleFactory.create(2);
		RhombusFactory.create(3);
		RhombusFactory.create(4);
		
			
This line was added to the touchDown() method of the InputHandler class:
			
			if (touchY < MozaicPlayer.trans)
				isNew = true;

And touchUp() was updated to the following:

	@Override
	public boolean touchUp(int screenX, int screenY, int pointer, int button) {
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCamera().unproject(touch);
			float x = touch.x; float y = touch.y;
			if (dragging != null) {
				drag.delete();

				// Allows for overlapping shapes to snap together
				dragging.translateWOC(x - initX, y - initY);	
				
				// Prevents overlapping shapes if no snap-to takes place
				if (!SnapTo.snap(dragging, Piece.getIterator())) {
					dragging.translateWOC(initX - x, initY - y);
					SnapTo.snap(dragging, Piece.getIterator());
					
					// Attempts a translation with overlapping checks, in case shape is moved to 'empty space'
					if (dragging.translate(x - initX, y - initY)) {						
						if(isNew)
							replace(dragging.getID());
						MozaicAudio.drag();
					}
					else {
						if (isNew)
							dragging.rotate45WOC();
						MozaicAudio.dragFail();
					}
				}
				
				// If a snap has occurred, check for 'third party' overlaps
				else {
					if (dragging.overlaps()) {
						dragging.translateWOC(initX - x, initY - y);
						
						if(isNew) {
							dragging.rotate45WOC();
							// somehow force to original position
						}
						else
							SnapTo.snap(dragging, Piece.getIterator());
						MozaicAudio.dragFail();
					}
					else {				
						if(isNew)
							replace(dragging.getID());						
						MozaicAudio.dragSnap();
					}
				}					
				dragging = null;
				isNew = false;			
			}
		}
		
And the replace() method was added, which is called to create a replacement shape.

	private void replace(int id) {
		if(id > 0) {
			if (id > MozaicPlayer.ID) {
				RhombusFactory.create(id);
			}
			else TriangleFactory.create(id);
		}
	}
	
Where MozaicPlayer.ID represents the number of colours of each shape available, and is initialised as follows:
	public static final int ID = 2;		


----- 21.10.13 -----
				
-------------- SHAPE DELETION --------------

Store counts of the number of pieces (for now just in the InputHandler), and uses this to decide if to replace the
shape when replace(id) is called. A successful replace decrements the count, and a deletion increments the count.

	int[] count = new int[10];

	public InputHandler(World world) {
		this.world = world;
		
		for (int i = 0; i < 10; i++) {
			count[i] = 5;
		}
	}
	
	
	private void replace(int id) {
		if (count[id] > 0) {
			if(id > 0) {
				if (id > MozaicPlayer.ID) {
					RhombusFactory.create(id);
				}
				else TriangleFactory.create(id);
			}
			count[id]--;
		}
	}
	
	
	@Override
	public boolean touchUp(int screenX, int screenY, int pointer, int button) {
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCamera().unproject(touch);
			float x = touch.x; float y = touch.y;
						
			if (dragging != null) {
				
				drag.delete();
				
				if (y < MozaicPlayer.trans && !isNew) {
					int id = dragging.getID();
					count[id]++;
					if (count[id] == 1)
						replace(id);
					dragging.delete();
				}
				
				
There were a couple of issues to do with replacement which I addressed by changing the code to the following:
(The change to rotation is a possible optimisation which I found while bugfixing)				
				
				if (dragging != null) {
				
				drag.delete();
				
				
				if (y < MozaicPlayer.trans && isNew) {
					dragging.rotate45WOC();
					isNew = false;
					return true;
				}
				
				if (y < MozaicPlayer.trans && !isNew) {
					int id = dragging.getID();
					if (count[id] == 0) {
						count[id]+=2;
						replace(id);
					}
					else count[id]++;
					System.out.println(count[id]);
					dragging.delete();
					return true;
				}
				
				
	private void replace(int id) {
		count[id]--;
		if (count[id] > 0) {
			if(id > 0) {
				if (id > MozaicPlayer.ID) {
					RhombusFactory.create(id);
				}
				else TriangleFactory.create(id);
			}
		}
	}
				
				
-------------- LOCKING SHAPES TOGETHER --------------				

*** Not sure how to implement or if it is worth doing so as of yet. ***
				
			if (touchY < MozaicPlayer.trans) {
				if (touchX < MozaicPlayer.width/10)
					toggleLock();
				isNew = true;
			}
			
	private void toggleLock() {}
							
	
-------------- BUG FIX --------------

Rotation sometimes occurs when it shouldn't, as it results in overlapping shapes.

The issue was with multiple shapes overlapping with the rotating shape, causing the shape to perform a rotation of -45,
this was fixed by adding the line "break" to the if statement in the while loop of rotate45().	
	
				q = iter.next();
				if (this != q)
					if (Intersector.overlapConvexPolygons(polygon, q.get())) {
						rot = (rot - 45) % 360;
						polygon.setRotation(rot);
						break;
					}
					

----- 21.10.13 -----
						
-------------- BUG FIX --------------

Origins not where they should be.

This issue occurred because the origin placement when creating shapes had not been updated when
the shapes were updated to scale to different screen sizes.


public class Rhombus extends Piece {
	private static float ORIGINOFFSET = (float) (MozaicPlayer.scale*100/Math.sqrt(2)/2);
 
	public Rhombus(float[] coords, float rot, Color color) {
		super(coords, rot, color);
		polygon.setOrigin((coords[2] + coords[6]) / 2, coords[1] + ORIGINOFFSET);
	}
	
	
public class Triangle extends Piece {
	private static float ORIGINOFFSET = (float) (MozaicPlayer.scale*100/3);

	public Triangle(float[] coords, float rot, Color color) {
		super(coords, rot, color);
		polygon.setOrigin(coords[0] + ORIGINOFFSET, coords[1] + ORIGINOFFSET);
	}
	
	
-------------- BUG FIX --------------
	
Shapes spawn in 'incorrect' positions when a different size screen is used.
		
The code for positioning the 'spawn shapes' was not made to scale with screen size, and was only meant for
testing purposes. It had been left this way by accident.

public class RhombusFactory {
...
	public static Rhombus create(int id) {
		if (id == 3)
			return RhombusFactory.create(MozaicPlayer.width*15/32, (MozaicPlayer.trans-HEIGHT)/2, 0, Color.BLUE, id);

		else return RhombusFactory.create(MozaicPlayer.width*23/32, (MozaicPlayer.trans-HEIGHT)/2, 0, Color.GREEN, id);
	}
	
	
public class TriangleFactory {
...	
	public static Triangle create(int id) {
		if (id == 1)
			return TriangleFactory.create(MozaicPlayer.width*3/32, MozaicPlayer.trans/2 - HEIGHT/3, 0, Color.RED, id);

		else return TriangleFactory.create(MozaicPlayer.width*10/32, MozaicPlayer.trans/2 - HEIGHT/3, 0, Color.MAGENTA, id);
	}
	

-------------- RUNS ON ANDROID! --------------

There seems to be an issue with retrieving the size of the screen, so for now I have manually set the width and height in MozaicPlayer.java:
		
		height = 1280;
		width = 720;
		size = width;
		scale = (float) size/assumeWidth;
		trans = height - width;
		
		
-------------- UPDATE --------------
		
Appears to be working! Code is currently:

		width = Gdx.graphics.getWidth(); 
		height = Gdx.graphics.getHeight();
		size = width;
		scale = (float) size/assumeWidth;
		trans = height - width;
		
-------------- END OF UPDATE --------------
				
		
Also in the MozaicPlayer.java class I have added the following line of code:

As it turns out, all that had to be done to get it to work on android was to change a variable in AndroidManifest.xml from "landscape" to "portrait"			
and therefore this code using the ANDROID boolean is now unused.

	public static final boolean ANDROID = true;
		

In WorldRenderer.java the cam setup has been updated to:

		cam = new OrthographicCamera();
		cam.setToOrtho(false, width, height);
		if (MozaicPlayer.ANDROID) {
			cam.rotateAround(new Vector3(width/2, height/2, 0), new Vector3(0, 0, 1), -90);
			cam.update();
			cam.translate(new Vector2(height/2 - width/2, width/2 - height/2));
		}
		cam.update();
		

And I have changed the background colour to white and the selection panel colour to black, to improve visibility on black mobile devices:

	public void render() {
		Gdx.gl.glClearColor(1, 1, 1, 1);
		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);

		...
		
		sr.begin(ShapeType.FilledRectangle);
		sr.setColor(Color.BLACK);
		sr.filledRect(0, 0, MozaicPlayer.size, MozaicPlayer.trans);
		sr.end(); 
		

I also changed SnapTo.java to work with a minimum distance d which is calculated based on screen size, as opposed to the previous flat value of 15.				
						
	private static float d;
	

	public static boolean snap(Piece piece, Iterator<Piece> pieces) {
		
		d = MozaicPlayer.size/36;	
		


----- 03.11.13 -----
						
-------------- COMPLETE SET OF TILES --------------

There are now 6 colours of triangle, and 4 colours of rhombus.

	public World(MozaicPlayer game) {
		this.game = game;
		Gdx.input.setInputProcessor(new InputHandler(this));
		for (int i = 0; i < 6; i++)
			TriangleFactory.create(i);
		for (int i = 0; i < 4; i++)
			RhombusFactory.create(MozaicPlayer.ID + 1 + i);
	}


These are the corresponding create methods in the TriangleFactory and RhombusFactory classes respectively.	
	
	public static Triangle create(int id) {
		if (id == 0)
			return TriangleFactory.create(MozaicPlayer.width*3/32, MozaicPlayer.trans/2 - HEIGHT/3, 0, Color.BLUE, id);

		else if(id == 1)
			return TriangleFactory.create(MozaicPlayer.width*10/32, MozaicPlayer.trans/2 - HEIGHT/3, 0, Color.GREEN, id);
		
		else if (id == 2)
			return TriangleFactory.create(MozaicPlayer.width*3/32, (MozaicPlayer.trans/2 - HEIGHT/3)/3, 0, Color.YELLOW, id);

		else if(id == 3)
			return TriangleFactory.create(MozaicPlayer.width*10/32, (MozaicPlayer.trans/2 - HEIGHT/3)/3, 0, Color.RED, id);
		
		else if (id == 4)
			return TriangleFactory.create(MozaicPlayer.width*3/32, MozaicPlayer.trans/2 - HEIGHT/3 + 2*(MozaicPlayer.trans/2 - HEIGHT/3)/3, 0, Color.CYAN, id);

		else
			return TriangleFactory.create(MozaicPlayer.width*10/32, MozaicPlayer.trans/2 - HEIGHT/3 + 2*(MozaicPlayer.trans/2 - HEIGHT/3)/3, 0, Color.MAGENTA, id);
	}
	
	
	public static Rhombus create(int id) {
		if (id == MozaicPlayer.ID + 1)
			return RhombusFactory.create(MozaicPlayer.width*15/32, (MozaicPlayer.trans-HEIGHT)/2, 0, Color.BLUE, id);

		else if (id == MozaicPlayer.ID + 2) 
			return RhombusFactory.create(MozaicPlayer.width*23/32, (MozaicPlayer.trans-HEIGHT)/2, 0, Color.GREEN, id);
	
		else if (id == MozaicPlayer.ID + 3)
			return RhombusFactory.create(MozaicPlayer.width*15/32, ((MozaicPlayer.trans-HEIGHT)/2)/3, 0, Color.YELLOW, id);
		
		else
			return RhombusFactory.create(MozaicPlayer.width*23/32, ((MozaicPlayer.trans-HEIGHT)/2)/3, 0, Color.RED, id);
	}
	
	
And the input handler is initialised so there are 8 of each piece.
	
	public InputHandler(World world) {
		this.world = world;
		
		for (int i = 0; i < 10; i++) {
			count[i] = 8;
		}
	}
	

-------------- REFLECTION --------------
			
Should be easy to keep the reflection in the correct position, but first we need to create the reflections which is proving tricky.



----- 04.11.13 -----

------------- PENROSE KITE/DART --------------

Created the PenrosePiece abstract class, renamed Piece to ClassicPiece, and created an interface called piece which both implement. Arrow and Kite 
then extend PenrosePiece, and I created new factorys, ArrowFactory and KiteFactory. These all work similarly to their classic counterparts.
I also modified the InputHandler slightly to work with the new model, and created PenroseWorld and PenroseGameScreen classes, along with abstract
classes World and GameScreen, which they extend along with ClassicGameScreen and ClassicWorld.

The first issue I encountered stemmed from the fact that the Arrow shape is not convex, meaning the overlapConvexPolygons() method cannot be used as before.
The solution for this was to instead of storing each piece as a polygon, store them as 2 triangular polygons, and update the overlap method as follows:


public boolean overlaps() {
		
		Array<MinimumTranslationVector> mtvs = new Array<MinimumTranslationVector>(false, 4*MozaicPlayer.PIECES);
		
		Iterator<PenrosePiece> iter = pieces.iterator();
		while (iter.hasNext()) {
			q = iter.next();
						
			if (this != q) {
				mtv1 = new MinimumTranslationVector();
				mtv2 = new MinimumTranslationVector();
				mtv3 = new MinimumTranslationVector();
				mtv4 = new MinimumTranslationVector();
				Intersector.overlapConvexPolygons(polygon1, q.get1(), mtv1);
				Intersector.overlapConvexPolygons(polygon1, q.get2(), mtv2);
				Intersector.overlapConvexPolygons(polygon2, q.get1(), mtv3);
				Intersector.overlapConvexPolygons(polygon2, q.get2(), mtv4);
				mtvs.add(mtv1);
				mtvs.add(mtv2);
				mtvs.add(mtv3);
				mtvs.add(mtv4);
			}
		}
		
		max = 0;
		for (int i = 0; i < mtvs.size; i++) {
			mtv1 = mtvs.get(i);
			// If we have already checked all values
			if (mtv1 == null)
				break;
						
			max = Math.max(max, mtv1.depth);
		}
		
		if (max > 1)
			return true;
		else return false;
	}


Obviously this entailed initialising more variables at the start, and the translation and rotation methods had to be changed to apply to both polygons.
Since the shape has to be kept together when rotating, this means the centre of rotation (origin) has to be along the line where the triangles join, and 
both polygons must have the same origin:

	public Kite(float[] coords, float rot, Color color) {
		super(coords, rot, color);
		polygon1.setOrigin(coords[0] + ORIGINOFFSETX, coords[1]);
		polygon2.setOrigin(coords[0] + ORIGINOFFSETX, coords[1]);		
	}



----- 05.11.13 -----	
	
I created a helper method in PenrosePiece to help with finding the centre of the shape, for rotation purposes:
	
	private Vector2 centre(float[] transformedVertices) {
		int n = transformedVertices.length;
		float x = 0, y = 0;
		for (int i = 0; i < n; i+=2) {
			x += transformedVertices[i];
			y += transformedVertices[i+1];
		}
		x /= (n/2);
		y /= (n/2);
		return new Vector2(x, y);
	}
	
	
this method is called by getAngle():
	
	public float getAngle(float x, float y) {
		Vector2 centre = centre(getVerts());
		float rx = x - centre.x;
		float ry = y - centre.y;
		float rot = (float) Math.toDegrees(Math.atan(ry / rx));
		if (rot < 0)
			rot += 180;
		if (ry < 0)
			rot += 180;
		return rot;
	}
	

which is used by the input handler to rotate the shape.	



----- 06.11.13 -----	

I then started work on the SnapTo class, which now looks like this:
(The methods are named this way, since 14 matches edges 1 and 4, and is used in more than one case,
  and for the rest, the letters stand for the case e.g. ka => v is a kite, u is an 'arrow' (dart) )

	public static boolean snap(Piece dragging, Iterator<PenrosePiece> penrosePieces) {
		
		d = MozaicPlayer.size/20;
		
		boolean snapped = false;
		boolean va = (dragging.getID() > MozaicPlayer.PenroseID);
		boolean ua;
		PenrosePiece u;
		float[] us, vs = dragging.getVerts();
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2();
		v0.x = vs[0]; v0.y = vs[1];
		v1.x = vs[2]; v1.y = vs[3];
		v2.x = vs[4]; v2.y = vs[5];
		v3.x = vs[6]; v3.y = vs[7];
				
		while (!snapped && penrosePieces.hasNext()) {
			u = penrosePieces.next();
			if (u != dragging) {
				us = u.getVerts();
				u0.x = us[0]; u0.y = us[1];
				u1.x = us[2]; u1.y = us[3];
				u2.x = us[4]; u2.y = us[5];
				u3.x = us[6]; u3.y = us[7];
				
				ua = (u.getID() > MozaicPlayer.PenroseID);
				

				if (va) {
					if (ua)
						snapped = edge14(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
					else if (!snapped)
						snapped = edgeak(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
				}
				
				else if (!snapped) {
					if (ua)
						snapped = edgeka(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
					else if (!snapped)
						snapped = edgekk(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
				}				
			}
		}
		
		return snapped;
	}
	
	private static boolean edgekk(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0,
			Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging) {
		
		if (edge14(v0, v1, v2, v3, u0, u1, u2, u3, dragging))
			return true;
		
		else if (v1.dst(u1) < d && v2.dst(u2) < d)
			dragging.fix(v1, v2, u1, u2);
		
		else if (v1.dst(u3) < d && v2.dst(u2) < d)
			dragging.fix(v1, v2, u3, u2);
		
		else if (v2.dst(u2) < d && v3.dst(u3) < d)
			dragging.fix(v2, v3, u2, u3);
		
		else if (v2.dst(u2) < d && v3.dst(u1) < d)
			dragging.fix(v2, v3, u2, u1);
		
		else return false;
		
		return true;
	}

	private static boolean edgeak(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0,
			Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging) {
		
		if (v0.dst(u1) < d && v1.dst(u0) < d)
			dragging.fix(v0, v1, u1, u0);
		
		else if (v0.dst(u3) < d && v1.dst(u0) < d)
			dragging.fix(v0, v1, u3, u0);
		
		else if (v0.dst(u1) < d && v3.dst(u0) < d)
			dragging.fix(v0, v3, u1, u0);
		
		else if (v0.dst(u3) < d && v3.dst(u0) < d)
			dragging.fix(v0, v3, u3, u0);
		
		
		else if (v2.dst(u1) < d && v1.dst(u2) < d)
			dragging.fix(v2, v1, u1, u2);
		
		else if (v2.dst(u3) < d && v1.dst(u2) < d)
			dragging.fix(v2, v1, u3, u2);
		
		else if (v2.dst(u1) < d && v3.dst(u2) < d)
			dragging.fix(v2, v3, u1, u2);
		
		else if (v2.dst(u3) < d && v3.dst(u2) < d)
			dragging.fix(v2, v3, u3, u2);
		
		else return false;
		
		return true;
	}
	
	private static boolean edge14(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0,
			Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging) {
		
		if (v0.dst(u0) < d && v1.dst(u1) < d)
			dragging.fix(v0, v1, u0, u1);
		
		else if (v0.dst(u0) < d && v1.dst(u3) < d)
			dragging.fix(v0, v1, u0, u3);
		
		else if (v0.dst(u0) < d && v3.dst(u3) < d)
			dragging.fix(v0, v3, u0, u3);
		
		else if (v0.dst(u0) < d && v3.dst(u1) < d)
			dragging.fix(v0, v3, u0, u1);
		
		else return false;
		
		return true;
	}
	
	private static boolean edgeka(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0,
			Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging) {
		return edgeak(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
	}

	
This uses a new method fix(), which transforms the PenrosePiece so the edge is lined up with the given edge (u0, u1)

	public void fix(Vector2 v0, Vector2 v1, Vector2 u0, Vector2 u1){
		float d0 = v0.dst(u0);
		float d1 = v1.dst(u1);
		
		
		// Swaps the input so v1 is always the vector that is 'furthest away'
				
		if (d0 > d1) {
			Vector2 v = v0;
			v0 = v1;
			v1 = v;
			v = u0;
			u0 = u1;
			u1 = v;
		}
		
		
		// If a rotation is required, calculate using the cosine rule
						
		if (d0 != d1) {			
			float a = (float) ( Math.pow((v1.x - v0.x), 2) + Math.pow((v1.y - v0.y), 2) );
			float b = (float) ( Math.pow((u1.x - u0.x), 2) + Math.pow((u1.y - u0.y), 2) );
			float c = (float) ( Math.pow(((u1.x + v0.x - u0.x) - v1.x), 2) + Math.pow(((u1.y + v0.y - u0.y) - v1.y), 2) );
			float rot = (float) Math.toDegrees( Math.acos( (a+b-c) / (2 * Math.sqrt(a) * Math.sqrt(b)) ) );
			
			
			// Prevents NaN errors, and pointless rotations of tiny amounts due to inaccuracies
			
			if ( rot > 0.5 ) {
				float dx = u1.x - u0.x;
				float dx2 = dx * dx;
				float dy = u1.y - u0.y;
				float dy2 = dy * dy;
				float ax = v0.x;
				float ay = v0.y;
				float bx = v1.x;
				float by = v1.y;
				
				float s_ = ( dy2 * dx * (bx - ax) - dx2 * dy * (by - ay) ) / ( dy2 - dx2 );
				float s = ( bx - ax - s_ / dx ) / dx;	
				Vector2 x_ = new Vector2(s * dx + ax, s * dy + ay);
				
				
				// x_ is the point making a right-angle with v0 and v1, originally calculated for an attempt at calculating the angle using
				// atan(o/a), and now just used for deciding whether to negate the rotation value or not. May be unnecessary computation.
				
				// The negation is decided based intuitively on which (diagonal) quarter of the axes the line (u0, u1) lies in.
							
				if (Math.abs(dy) > Math.abs(dx)) {			
					if (dy > 0 && v1.x < x_.x)
						rot = - rot;
					if (dy < 0 && v1.x > x_.x)
						rot = - rot;
				}
				
				else {
					if (dx > 0 && v1.y > x_.y)
						rot = - rot;
					if (dx < 0 && v1.y < x_.y)
						rot = - rot;
				}	
						
				rotate(rot);
			}
		}
		
		
		// The distance between the transformed v1 and the point u1 is now calculated, and the translation is performed
		
		Vector2 v_ = getClosest(u1);
		translateWOC(u1.x - v_.x, u1.y - v_.y);
	}
	
	
This required the helper method getClosest(), which find the point of the PenrosePiece which is nearest the given vector.

	private Vector2 getClosest(Vector2 u) {
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2();
		float[] verts = getVerts();
		v0.x = verts[0]; v0.y = verts[1];
		v1.x = verts[2]; v1.y = verts[3];
		v2.x = verts[4]; v2.y = verts[5];
		v3.x = verts[6]; v3.y = verts[7];
		float v0d = v0.dst(u);
		float v1d = v1.dst(u);
		float v2d = v2.dst(u);
		float v3d = v3.dst(u);

		float dst = Math.min(Math.min(Math.min(v0d, v1d), v2d), v3d);
		
		if (v0d == dst)
			return v0;
		
		if (v1d == dst)
			return v1;
		
		if (v2d == dst)
			return v2;
		
		if (v3d == dst)
			return v3;
				
		return null;
	}	


This method fix() for 'snapping' should be useable for any future implemented pieces, although is only really appropriate for
puzzles allowing free rotation such as the Penrose puzzle.


I then changed the NewInputHandler class, the SnapTo class and made a few smaller changes to other classes to allow the game mode
to be changed by changing the value of:
	public static final GameMode GAMEMODE = GameMode.Classic;

The biggest change I had to make was to change all the iterators to type Iterator<Piece> and add casting to the specific type of piece where required.


----- 19.11.13 -----	

-------------- REFLECTION --------------

I created 4 new classes, RefTriangle, RefRhombus, and their factory counterparts. These currently somewhat work with vertical reflection. Problems 
occur when the 'reflected' shape is manipulated instead of the 'original' shape.


Here is the code for RefTriangle, RefRhombus is very similar: 

public class RefTriangle extends ClassicPiece {	
	private Array<RefTriangle> refPieces;
	private int ref;
	private ClassicPiece p;
	private Polygon poly;
	private Iterator<RefTriangle> iter1;
	private Iterator<Piece> iter2;
	private static float ORIGINOFFSET = (float) (MozaicPlayer.scale*100/3);


	
	private static final float HEIGHT = (float) (MozaicPlayer.scale * 100);
	private static final float WIDTH = HEIGHT;

	public RefTriangle(float[] coords, float rot, Color color, int ref, int id) {

		polygon = new Polygon(coords);
		this.color = color;
		this.rot = rot;
		polygon.setRotation(rot);
		polygon.setOrigin(coords[0] + ORIGINOFFSET, coords[1] + ORIGINOFFSET);
		
		
		this.id = id;
		this.ref = ref;
		int size = 2;
		if (ref > 4)
			size += 2;
		refPieces = new Array<RefTriangle>(false, size);
		refPieces.add(this);
		classicPieces.add(this);
		createReflections();
	}
	
	public RefTriangle(Polygon p, Color c, float rot, Array<RefTriangle> refPieces, int ref, int id) {
		this.ref = ref;
		this.id = id;
		this.refPieces = refPieces;
		this.polygon = p;
		this.color = c;
		this.rot = rot;
		polygon.setRotation(rot);
		classicPieces.add(this);
	}
	
	
	@Override
	public Array<RefTriangle> getRefs() {
		return refPieces;
	}
	
	@Override
	public Piece next() {
		return (Piece) refPieces.get(1);
	}
	
	private void createReflections() {
		if (ref == 1) {
			// Should make factory method to help with this...
			Polygon p_ = new Polygon(polygon.getVertices());
			p_.setOrigin(polygon.getOriginX(), polygon.getOriginY());
			p_.setScale(polygon.getScaleX(), -polygon.getScaleY());
			p_.translate(0, MozaicPlayer.height - MozaicPlayer.trans - 2*HEIGHT/3);
			RefTriangle rt2 = new RefTriangle(p_, color, (-rot) % 360, refPieces, ref, id);
			refPieces.add(rt2);
		}
	}

	@Override
	public void translateWOC(float x, float y) {
		RefTriangle p = refPieces.get(0);
		p.get().translate(x, y);
		if (ref == 1) {
			p = refPieces.get(1);
			p.get().translate(x, -y);
		}
				
	}

	
	@Override
	public boolean translate(float x, float y) {
		translateWOC(x, y);
		
		boolean f = true;
		iter1 = refPieces.iterator();
		
		while(iter1.hasNext() && f) {
			poly = iter1.next().get();
			if(Intersector.overlapConvexPolygons(poly, LEFT) || Intersector.overlapConvexPolygons(poly, RIGHT) ||
					Intersector.overlapConvexPolygons(poly, TOP) || Intersector.overlapConvexPolygons(poly, BOTTOM))
				f = false;
		}
		
		if (!f) {
			translateWOC(-x, -y);
			return false;
		}
		
		iter1 = refPieces.iterator();
		
		while (iter1.hasNext() && f) {
			p = iter1.next();
			poly = p.get();
			iter2 = classicPieces.iterator();
			
			while (iter2.hasNext() && f) {					
				q = (ClassicPiece) iter2.next();
				
				if (p != q && Intersector.overlapConvexPolygons(poly, q.get()))		
					f = false;
			}
		}
		
		if (!f) {
			translateWOC(-x, -y);
			return false;
		}
		
		return true;
	}



	@Override
	public void rotate45() {
		super.rotate45();
		if (refPieces.get(0) == this)
			refPieces.get(1).rotate_45();
	}

	public void draw(ShapeRenderer sr) {
		float[] coords = getVerts();
		sr.setColor(color);
		sr.filledTriangle(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
	}

	@Override
	public void createReflection() {
	}
	
	@Override
	public void delete() {
		iter1 = refPieces.iterator();
		while (iter1.hasNext())
			classicPieces.removeValue(iter1.next(), true);
	}

	@Override
	public ClassicPiece clonef() {
		Color c = color.cpy();
		c.a = 0.5f;
		RefTriangle triangle = new RefTriangle(new float[] {0, MozaicPlayer.trans, WIDTH, MozaicPlayer.trans, 0, MozaicPlayer.trans + HEIGHT}, rot, c, ref, id);
		triangle.translateWOC(polygon.getX(), polygon.getY());
		//Triangle triangle = new Triangle(polygon.getTransformedVertices(), 0, c, polygon.getOriginX(), polygon.getOriginY());
		return triangle;
	}
}



And here is the code for the RefTriangleFactory class:

public class RefTriangleFactory {

	private static final float HEIGHT = (float) (MozaicPlayer.scale * 100);
	private static final float WIDTH = HEIGHT;
	
	private RefTriangleFactory() {}

	public static RefTriangle create(float x, float y, float rot, Color color, int ref, int id) {
		RefTriangle triangle = new RefTriangle(new float[] {x, y, x + WIDTH, y, x, y + HEIGHT}, rot, color, ref, id);
		triangle.id = id;
		return triangle;
	}
	
	public static RefTriangle create(Color color, int ref, int id) {
		RefTriangle triangle = RefTriangleFactory.create(0, MozaicPlayer.trans, 0, color, ref, id);
		return triangle;
	}
	
	public static RefTriangle create(int ref, int id) {
		if (id == 0) {
			RefTriangle temp = create(Color.BLUE, ref, id);
			temp.translateWOC(MozaicPlayer.width*3/32, -MozaicPlayer.trans/2 - HEIGHT/3);
			return temp;
		}

		else if(id == 1) {
			RefTriangle temp = create(Color.GREEN, ref, id);
			temp.translateWOC(MozaicPlayer.width*10/32, -MozaicPlayer.trans/2 - HEIGHT/3);
			return temp;
		}
		
		else if (id == 2) {
			RefTriangle temp = create(Color.YELLOW, ref, id);
			temp.translateWOC(MozaicPlayer.width*3/32, -MozaicPlayer.trans + (MozaicPlayer.trans/2 - HEIGHT/3)/3);
			return temp;
		}

		else if(id == 3) {
			RefTriangle temp = create(Color.RED, ref, id);
			temp.translateWOC(MozaicPlayer.width*10/32, -MozaicPlayer.trans + (MozaicPlayer.trans/2 - HEIGHT/3)/3);
			return temp;
		}
		
		else if (id == 4) {
			RefTriangle temp = create(Color.CYAN, ref, id);
			temp.translateWOC(MozaicPlayer.width*3/32, -MozaicPlayer.trans/2 - HEIGHT/3 + 2*(MozaicPlayer.trans/2 - HEIGHT/3)/3);
			return temp;
		}

		else {
			RefTriangle temp = create(Color.MAGENTA, ref, id);
			temp.translateWOC(MozaicPlayer.width*10/32, -MozaicPlayer.trans/2 - HEIGHT/3 + 2*(MozaicPlayer.trans/2 - HEIGHT/3)/3);
			return temp;
		}
	}
}



There have been minor changes to the InputHandler, and SnapTo has changed thusly (sections highlighted):

			while (pieces.hasNext() && !snapped) {
				u = (ClassicPiece) pieces.next();
				if (u != dragging) {	
					ru = false;
					us = u.getVerts();
					u0.x = us[0]; u0.y = us[1];
					u1.x = us[2]; u1.y = us[3];
					u2.x = us[4]; u2.y = us[5];
					if (us.length > 7) {
						ru = true;
						u3.x = us[6]; u3.y = us[7];
					}
					*****
					ref = dragging.getRefs().contains(u, true);
					
					snapped = edge(v0, v1, v2, u0, u1, u2, dragging, ref);

					if (!snapped && r)
						snapped = edgeR(v0, v1, v2, v3, u0, u1, u2, dragging, ref);

					if (!snapped && ru) {
						snapped = edgeRU(v0, v1, v2, u0, u1, u2, u3, dragging, ref);
						if (!snapped && r)
							snapped = edgeRRU(v0, v1, v2, v3, u0, u1, u2, u3, dragging, ref);
					}
					*****
				}
			}
			
			if (!snapped) {
				vs = next.getVerts();
				// Initialise vectors, with the u vectors initially set as the corners of the screen
				v0.x = vs[0]; v0.y = vs[1];
				v1.x = vs[2]; v1.y = vs[3];
				v2.x = vs[4]; v2.y = vs[5];
				
				snapped = corner(v0, v1, v2, dragging);
	
				if (!snapped && vs.length > 7) {
					r = true;
					v3.x = vs[6]; v3.y = vs[7];
					
					snapped = cornerR(v3, dragging);
				}
				
				
				while (pieces.hasNext() && !snapped) {
					u = (ClassicPiece) pieces.next();
					if (u != dragging) {	
						ru = false;
						us = u.getVerts();
						u0.x = us[0]; u0.y = us[1];
						u1.x = us[2]; u1.y = us[3];
						u2.x = us[4]; u2.y = us[5];
						if (us.length > 7) {
							ru = true;
							u3.x = us[6]; u3.y = us[7];
						}
					
						*****
						ref = dragging.getRefs().contains(u, true);
						
						snapped = edge(v0, v1, v2, u0, u1, u2, dragging, ref);
	
						if (!snapped && r)
							snapped = edgeR(v0, v1, v2, v3, u0, u1, u2, dragging);
	
						if (!snapped && ru) {
							snapped = edgeRU(v0, v1, v2, u0, u1, u2, u3, dragging);
							if (!snapped && r)
								snapped = edgeRRU(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
						}
						*****
					}
				}
			}
			

Then here is the code for the edge() method, as an example:

private static boolean edge(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 u0,
			Vector2 u1, Vector2 u2, Piece dragging, boolean ref) {
		
		if(!ref)
			return edge(v0, v1, v2, u0, u1, u2, dragging);
		
		if (v0.dst(u0) < d && v1.dst(u1) < d)
			dragging.translateWOC((u0.x - v0.x)/2, (u0.y - v0.y)/2);
		
		else if (v0.dst(u0) < d && v1.dst(u2) < d)
			dragging.translateWOC((u0.x - v0.x)/2, (u0.y - v0.y)/2);
		
		
		else if (v0.dst(u1) < d && v1.dst(u0) < d)
			dragging.translateWOC((u1.x - v0.x)/2, (u1.y - v0.y)/2);
		
		else if (v0.dst(u1) < d && v1.dst(u2) < d)
			dragging.translateWOC((u1.x - v0.x)/2, (u1.y - v0.y)/2);
		
		
		else if (v0.dst(u2) < d && v1.dst(u0) < d)
			dragging.translateWOC((u2.x - v0.x)/2, (u2.y - v0.y)/2);
		
		else if (v0.dst(u2) < d && v1.dst(u1) < d)
			dragging.translateWOC((u2.x - v0.x)/2, (u2.y - v0.y)/2);
		
		
		
		
		else if (v0.dst(u0) < d && v2.dst(u1) < d)
			dragging.translateWOC((u0.x - v0.x)/2, (u0.y - v0.y)/2);
		
		else if (v0.dst(u0) < d && v2.dst(u2) < d)
			dragging.translateWOC((u0.x - v0.x)/2, (u0.y - v0.y)/2);
		
		
		else if (v0.dst(u1) < d && v2.dst(u0) < d)
			dragging.translateWOC((u1.x - v0.x)/2, (u1.y - v0.y)/2);
		
		else if (v0.dst(u1) < d && v2.dst(u2) < d)
			dragging.translateWOC((u1.x - v0.x)/2, (u1.y - v0.y)/2);
		
		
		else if (v0.dst(u2) < d && v2.dst(u0) < d)
			dragging.translateWOC((u2.x - v0.x)/2, (u2.y - v0.y)/2);
		
		else if (v0.dst(u2) < d && v2.dst(u1) < d)
			dragging.translateWOC((u2.x - v0.x)/2, (u2.y - v0.y)/2);
		
		
		
		
		else if (v1.dst(u0) < d && v2.dst(u1) < d)
			dragging.translateWOC((u0.x - v1.x)/2, (u0.y - v1.y)/2);
		
		else if (v1.dst(u0) < d && v2.dst(u2) < d)
			dragging.translateWOC((u0.x - v1.x)/2, (u0.y - v1.y)/2);
		
		
		else if (v1.dst(u1) < d && v2.dst(u0) < d)
			dragging.translateWOC((u1.x - v1.x)/2, (u1.y - v1.y)/2);
		
		else if (v1.dst(u1) < d && v2.dst(u2) < d)
			dragging.translateWOC((u1.x - v1.x)/2, (u1.y - v1.y)/2);
		
		
		else if (v1.dst(u2) < d && v2.dst(u0) < d)
			dragging.translateWOC((u2.x - v1.x)/2, (u2.y - v1.y)/2);
		
		else if (v1.dst(u2) < d && v2.dst(u1) < d)
			dragging.translateWOC((u2.x - v1.x)/2, (u2.y - v1.y)/2);
		
		else return false;
		
		return true;
	}
	
	
	
The issues with manipulating the 'reflected' shape need to be resolved, and more 'ref' values need to be implemented.
The idea behind this implementation is to create the shapes in a corner, and create the required reflection in the correct corner,
link the pieces together and translate them simultaneously in a 'reflected' manner.



----- 19.11.13 -----

-------------- BUG FIX --------------	

The problem with manipulating the 'reflected' shape was twofold, firstly the final translation wasn't being performed properly,
this was fixed by an update to translateWOC to properly deal with translating a piece other than the 'original'. Secondly,
the 'preview' pieces were moving in the opposite direction as to was expected. This was caused by the wrong triangle being returned
by the clonef() method, and also there were errors relating to the initialisation of the new RefTriangle object. The fixes are below.


	@Override
	public void translateWOC(float x, float y) {
		if (refPieces.get(0) == this) {
			RefTriangle p = refPieces.get(0);
			p.get().translate(x, y);
			if (ref == 1) {
				p = refPieces.get(1);
				p.get().translate(x, -y);
			}
		}
		else {
			RefTriangle p = refPieces.get(1);
			p.get().translate(x, y);
			if (ref == 1) {
				p = refPieces.get(0);
				p.get().translate(x, - y);
			}
		}
	}



	@Override
	public ClassicPiece clonef() {
		Color c = color.cpy();
		c.a = 0.5f;
		
		RefTriangle fst = refPieces.first();
		Polygon p = fst.get();
		
		RefTriangle triangle = new RefTriangle(new float[] {0, MozaicPlayer.trans, WIDTH, MozaicPlayer.trans, 0, MozaicPlayer.trans + HEIGHT}, fst.rot, c, ref, id);
		triangle.translateWOC(p.getX(), p.getY());
		if (this == refPieces.first())
			return triangle;
		else return (ClassicPiece) triangle.next();
	}
	
	

-------------- MORE REFLECTIONS --------------

I updated the code to add (to the x-axis reflection (ref 1)) y-axis reflection (ref 2), {y = -x} reflection (ref 3), {y = x} reflection (ref 4),
both x-axis and y-axis reflection (ref 5), and both {y = -x} and {y = x} reflection (ref 6).
Translation now works by finding the first element of refPieces and performing the appropriate translations to that RefTriangle. This
led to the creation of a helper method translate_(), which moves all the pieces accordingly given the movement of the first piece.
There are similar rotation helper methods, for the same reason and purpose. Also the rotation methods were updated so that if rotation
fails for any one of the pieces in refPieces, all of the pieces fail to rotate.


This also involved the creation of a method reflect() in RefTriangleFactory:

	public static void reflect(float transX, float transY, int scaleX, int scaleY, float rot, Array<RefTriangle> refPieces,
			Color color, int ref, int id) {
		RefTriangle temp = new RefTriangle(new float[] {0, MozaicPlayer.trans, WIDTH, MozaicPlayer.trans, 0, MozaicPlayer.trans + HEIGHT}, rot, color, ref, id, refPieces);
		Polygon poly = temp.get();
		poly.setScale(scaleX, scaleY);
		poly.translate(transX, transY);
	}
	

public class RefTriangle extends ClassicPiece {	
	private Array<RefTriangle> refPieces;
	private int ref;
	private ClassicPiece p;
	private Polygon poly;
	private Iterator<RefTriangle> iter1;
	private Iterator<Piece> iter2;
	private static float ORIGINOFFSET = (float) (MozaicPlayer.scale*100/3);
	private boolean spawned;

	private static final float HEIGHT = (float) (MozaicPlayer.scale * 100);
	private static final float WIDTH = HEIGHT;

	public RefTriangle(float[] coords, float rot, Color color, int ref, int id) {
		
		polygon = new Polygon(coords);
		this.color = color;
		this.rot = rot;
		polygon.setRotation(rot);
		polygon.setOrigin(coords[0] + ORIGINOFFSET, coords[1] + ORIGINOFFSET);
		
		this.id = id;
		this.ref = ref;
		int size = 2;
		if (ref > 4)
			size += 2;
		refPieces = new Array<RefTriangle>(false, size);
		refPieces.add(this);
		classicPieces.add(this);
		createReflections();
		
		spawned = true;
	}
	
	public RefTriangle(float[] coords, float rot, Color color, int ref, int id, Array<RefTriangle> refPieces) {
		
		polygon = new Polygon(coords);
		this.color = color;
		this.rot = rot;
		polygon.setRotation(rot);
		polygon.setOrigin(coords[0] + ORIGINOFFSET, coords[1] + ORIGINOFFSET);
		
		this.id = id;
		this.ref = ref;
		this.refPieces = refPieces;
		refPieces.add(this);
		classicPieces.add(this);
		
		spawned = false;
	}
	
	private void spawn_() {
		spawned = true;
	}
	
	public void spawn() {
		for (RefTriangle p : refPieces)
			p.spawn_();
	}
	
	@Override
	public Array<RefTriangle> getRefs() {
		return refPieces;
	}
		
	private void createReflections() {
		if (ref == 1 || ref == 5)
			RefTriangleFactory.reflect(0, MozaicPlayer.height - MozaicPlayer.trans - 2*HEIGHT/3, 1, -1, (-rot) % 360, refPieces, color, ref, id);
		
		if (ref == 2 || ref == 5)
			RefTriangleFactory.reflect(MozaicPlayer.width - 2*WIDTH/3, 0, -1, 1, (-rot) % 360, refPieces, color, ref, id);
		
		if (ref == 3 || ref == 6)
			RefTriangleFactory.reflect(MozaicPlayer.width - 2*WIDTH/3, MozaicPlayer.height - MozaicPlayer.trans - 2*HEIGHT/3, -1, -1, (-rot) % 360, refPieces, color, ref, id);

		if (ref == 4 || ref == 6)
			RefTriangleFactory.reflect(0, 0, 1, 1, (-rot) % 360, refPieces, color, ref, id);
		
		if (ref == 5 || ref == 6)
			RefTriangleFactory.reflect(MozaicPlayer.width - 2*WIDTH/3, MozaicPlayer.height - MozaicPlayer.trans - 2*HEIGHT/3, -1, -1, rot, refPieces, color, ref, id);
	}

	private void translateWOC_(float x, float y) {
		RefTriangle p = refPieces.get(0);
		p.get().translate(x, y);
		p = refPieces.get(1);
		if (ref == 1 || ref == 5)
			p.get().translate(x, -y);
		if (ref == 2)
			p.get().translate(-x, y);
		if (ref == 3 || ref == 6)
			p.get().translate(-y, -x);
		if (ref == 4)
			p.get().translate(y, x);
			
		if (ref > 4) {
			p = refPieces.get(2);
			if (ref == 5)
				p.get().translate(-x, y);
			if (ref == 6)
				p.get().translate(y, x);
			
			p = refPieces.get(3);
			if (ref == 5)
				p.get().translate(-x, -y);
			if (ref == 6)
				p.get().translate(-x, -y);
		}
	}
	
	@Override
	public void translateWOC(float x, float y) {
		if (refPieces.get(0) == this) 
			translateWOC_(x, y);
		if (refPieces.get(1) == this) {
			if (ref == 1 || ref == 5)
				translateWOC_(x, -y);
			if (ref == 2)
				translateWOC_(-x, y);
			if (ref == 3 || ref == 6)
				translateWOC_(-y, -x);
			if (ref == 4)
				translateWOC_(y, x);
		}
		
		if (ref > 4) {
			if (refPieces.get(2) == this) {
				if (ref == 5)
					translateWOC_(-x, y);
				if (ref == 6)
					translateWOC_(y, x);
			}
			if (refPieces.get(3) == this) {
				if (ref == 5)
					translateWOC_(-x, -y);
				if (ref == 6)
					translateWOC_(-x, -y);
			}
		}
	}

	
	@Override
	public boolean translate(float x, float y) {
		translateWOC(x, y);
		
		boolean f = true;
		iter1 = refPieces.iterator();
		
		while(iter1.hasNext() && f) {
			poly = iter1.next().get();
			if(Intersector.overlapConvexPolygons(poly, LEFT) || Intersector.overlapConvexPolygons(poly, RIGHT) ||
					Intersector.overlapConvexPolygons(poly, TOP) || Intersector.overlapConvexPolygons(poly, BOTTOM))
				f = false;
		}
		
		if (!f) {
			translateWOC(-x, -y);
			return false;
		}
		
		iter1 = refPieces.iterator();
		
		while (iter1.hasNext() && f) {
			p = iter1.next();
			poly = p.get();
			iter2 = classicPieces.iterator();
			
			while (iter2.hasNext() && f) {					
				q = (ClassicPiece) iter2.next();
				
				if (p != q && Intersector.overlapConvexPolygons(poly, q.get()))		
					f = false;
			}
		}
		
		
		if (!f) {
			translateWOC(-x, -y);
			return false;
		}
		
		return true;
	}
	
	/*private void rotate45_WOC() {
		super.rotate45WOC();
		if (ref == 1)
			refPieces.get(1).rotate_45WOC();
	}
	
	private void rotate_45_WOC() {
		super.rotate_45WOC();
		if (ref == 1)
			refPieces.get(1).rotate45WOC();
	}
	*/

	private boolean rotate45_() {
		boolean ret = super.rotate45();
		if (ret) {
			if (ref == 1 || ref == 2 || ref == 3 || ref == 4 || ref == 5 || ref == 6) {
				if (!refPieces.get(1).rotate_45()) {
					ret = false;
					super.rotate_45WOC();
				}
			}
		}
		
		if (ret && ref > 4) {
			if (ref == 5 || ref == 6) {
				if (!refPieces.get(2).rotate_45()) {
					super.rotate_45WOC();
					refPieces.get(1).rotate45WOC();
					ret = false;
				}
			}
			
			if (ret) {
				if (ref == 5 || ref == 6) {
					if (!refPieces.get(3).srotate45()) {
						super.rotate_45WOC();
						refPieces.get(1).rotate45WOC();
						refPieces.get(2).rotate45WOC();
						ret = false;
					}
				}
			}
		}
		
		return ret;
	}
	
	private boolean rotate_45_() {
		boolean ret = super.rotate_45();
		if (ret) {
			if (ref == 1 || ref == 2 || ref == 3 || ref == 4 || ref == 5 || ref == 6) {
				if (!refPieces.get(1).srotate45()) {
					super.rotate45WOC();
					ret = false;
				}
			}
			
			if (ret && ref > 4) {
				if (ref == 5 || ref == 6) {
					if (!refPieces.get(2).srotate45()) {
						super.rotate45WOC();
						refPieces.get(1).rotate45WOC();
						ret = false;
					}
				}
				if (ret) {
					if (ref == 5 || ref == 6) {
						if (!refPieces.get(3).rotate_45()) {
							super.rotate45WOC();
							refPieces.get(1).rotate_45WOC();
							refPieces.get(2).rotate_45WOC();
							ret = false;
						}
					}
				}
			}
		}
		
		return ret;
	}
	
	private boolean srotate45() {
		return super.rotate45();
	}
	
	@Override
	public boolean rotate45() {
		if (refPieces.get(0) == this) 
			return rotate45_();
		if (refPieces.get(1) == this) 
			return refPieces.get(0).rotate_45_();
		if (refPieces.get(2) == this) {
			if (ref == 5 || ref == 6)
				return refPieces.get(0).rotate_45_();
		}
		if (refPieces.get(3) == this) {
			if (ref == 5 || ref == 6)
				return refPieces.get(0).rotate45_();
		}
			
		return false;
	}

	
	public void draw(ShapeRenderer sr) {
		if (spawned) {
			float[] coords = getVerts();
			sr.setColor(color);
			sr.filledTriangle(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
		}
	}
	
	@Override
	public void delete() {
		iter1 = refPieces.iterator();
		while (iter1.hasNext())
			classicPieces.removeValue(iter1.next(), true);
	}

	@Override
	public ClassicPiece clonef() {
		Color c = color.cpy();
		c.a = 0.5f;
		
		RefTriangle fst = refPieces.first();
		Polygon p = fst.get();
		
		RefTriangle triangle = new RefTriangle(new float[] {0, MozaicPlayer.trans, WIDTH, MozaicPlayer.trans, 0, MozaicPlayer.trans + HEIGHT}, fst.rot, c, ref, id);
		triangle.translateWOC(p.getX(), p.getY());
		triangle.spawn();
		
		if (this == refPieces.get(0))
			return triangle;
		if (this == refPieces.get(1))
			return triangle.get(1);
		if (this == refPieces.get(2))
			return triangle.get(2);
		else return triangle.get(3);
	}

	private ClassicPiece get(int i) {
		return refPieces.get(i);
	}

	public int getRef() {
		return ref;
	}
}



----- 03.12.13 -----

-------------- REFLECTING RHOMBUSES --------------	
	
I adapted the RefTriangle class into a working RefRhombus class. This only required a few small changes. I also had to update the InputHandler code
so that it no longer cast calues to RefTriangle, and instead I added more methods to the Piece interface. In the future I will most likely
create an abstract class RefPiece, since RefTriangle and RefRhombus have a lot of overlapping code.

Here are the sections that were different in RefRhombus than RefTriangle (other than changing Triangle to Rhombus):

	private static float ORIGINOFFSET = (float) (MozaicPlayer.scale*100/Math.sqrt(2)/2);
	private static final float HEIGHT = (float) (MozaicPlayer.scale * (100 / Math.sqrt(2)));
	private static float WIDTH = (float) (MozaicPlayer.scale * 100);
	private static float SLIDE = HEIGHT;
	
	public RefRhombus(float[] coords, float rot, Color color, int ref, int id) {
		...
		polygon.setOrigin((coords[2] + coords[6]) / 2, coords[1] + ORIGINOFFSET);
	}		
	
	public RefRhombus(float[] coords, float rot, Color color, int ref, int id, Array<RefRhombus> refPieces) {
		...
		polygon.setOrigin((coords[2] + coords[6]) / 2, coords[1] + ORIGINOFFSET);
	}
	
	private void createReflections() {
		if (ref == 1 || ref == 5)
			RefRhombusFactory.reflect(0, MozaicPlayer.height - MozaicPlayer.trans - HEIGHT, 1, -1, (-rot) % 360, refPieces, color, ref, id);
		
		if (ref == 2 || ref == 5)
			RefRhombusFactory.reflect(MozaicPlayer.width - WIDTH - SLIDE , 0, -1, 1, (-rot) % 360, refPieces, color, ref, id);
		
		if (ref == 3 || ref == 6)
			RefRhombusFactory.reflect(MozaicPlayer.width - WIDTH - SLIDE, MozaicPlayer.height - MozaicPlayer.trans - HEIGHT, -1, -1, (-rot) % 360, refPieces, color, ref, id);

		if (ref == 4 || ref == 6)
			RefRhombusFactory.reflect(0, 0, 1, 1, (-rot) % 360, refPieces, color, ref, id);
		
		if (ref == 5 || ref == 6)
			RefRhombusFactory.reflect(MozaicPlayer.width - WIDTH - SLIDE, MozaicPlayer.height - MozaicPlayer.trans - HEIGHT, -1, -1, rot, refPieces, color, ref, id);	
	}
	
	public void draw(ShapeRenderer sr) {
		if (spawned) {
			float[] coords = getVerts();
			sr.setColor(color);
			sr.filledTriangle(coords[0], coords[1], coords[2], coords[3], coords[6], coords[7]);
			sr.filledTriangle(coords[2], coords[3], coords[4], coords[5], coords[6], coords[7]);
		}
	}
	
	public ClassicPiece clonef() {
		...
		float t = MozaicPlayer.trans;
		RefRhombus rhombus = new RefRhombus(new float[] {0, t, SLIDE, t + HEIGHT, SLIDE + WIDTH, t + HEIGHT, WIDTH, t}, fst.rot, c, ref, id);
	}	
	
	
This obviously required a RefRhombusFactory, which as expected was based on the RefTriangleFactory:

	public class RefRhombusFactory {
		
		private static final float HEIGHT = (float) (MozaicPlayer.scale * (100 / Math.sqrt(2)));
		private static float WIDTH = (float) (MozaicPlayer.scale * 100);
		private static float SLIDE = HEIGHT;
		
		private RefRhombusFactory() {}
	
		public static RefRhombus create(float x, float y, float rot, Color color, int ref, int id) {
			RefRhombus rhombus = new RefRhombus(new float[] {x, y, x + SLIDE, y + HEIGHT, x + SLIDE + WIDTH, y + HEIGHT, x + WIDTH, y}, rot, color, ref, id);
			rhombus.id = id;
			return rhombus;
		}
		
		public static RefRhombus create(Color color, int ref, int id) {
			RefRhombus rhombus = RefRhombusFactory.create(0, MozaicPlayer.trans, 0, color, ref, id);
			return rhombus;
		}
		
		
		public static RefRhombus create(int ref, int id) {
			if (id == MozaicPlayer.ClassicID + 1) {
				RefRhombus temp = create(Color.BLUE, ref, id);
				temp.translateWOC(MozaicPlayer.width*15/32, -(MozaicPlayer.trans + HEIGHT)/2);
				return temp;
			}
	
			else if (id == MozaicPlayer.ClassicID + 2) {
				RefRhombus temp = create(Color.GREEN, ref, id);
				temp.translateWOC(MozaicPlayer.width*23/32, -(MozaicPlayer.trans + HEIGHT)/2);
				return temp;
			}
			
			else if (id == MozaicPlayer.ClassicID + 3) {
				RefRhombus temp = create(Color.YELLOW, ref, id);
				temp.translateWOC(MozaicPlayer.width*15/32, -(5*MozaicPlayer.trans + HEIGHT)/6);
				return temp;
			}
	
			else {
				RefRhombus temp = create(Color.CYAN, ref, id);
				temp.translateWOC(MozaicPlayer.width*23/32, -(5*MozaicPlayer.trans + HEIGHT)/6);
				return temp;
			}
		}
	
	
		public static void reflect(float transX, float transY, int scaleX, int scaleY, float rot, Array<RefRhombus> refPieces,
				Color color, int ref, int id) {
			float t = MozaicPlayer.trans;
			RefRhombus temp = new RefRhombus(new float[] {0, t, SLIDE, t + HEIGHT, SLIDE + WIDTH, t + HEIGHT, WIDTH, t}, rot, color, ref, id, refPieces);
			Polygon poly = temp.get();
			poly.setScale(scaleX, scaleY);
			poly.translate(transX, transY);
		}
	}
	
	
	
I also updated the replace method in the InputHandler.

	private void replace(int ref, int id) {
		if (id > MozaicPlayer.ClassicID)
			RefRhombusFactory.create(ref, id);
		else RefTriangleFactory.create(ref, id);
	}	


-------------- (PARTIAL) BUGFIX --------------

SnapTo seems to fail when the distance between the pieces is larger.
**(Note there are still issues when it comes to snapping when 4 pieces are being manipulated)**

There was an error in the SnapTo class, the methods:

edgeR(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0, Vector2 u1, Vector2 u2, Piece dragging, boolean ref)
edgeRU(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 u0, Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging, boolean ref)
edgeRRU(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0, Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging, boolean ref)

were all missing a division by 2 of the change in y coordinate.

e.g.

	if (v3.dst(u3) < d && v0.dst(u0) < d)
		dragging.translateWOC((u3.x - v3.x)/2, (u3.y - v3.y));
		
where we should have had

	if (v3.dst(u3) < d && v0.dst(u0) < d)
		dragging.translateWOC((u3.x - v3.x)/2, (u3.y - v3.y)/2);
		
		


		
		
	private void srotate45WOC() {
		super.rotate45WOC();
	}
	
	@Override
	public void rotate45WOC() {
		assert (refPieces.get(0) == this);
		super.rotate45WOC();
		if (ref == 1 || ref == 2 || ref == 3 || ref == 4 || ref == 5 || ref == 6)
			refPieces.get(1).rotate_45WOC();
		
		if (ref == 5 || ref == 6) {
			refPieces.get(2).rotate_45WOC();
			refPieces.get(3).srotate45WOC();
		}
	}		
		
		
		
----- 04.12.13 -----

-------------- UNTITLED --------------	

I updated the InputHandler and RefTriangle and RefRhombus classes to allow rotation whilst on the black area of the screen.
The following code is currently in both RefTriangle and RefRhombus.

	private void srotate45WOC() {
		super.rotate45WOC();
	}
	
	@Override
	public void rotate45WOC() {
		assert (refPieces.get(0) == this);
		super.rotate45WOC();
		if (ref == 1 || ref == 2 || ref == 3 || ref == 4 || ref == 5 || ref == 6)
			refPieces.get(1).rotate_45WOC();
		
		if (ref == 5 || ref == 6) {
			refPieces.get(2).rotate_45WOC();
			refPieces.get(3).srotate45WOC();
		}
	}
	

And the touchDown() method of the InputHandler was updated to:

	if (button == 2) {
		touch.set(screenX, screenY, 0);
		world.getRenderer().getCamera().unproject(touch);
		ClassicPiece rotate = (ClassicPiece) world.underMouse(touch.x, touch.y);
		if (rotate != null) {
			if (touch.y < MozaicPlayer.trans)
				rotate.rotate45WOC();
			else rotate.rotate45();
		}
	}
	
	
-------------- BUGFIX --------------
	
If one piece fails to rotate because of a self collision, the others do not undo.

Caused by addition of overrided rotate45WOC. This meant that the calls to undo the rotation no longer
called a super method, but the new method, and so srotate45WOC() is required instead. This change
applies to both RefTriangle and RefRhombus.


private boolean rotate45_() {
		boolean ret = super.rotate45();
		if (ret) {
			if (ref == 1 || ref == 2 || ref == 3 || ref == 4 || ref == 5 || ref == 6) {
				if (!refPieces.get(1).rotate_45()) {
					ret = false;
					super.rotate_45WOC();
				}
			}
		}
		
		if (ret && ref > 4) {
			if (ref == 5 || ref == 6) {
				if (!refPieces.get(2).rotate_45()) {
					super.rotate_45WOC();
					refPieces.get(1).srotate45WOC();
					ret = false;
				}
			}
			
			if (ret) {
				if (ref == 5 || ref == 6) {
					if (!refPieces.get(3).srotate45()) {
						super.rotate_45WOC();
						refPieces.get(1).srotate45WOC();
						refPieces.get(2).srotate45WOC();
						ret = false;
					}
				}
			}
		}
		
		return ret;
	}
	
	
	// This helper method rotates all the pieces in refPieces appropriately given the rotation -ve 45 is to be applied to the first piece.
	private boolean rotate_45_() {
		boolean ret = super.rotate_45();
		if (ret) {
			if (ref == 1 || ref == 2 || ref == 3 || ref == 4 || ref == 5 || ref == 6) {
				if (!refPieces.get(1).srotate45()) {
					super.rotate45WOC();
					ret = false;
				}
			}
			
			if (ret && ref > 4) {
				if (ref == 5 || ref == 6) {
					if (!refPieces.get(2).srotate45()) {
						super.rotate45WOC();
						refPieces.get(1).rotate_45WOC();
						ret = false;
					}
				}
				if (ret) {
					if (ref == 5 || ref == 6) {
						if (!refPieces.get(3).rotate_45()) {
							super.rotate45WOC();
							refPieces.get(1).rotate_45WOC();
							refPieces.get(2).rotate_45WOC();
							ret = false;
						}
					}
				}
			}
		}
		
		return ret;
	}	
		
		
		
----- 22.12.13 -----

-------------- BUGFIX --------------					
		
SnapTo seems to fail when the distance between the pieces is larger.

I used the idea
	Could implement SnapTo as returning the value that the dragging object needs to be translated by,
	ratherthan performing the translation itself and simply returning a boolean.
to fix this bug, caused by overcompensation when undoing after an overlap occurred, and other issues.

InputHandler has been updated to:

	// Allows for overlapping shapes to snap together
	dragging.translateWOC(x - initX, y - initY);
	
	// Prevents overlapping shapes if no snap-to takes place
	snapped = SnapTo.snap(dragging, getIterator());
	if (!snapped.l) {
		dragging.translateWOC(initX - x, initY - y);
		
		// Attempts a translation with overlapping checks, in case shape is moved to 'empty space'
		if (dragging.translate(x - initX, y - initY)) {
			if(isNew) {
				replace(dragging.getRef(), dragging.getID());
			dragging.spawn();
		}
			MozaicAudio.drag();						
		}
		else
			MozaicAudio.dragFail();
	}
	
	else {
		dragging.translateWOC(snapped.r.x, snapped.r.y);
		
		// If a snap has occurred, check for 'third party' overlaps
		if (dragging.overlaps()) {
			dragging.translateWOC(initX - x - snapped.r.x, initY - y - snapped.r.y);
			MozaicAudio.dragFail();
		}
		else {
			if(isNew) {
				replace(dragging.getRef(), dragging.getID());
				dragging.spawn();
			}
			MozaicAudio.dragSnap();
		}
	}
	dragging = null;
	isNew = false;			
		

SnapTo has been updated in several areas, it now returns a tuple (a simple class Tuple<X,Y> I implemented) of a
boolean and a vector. Obviously this required most/all of the methods to be changed, they now accept a tuple
and change the values contained within that tuple and return nothing.

	public static Tuple<Boolean, Vector2> snap(Piece dragging, Iterator<Piece> pieces) {
		Tuple<Boolean, Vector2> snapped = new Tuple(false, new Vector2(0, 0));
		
		...
		
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2();
			v0.x = vs[0]; v0.y = vs[1];
			v1.x = vs[2]; v1.y = vs[3];
			v2.x = vs[4]; v2.y = vs[5];
			
	//		snapped = corner(v0, v1, v2, dragging);

			if (/*!snapped && */vs.length > 7) {
				r = true;
				v3.x = vs[6]; v3.y = vs[7];
				
	//			snapped = cornerR(v3, dragging);
			}
		
			Array<ClassicPiece> refs = dragging.getRefs();
			
			while (pieces.hasNext() && !snapped.l) {
				
				u = (ClassicPiece) pieces.next();
				if (u != dragging) {	
					ru = false;
					us = u.getVerts();
					u0.x = us[0]; u0.y = us[1];
					u1.x = us[2]; u1.y = us[3];
					u2.x = us[4]; u2.y = us[5];
					if (us.length > 7) {
						ru = true;
						u3.x = us[6]; u3.y = us[7];
					}
					
					ref = refs.contains(u, true);
					
					edge(v0, v1, v2, u0, u1, u2, dragging, ref, snapped);

					if (!snapped.l && r)
						edgeR(v0, v1, v2, v3, u0, u1, u2, dragging, ref, snapped);

					if (!snapped.l && ru) {
						edgeRU(v0, v1, v2, u0, u1, u2, u3, dragging, ref, snapped);
						if (!snapped.l && r)
							edgeRRU(v0, v1, v2, v3, u0, u1, u2, u3, dragging, ref, snapped);
					}
				}
			}
			
			
			if (snapped.l && refs.size > 2) {
				dragging.translateWOC(snapped.r.x, snapped.r.y);
				System.out.println(snapped.r.x + ", " + snapped.r.y);

				if (snapped.r.x == 0) {
					if (vs.length > 7)
						snap4x(v0, v1, v2, v3, dragging, refs, snapped);
					else snap4x(v0, v1, v2, dragging, refs, snapped);
					dragging.translateWOC(0, -snapped.r.y);
				}
				else {
					if (vs.length > 7)
						snap4y(v0, v1, v2, v3, dragging, refs, snapped);
					else snap4y(v0, v1, v2, dragging, refs, snapped);
					dragging.translateWOC(-snapped.r.x, 0);
				}
			}	
		

snap4 has been replaced by snap4y and snap4x, shown here are 2 of the methods, the corresponding methods
should be obvious to work out (in fact I will probably change this, since the difference is so minor)

private static void snap4y(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Piece dragging, Array<ClassicPiece> refs, Tuple<Boolean, Vector2> tuple) {
		Tuple<Boolean, Vector2> tuple_ = new Tuple(false, new Vector2(0, 0));
		Vector2[][] us = new Vector2[3][4];
		Iterator<ClassicPiece> iter = refs.iterator();
		float[] u;
		ClassicPiece u_;
		int i = 0;
		while (i < 3 && iter.hasNext()) {
			u_ = iter.next();
			if (u_ != dragging) {
				u = u_.getVerts();
				for (int j = 0; j < 4; j++)
					us[i][j] = new Vector2(u[2*j], u[2*j+1]);
				i++;
			}
		}
		boolean found = false;
		Vector2[] match;
		i = 0;
		while (!found && i < 3) {
			match = us[i];
			if (v0.dst(match[0]) < 0.01) {
				if (v1.dst(match[1]) < 0.01 || v1.dst(match[3]) < 0.01 || v3.dst(match[1]) < 0.01 || v3.dst(match[3]) < 0.01)
					found = true;
			}
			
			else if (v0.dst(match[1]) < 0.01) {
				if (v1.dst(match[0]) < 0.01 || v1.dst(match[2]) < 0.01 || v3.dst(match[0]) < 0.01 || v3.dst(match[2]) < 0.01)
					found = true;
			}
			
			else if (v0.dst(match[2]) < 0.01) {
				if (v1.dst(match[1]) < 0.01 || v1.dst(match[3]) < 0.01 || v3.dst(match[1]) < 0.01 || v3.dst(match[3]) < 0.01)
					found = true;
			}
			
			else if (v0.dst(match[3]) < 0.01) {
				if (v1.dst(match[2]) < 0.01 || v1.dst(match[0]) < 0.01 || v3.dst(match[2]) < 0.01 || v3.dst(match[0]) < 0.01)
					found = true;
			}
			
			else if (v2.dst(match[0]) < 0.01) {
				if (v1.dst(match[1]) < 0.01 || v1.dst(match[3]) < 0.01 || v3.dst(match[1]) < 0.01 || v3.dst(match[3]) < 0.01)
					found = true;
			}
			
			else if (v2.dst(match[1]) < 0.01) {
				if (v1.dst(match[0]) < 0.01 || v1.dst(match[2]) < 0.01 || v3.dst(match[0]) < 0.01 || v3.dst(match[2]) < 0.01)
					found = true;
			}
			
			else if (v2.dst(match[2]) < 0.01) {
				if (v1.dst(match[1]) < 0.01 || v1.dst(match[3]) < 0.01 || v3.dst(match[1]) < 0.01 || v3.dst(match[3]) < 0.01)
					found = true;
			}
			
			else if (v2.dst(match[3]) < 0.01) {
				if (v1.dst(match[2]) < 0.01 || v1.dst(match[0]) < 0.01 || v3.dst(match[2]) < 0.01 || v3.dst(match[0]) < 0.01)
					found = true;
			}
			else i++;
		}
		
		for (int j = 0; j < 3; j++) {
			if (j != i) {
				match = us[j];
				
				edge(v0, v1, v2, match[0], match[1], match[2], dragging, true, tuple_);

				if (!tuple.l)
					edgeR(v0, v1, v2, v3, match[0], match[1], match[2], dragging, true, tuple_);

				if (!tuple.l)
					edgeRU(v0, v1, v2, match[0], match[1], match[2], match[3], dragging, true, tuple_);
				if (!tuple.l)
					edgeRRU(v0, v1, v2, v3, match[0], match[1], match[2], match[3], dragging, true, tuple_);
			}
		}
		tuple.r.y = tuple_.r.y*2;
	}
	
	
	private static void snap4x(Vector2 v0, Vector2 v1, Vector2 v2, Piece dragging, Array<ClassicPiece> refs, Tuple<Boolean, Vector2> tuple) {
		Tuple<Boolean, Vector2> tuple_ = new Tuple(false, new Vector2(0, 0));
		Vector2[][] us = new Vector2[3][3];
		Iterator<ClassicPiece> iter = refs.iterator();
		float[] u;
		ClassicPiece u_;
		int i = 0;
		while (i < 3 && iter.hasNext()) {
			u_ = iter.next();
			if (u_ != dragging) {
				u = u_.getVerts();
				for (int j = 0; j < 3; j++)
					us[i][j] = new Vector2(u[2*j], u[2*j+1]);
				i++;
			}
		}
		boolean found = false;
		Vector2[] match;
		i = 0;
		while (!found && i < 3) {
			match = us[i];
			if (v0.dst(match[0]) < 0.01) {
				if (v1.dst(match[1]) < 0.01 || v1.dst(match[2]) < 0.01 || v2.dst(match[1]) < 0.01 || v2.dst(match[2]) < 0.01)
					found = true;
			}
			
			else if (v0.dst(match[1]) < 0.01) {
				if (v1.dst(match[0]) < 0.01 || v1.dst(match[2]) < 0.01 || v2.dst(match[0]) < 0.01 || v2.dst(match[2]) < 0.01)
					found = true;
			}
			
			else if (v0.dst(match[2]) < 0.01) {
				if (v1.dst(match[0]) < 0.01 || v1.dst(match[1]) < 0.01 || v2.dst(match[0]) < 0.01 || v2.dst(match[1]) < 0.01)
					found = true;
			}
			
			else if (v1.dst(match[0]) < 0.01) {
				if (v2.dst(match[1]) < 0.01 || v2.dst(match[2]) < 0.01)
					found = true;
			}
			
			else if (v1.dst(match[1]) < 0.01) {
				if (v2.dst(match[0]) < 0.01 || v2.dst(match[2]) < 0.01)
					found = true;
			}
			
			else if (v1.dst(match[2]) < 0.01) {
				if (v2.dst(match[0]) < 0.01 || v2.dst(match[1]) < 0.01)
					found = true;
			}
			else i++;
		}
		
		for (int j = 0; j < 3; j++) {
			if (j != i) {
				match = us[j];
				edge(v0, v1, v2, match[0], match[1], match[2], dragging, true, tuple_);
			}
		}
		tuple.r.x = tuple_.r.x*2;
	}
	
			
The edge methods have been updated as such:

	private static void edge(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 u0,
			Vector2 u1, Vector2 u2, Piece dragging, Tuple<Boolean, Vector2> tuple) {
		
		if (v0.dst(u0) < d && v1.dst(u1) < d)
			tuple.r = new Vector2(u0.x - v0.x, u0.y - v0.y);
		
		else if (v0.dst(u0) < d && v1.dst(u2) < d)
			tuple.r = new Vector2(u0.x - v0.x, u0.y - v0.y);
		
		
		else if (v0.dst(u1) < d && v1.dst(u0) < d)
			tuple.r = new Vector2(u1.x - v0.x, u1.y - v0.y);
		
		else if (v0.dst(u1) < d && v1.dst(u2) < d)
			tuple.r = new Vector2(u1.x - v0.x, u1.y - v0.y);
		
		
		else if (v0.dst(u2) < d && v1.dst(u0) < d)
			tuple.r = new Vector2(u2.x - v0.x, u2.y - v0.y);
		
		else if (v0.dst(u2) < d && v1.dst(u1) < d)
			tuple.r = new Vector2(u2.x - v0.x, u2.y - v0.y);
		
		
		
		
		else if (v0.dst(u0) < d && v2.dst(u1) < d)
			tuple.r = new Vector2(u0.x - v0.x, u0.y - v0.y);
		
		else if (v0.dst(u0) < d && v2.dst(u2) < d)
			tuple.r = new Vector2(u0.x - v0.x, u0.y - v0.y);
		
		
		else if (v0.dst(u1) < d && v2.dst(u0) < d)
			tuple.r = new Vector2(u1.x - v0.x, u1.y - v0.y);
		
		else if (v0.dst(u1) < d && v2.dst(u2) < d)
			tuple.r = new Vector2(u1.x - v0.x, u1.y - v0.y);
		
		
		else if (v0.dst(u2) < d && v2.dst(u0) < d)
			tuple.r = new Vector2(u2.x - v0.x, u2.y - v0.y);
		
		else if (v0.dst(u2) < d && v2.dst(u1) < d)
			tuple.r = new Vector2(u2.x - v0.x, u2.y - v0.y);
		
		
		
		
		else if (v1.dst(u0) < d && v2.dst(u1) < d)
			tuple.r = new Vector2(u0.x - v1.x, u0.y - v1.y);
		
		else if (v1.dst(u0) < d && v2.dst(u2) < d)
			tuple.r = new Vector2(u0.x - v1.x, u0.y - v1.y);
		
		
		else if (v1.dst(u1) < d && v2.dst(u0) < d)
			tuple.r = new Vector2(u1.x - v1.x, u1.y - v1.y);
		
		else if (v1.dst(u1) < d && v2.dst(u2) < d)
			tuple.r = new Vector2(u1.x - v1.x, u1.y - v1.y);
		
		
		else if (v1.dst(u2) < d && v2.dst(u0) < d)
			tuple.r = new Vector2(u2.x - v1.x, u2.y - v1.y);
		
		else if (v1.dst(u2) < d && v2.dst(u1) < d)
			tuple.r = new Vector2(u2.x - v1.x, u2.y - v1.y);
		
		else return;
		
		tuple.l = true;
	}		
		
		
	private static void edge(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 u0,
			Vector2 u1, Vector2 u2, Piece dragging, boolean ref, Tuple<Boolean, Vector2> tuple) {
		
		edge(v0, v1, v2, u0, u1, u2, dragging, tuple);

		if(ref && tuple.l)
			tuple.r.div(2);
	}	
		
		
		
----- 27-28.12.13 -----

-------------- TIDYING UP --------------			
	
See version 0.1.0 for the results after tidying.	
	
I fixed many tiny issues in the code, so that all three types of game work. I then started to improve areas of code that were
'messy', the largest change was creating a new abstract class, ReflectPiece, which extends ClassicPiece, and contains the common
methods previously found in RefRhombus and RefTriangle. The aim of these changes was to make the code easier to understand, and
make more use of object-oriented design patterns.

There was also a fairly large change in the InputHandler, replace now works as follows. This, along with addition type casting,
allowed me to remove the error throwing methods I was using in ClassicPiece and PenrosePiece, and just have the working methods in
the ReflectPiece class.

	private void replace(Piece piece) {
		if (MozaicPlayer.GAMEMODE == GameMode.Classic)
			replace((ClassicPiece) piece);
		else if (MozaicPlayer.GAMEMODE == GameMode.PenroseKD)
			replace((PenrosePiece) piece);
		else if (MozaicPlayer.GAMEMODE == GameMode.Reflect)
			replace((ReflectPiece) piece);
	}

	private void replace(PenrosePiece piece) {
		int id = piece.getID();
		if (id > MozaicPlayer.PenroseID)
			ArrowFactory.create(id);
		else 
			KiteFactory.create(id);
	}
	
	private void replace(ReflectPiece piece) {
		int id = piece.getID();
		int ref = piece.getRef();
		if (id > MozaicPlayer.ClassicID)
			RefRhombusFactory.create(ref, id);
		else RefTriangleFactory.create(ref, id);
		piece.spawn();
	}
	
	private void replace(ClassicPiece piece) {
		int id = piece.getID();
		count[id]--;
		if (count[id] > 0) {
			if (id > MozaicPlayer.ClassicID) {
				RhombusFactory.create(id);
			}
			else TriangleFactory.create(id);
		}
	}
	
	
	
----- 02.01.14 -----

-------------- ZOOMING --------------			
	
Create zoom for Penrose puzzle, use libgdx camera features?

The basic idea is to manipulate the zoom value of a camera to provide the required effect.

In the InputHandler we have:
	public boolean scrolled(int amount) {
		world.getRenderer().zoom(amount);
		return true;
	}
		
which calls the zoom method from the new class ZoomingWorldRenderer:

	public class ZoomingWorldRenderer extends WorldRenderer {
		
		OrthographicCamera camO;
		Piece clone;
	
		public ZoomingWorldRenderer(World world) {
			super(world);
			camO = new OrthographicCamera();
			camO.setToOrtho(false, width, height);
			camO.update();
		}
		
		@Override
		public void render() {
			Gdx.gl.glClearColor(1, 1, 1, 1);
			Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
			
			batch.setProjectionMatrix(cam.combined);
			batch.begin();
			batch.end();
			
			iter = getIterator();
			
			sr.setProjectionMatrix(cam.combined);
			 Gdx.gl.glEnable(GL10.GL_BLEND);
			    Gdx.gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
			
			sr.begin(ShapeType.FilledTriangle);
			while (iter.hasNext()) {
				Piece next = iter.next();
				if (next == PenrosePiece.clone)
					clone = next;
				else
					next.draw(sr);
			}
			sr.end();
			
			sr.setProjectionMatrix(camO.combined);
			sr.begin(ShapeType.FilledRectangle);
			sr.setColor(Color.BLACK);
			sr.filledRect(0, 0, MozaicPlayer.size, MozaicPlayer.trans);
			sr.end();   
	
			sr.begin(ShapeType.FilledTriangle);
			iter = PenrosePiece.initPieces.iterator();
			while (iter.hasNext()) {
				iter.next().draw(sr);
			}
			sr.end();
			
			if (clone != null) {
				sr.setProjectionMatrix(cam.combined);
				sr.begin(ShapeType.FilledTriangle);
				clone.draw(sr);
				clone = null;
				sr.end();
			}
			
		    Gdx.gl.glDisable(GL10.GL_BLEND);
		}
		
		@Override
		public OrthographicCamera getCameraO() {
			return camO;
		}
		
		@Override
		public void zoom(int amount) {
			cam.zoom += (float) amount/10;
			cam.update();
		}
	}
	
	
As shown by the above code, I have created a second camera, camO, which never has its zoom value changed, this is used
to display the black area at the bottom and the pieces within that area. The current cloned shape is drawn last, so
that it will be visible when on top of the black rectangle.
I have also added a (currently public) static array initPieces to the PenrosePiece class, to contain those pieces to be
drawn on the black area. The relevant code is shown below.
The methods getCameraO() and zoom(int amount) obviously need to exist in the superclass WorldRenderer, I have implemented
them as empty methods containing no code.


From PenrosePiece:
	public static Iterator<Piece> getIterator() {
		Array<Piece> temp = new Array<Piece>(false, MozaicPlayer.PIECES);
		for(Piece p : pieces) {
			temp.add(p);
		}
		temp.removeAll(initPieces, true);
		return temp.iterator();
	}
	
	[For underMouse() calls]
	public static Iterator<Piece> getFullIterator() {
		return pieces.iterator();
	}

	public void delete() {
		pieces.removeValue(this, true);
		initPieces.removeValue(this, true);
	}
	
	
From KiteFactory:	
	public static Kite create(float x, float y, float rot, Color color, int id) {
		Kite kite = new Kite(new float[] {x, y + Y, x + X1, y, x + X2, y + Y, x + X1, y + 2*Y}, rot, color);
		kite.id = id;
		if(PenrosePiece.initPieces.size == 4) {
			PenrosePiece.initPieces.removeIndex(id);
			System.out.println(PenrosePiece.initPieces.size);
		}
		PenrosePiece.initPieces.insert(id, kite);
		return kite;
	}
and similarly for ArrowFactory.	


From PenroseGameScreen:
	public PenroseGameScreen(MozaicPlayer game){	
		super(game);
		render = new ZoomingWorldRenderer(world);
	}
	
	
From InputHandler:
	public boolean touchDown(int screenX, int screenY, int pointer, int button) {
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			// Required for zoom implementations
			world.getRenderer().getCameraO().unproject(touch);
			
			if (touch.y >= MozaicPlayer.trans) {
				touch.set(screenX, screenY, 0);
				world.getRenderer().getCamera().unproject(touch);
			}
			
			touchX = touch.x; touchY = touch.y;
			initX = touchX; initY = touchY;
			dragging = world.underMouse(touchX, touchY);
			if (dragging != null) {
				drag = dragging.clonef();
				if (touchY < MozaicPlayer.trans)
					isNew = true;
			}
		}
		
	public boolean touchUp(int screenX, int screenY, int pointer, int button) {
		...
				// If in the black area, delete the piece
				if (y < MozaicPlayer.trans) {
					// Behaviour required for classic, since it has limited pieces
					if (MozaicPlayer.GAMEMODE == GameMode.Classic && !isNew) {
						int id = dragging.getID();
						if (count[id] == 0) {
							count[id]+=2;
							replace((ClassicPiece) dragging);
						}
						else count[id]++;
					}
					
					// Required for zooming implementation, since collision with black box is not easy to calculate
					if (isNew)
						replace(dragging);
					
					dragging.delete();
					MozaicAudio.delete();
					return true;
				}
				
				

-------------- ORIGINAL PENROSE PIECES --------------
					
So far I have created a new abstract class that the new pieces will extend, a class Pentagon which will be the implementation
for all 3 kinds of Pentagon, and a PentagonFactory class. All are shown here:					

public abstract class PenroseOriPiece implements Piece {
	
	protected Polygon polygon1, polygon2, polygon3;
	protected Color color;
	protected float rot;
	protected int id;
	PenroseOriPiece q;
	private static Array<Piece> pieces = new Array<Piece>(false, MozaicPlayer.PIECES);
	public static Array<Piece> initPieces = new Array<Piece>(false, 6);
	public static PenroseOriPiece clone;
	
	private MinimumTranslationVector mtv1, mtv2, mtv3, mtv4, mtv5, mtv6, mtv7, mtv8, mtv9;

	private float max;

	public PenroseOriPiece(float[] triangle1, float[] triangle2, float[] triangle3, float rot, Color color) {
		polygon1 = new Polygon(new float[] {triangle1[0], triangle1[1], triangle1[2], triangle1[3], triangle1[4], triangle1[5]});
		polygon2 = new Polygon(new float[] {triangle2[0], triangle2[1], triangle2[2], triangle2[3], triangle2[4], triangle2[5]});
		polygon3 = new Polygon(new float[] {triangle3[0], triangle3[1], triangle3[2], triangle3[3], triangle3[4], triangle3[5]});
		this.color = color;
		this.rot = rot;
		id = 0;
		pieces.add(this);
	}
	
	public float getAngle(float x, float y) {
		Vector2 centre = centre(getVerts());
		float rx = x - centre.x;
		float ry = y - centre.y;
		float rot = (float) Math.toDegrees(Math.atan(ry / rx));
		if (rot < 0)
			rot += 180;
		if (ry < 0)
			rot += 180;
		return rot;
	}
	
	private Vector2 centre(float[] transformedVertices) {
		int n = transformedVertices.length;
		float x = 0, y = 0;
		for (int i = 0; i < n; i+=2) {
			x += transformedVertices[i];
			y += transformedVertices[i+1];
		}
		x /= (n/2);
		y /= (n/2);
		return new Vector2(x, y);
	}
	
	public boolean translate(float x, float y) {
		polygon1.translate(x, y);
		polygon2.translate(x, y);
		polygon3.translate(x, y);
		
		Iterator<Piece> iter = pieces.iterator();
		while (iter.hasNext()) {
			q = (PenroseOriPiece) iter.next();
			
			if (this != q)		
				if (overlaps()) {
					polygon1.translate(-x, -y);
					polygon2.translate(-x, -y);
					polygon3.translate(-x, -y);
					return false;
				}	
		}		
		
		return true;
	}
	
	//TODO
	private Vector2 getClosest(Vector2 u) {
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2();
		float[] verts = getVerts();
		v0.x = verts[0]; v0.y = verts[1];
		v1.x = verts[2]; v1.y = verts[3];
		v2.x = verts[4]; v2.y = verts[5];
		v3.x = verts[6]; v3.y = verts[7];
		float v0d = v0.dst(u);
		float v1d = v1.dst(u);
		float v2d = v2.dst(u);
		float v3d = v3.dst(u);

		float dst = Math.min(Math.min(Math.min(v0d, v1d), v2d), v3d);
		
		if (v0d == dst)
			return v0;
		
		if (v1d == dst)
			return v1;
		
		if (v2d == dst)
			return v2;
		
		if (v3d == dst)
			return v3;
				
		return null;
	}
	
	public void fix(Vector2 v0, Vector2 v1, Vector2 u0, Vector2 u1){
		float d0 = v0.dst(u0);
		float d1 = v1.dst(u1);
		
		if (d0 > d1) {
			Vector2 v = v0;
			v0 = v1;
			v1 = v;
			v = u0;
			u0 = u1;
			u1 = v;
		}
				
		if (d0 != d1) {
			
			float a = (float) ( Math.pow((v1.x - v0.x), 2) + Math.pow((v1.y - v0.y), 2) );
			float b = (float) ( Math.pow((u1.x - u0.x), 2) + Math.pow((u1.y - u0.y), 2) );
			float c = (float) ( Math.pow(((u1.x + v0.x - u0.x) - v1.x), 2) + Math.pow(((u1.y + v0.y - u0.y) - v1.y), 2) );
			float rot = (float) Math.toDegrees( Math.acos( (a+b-c) / (2 * Math.sqrt(a) * Math.sqrt(b)) ) );
			if ( rot > 0.5 ) {
			
			
			float dx = u1.x - u0.x;
			float dx2 = dx * dx;
			float dy = u1.y - u0.y;
			float dy2 = dy * dy;
			float ax = v0.x;
			float ay = v0.y;
			float bx = v1.x;
			float by = v1.y;
			float s_ = ( dy2 * dx * (bx - ax) - dx2 * dy * (by - ay) ) / ( dy2 - dx2 );
			float s = ( bx - ax - s_ / dx ) / dx;
			
			Vector2 x_ = new Vector2(s * dx + ax, s * dy + ay);
			
			if (Math.abs(dy) > Math.abs(dx)) {			
				if (dy > 0 && v1.x < x_.x)
					rot = - rot;
				if (dy < 0 && v1.x > x_.x)
					rot = - rot;
			}
			
			else {
				if (dx > 0 && v1.y > x_.y)
					rot = - rot;
				if (dx < 0 && v1.y < x_.y)
					rot = - rot;
			}
			
			rotate(rot);
			}
		}
		
		Vector2 v_ = getClosest(u1);
		translateWOC(u1.x - v_.x, u1.y - v_.y);
	}
	
	public void translateWOC(float x, float y) {
		polygon1.translate(x, y);
		polygon2.translate(x, y);
		polygon3.translate(x, y);
	}
	
	public boolean overlaps() {
		Array<MinimumTranslationVector> mtvs = new Array<MinimumTranslationVector>(false, 9*MozaicPlayer.PIECES);
		Iterator<Piece> iter = pieces.iterator();
		while (iter.hasNext()) {
			q = (PenroseOriPiece) iter.next();
						
			if (this != q) {
				mtv1 = new MinimumTranslationVector();
				mtv2 = new MinimumTranslationVector();
				mtv3 = new MinimumTranslationVector();
				mtv4 = new MinimumTranslationVector();
				mtv5 = new MinimumTranslationVector();
				mtv6 = new MinimumTranslationVector();
				mtv7 = new MinimumTranslationVector();
				mtv8 = new MinimumTranslationVector();
				mtv9 = new MinimumTranslationVector();
				Intersector.overlapConvexPolygons(polygon1, q.get1(), mtv1);
				Intersector.overlapConvexPolygons(polygon1, q.get2(), mtv2);
				Intersector.overlapConvexPolygons(polygon1, q.get3(), mtv3);
				Intersector.overlapConvexPolygons(polygon2, q.get1(), mtv4);
				Intersector.overlapConvexPolygons(polygon2, q.get2(), mtv5);
				Intersector.overlapConvexPolygons(polygon2, q.get3(), mtv6);
				Intersector.overlapConvexPolygons(polygon3, q.get1(), mtv7);
				Intersector.overlapConvexPolygons(polygon3, q.get2(), mtv8);
				Intersector.overlapConvexPolygons(polygon3, q.get3(), mtv9);
				mtvs.add(mtv1);
				mtvs.add(mtv2);
				mtvs.add(mtv3);
				mtvs.add(mtv4);
				mtvs.add(mtv5);
				mtvs.add(mtv6);
				mtvs.add(mtv7);
				mtvs.add(mtv8);
				mtvs.add(mtv9);
			}
		}
		
		max = 0;
		for (int i = 0; i < mtvs.size; i++) {
			mtv1 = mtvs.get(i);
			// If we have already checked all values
			if (mtv1 == null)
				break;
						
			max = Math.max(max, mtv1.depth);
		}
		
		if (max > 1)
			return true;
		else return false;
	}
	
	public void rotate(float degrees) {	
		polygon1.rotate(degrees);
		polygon2.rotate(degrees);
		polygon3.rotate(degrees);
	}
	
	public static Iterator<Piece> getIterator() {
		Array<Piece> temp = new Array<Piece>(false, MozaicPlayer.PIECES);
		for(Piece p : pieces) {
			temp.add(p);
		}
		temp.removeAll(initPieces, true);
		return temp.iterator();
	}
	
	public static Iterator<Piece> getFullIterator() {
		return pieces.iterator();
	}
	
	public abstract float[] getVerts();
	
	public boolean contains(float x, float y) {
		return polygon1.contains(x, y) || polygon2.contains(x, y) || polygon3.contains(x, y); 
	}
	
	public Polygon get1() {
		return polygon1;
	}
	
	public Polygon get2() {
		return polygon2;
	}
	
	public Polygon get3() {
		return polygon3;
	}
	
	public void draw(ShapeRenderer sr) {
		float[] vert1 = polygon1.getTransformedVertices();
		float[] vert2 = polygon2.getTransformedVertices();
		float[] vert3 = polygon3.getTransformedVertices();
		sr.setColor(color);
		sr.filledTriangle(vert1[0], vert1[1], vert1[2], vert1[3], vert1[4], vert1[5]);
		sr.filledTriangle(vert2[0], vert2[1], vert2[2], vert2[3], vert2[4], vert2[5]);
		sr.filledTriangle(vert3[0], vert3[1], vert3[2], vert3[3], vert3[4], vert3[5]);
	}
	
	public abstract PenroseOriPiece clonef();
	
	public void delete() {
		pieces.removeValue(this, true);
		initPieces.removeValue(this, true);
	}

	public int getID() {
		return id;
	}
}



public class Pentagon extends PenroseOriPiece {
	private static float ORIGINOFFSETX = (float) (MozaicPlayer.scale * 50);
	private static float ORIGINOFFSETY = (float) (MozaicPlayer.scale * 50 * (Math.sin(Math.toRadians(36)) + Math.cos(Math.toRadians(18))));
	
	public Pentagon(float[] triangle1, float[] triangle2, float[] triangle3, float rot, Color color) {
		super(triangle1, triangle2, triangle3, rot, color);
		float oX = triangle1[0] + ORIGINOFFSETX;
		float oY = triangle1[1] + ORIGINOFFSETY;
		polygon1.setOrigin(oX, oY);
		polygon2.setOrigin(oX, oY);
		polygon3.setOrigin(oX, oY);
	}
	
	public Pentagon(float[] triangle1, float[] triangle2, float[] triangle3, float rot, Color color, float oX, float oY) {
		super(triangle1, triangle2, triangle3, rot, color);
		polygon1.setOrigin(oX, oY);
		polygon2.setOrigin(oX, oY);
		polygon3.setOrigin(oX, oY);
	}

	@Override
	public float[] getVerts() {
		float[] vert1 = polygon1.getTransformedVertices();
		float[] vert2 = polygon2.getTransformedVertices();
		float[] coords = new float[] {vert1[0], vert1[1], vert1[2], vert1[3], vert1[4], vert1[5], vert2[2], vert2[3], vert2[4], vert2[5]};
		return coords;
	}

	@Override
	public PenroseOriPiece clonef() {
		float[] vert1 = polygon1.getTransformedVertices();
		float[] vert2 = polygon2.getTransformedVertices();
		float[] vert3 = polygon3.getTransformedVertices();
		Color c = color.cpy();
		c.a = 0.5f;
		Pentagon pent = new Pentagon(vert1, vert2, vert3, 0, c, polygon1.getOriginX(), polygon1.getOriginY());
		clone = pent;
		return pent;
	}
	
}



public class PentagonFactory {
	private static final float X1 = (float) (MozaicPlayer.scale * 100);
	private static final float X2 = (float) (MozaicPlayer.scale * 100 * Math.sin(Math.toRadians(18)));
	private static final float X3 = X1/2;

	private static final float Y1 = (float) (MozaicPlayer.scale * 100 * Math.cos(Math.toRadians(18)));
	private static final float Y2 = (float) (MozaicPlayer.scale * 100 * Math.sin(Math.toRadians(36)));
	
	private PentagonFactory() {}
	
	public static Pentagon create(float x, float y, float rot, Color color) {
		float[] triangle1 = {x, y, x + X1, y, x + X1 + X2, y + Y1};
		float[] triangle2 = {x + X1 + X2, y + Y1, x + X3, y + Y1 + Y2, x - X2, y + Y1};
		float[] triangle3 = {x, y, x - X2, y + Y1, x + X1 + X2, y + Y1};
		Pentagon pent = new Pentagon(triangle1, triangle2, triangle3, rot, color);
		return pent;
	}

	public static Pentagon create(float x, float y, float rot, Color color, int id) {
		float[] triangle1 = {x, y, x + X1, y, x + X1 + X2, y + Y1};
		float[] triangle2 = {x + X1 + X2, y + Y1, x + X3, y + Y1 + Y2, x - X2, y + Y1};
		float[] triangle3 = {x, y, x - X2, y + Y1, x + X1 + X2, y + Y1};
		Pentagon pent = new Pentagon(triangle1, triangle2, triangle3, rot, color);
		
		pent.id = id;
		if(PenrosePiece.initPieces.size == 6) {
			PenrosePiece.initPieces.removeIndex(id);
		}
		PenrosePiece.initPieces.insert(id, pent);
		return pent;
	}
	
	public static Pentagon create(int id) {
		if (id == 0)
			return PentagonFactory.create(MozaicPlayer.width*10/32, MozaicPlayer.trans/2 - Y1, 0, Color.BLUE, id);

		else if (id == 1)
			return PentagonFactory.create(MozaicPlayer.width*10/32, MozaicPlayer.trans/2 - Y1 + 2*(MozaicPlayer.trans/2 - Y1/3)/3, 0, Color.RED, id);
		
		else
			return PentagonFactory.create(MozaicPlayer.width*10/32, MozaicPlayer.trans/2 - Y1 - 2*(MozaicPlayer.trans/2 - Y1/3)/3, 0, Color.GREEN, id);
	}
}



----- 03.01.14 -----

I created the rest of the pieces (Star, Boat and Diamond) and their respective Factory classes. The way I chose to create these shapes
is documented in my diary notepad for future referencing. I also made minor changes to a couple of classes, where PenrosePiece had been
directly referenced, e.g. when ZoomingWorldRenderer retrieves the initPieces, and replaced them with getters.
All that remains to be done is the implementation of the snapping and a minor update to the InputHandler.
		


----- 04.01.14 -----

I updated SnapTo in order to deal with the new kinds of pieces. I also had to update getClosest() in PenroseOriPiece in order for it to
work on pieces with any number of vertices. Finally, star needed additional changes to deal with representing all 10 vertices, for snapping.
See Project Backup V.0.1.2 for the rest of the implementation.


	private Vector2 getClosest(Vector2 u) {
		
		Array<Vector2> vecs = new Array<Vector2>(false, 10);
		Vector2 current;
		Vector2 currentMin = null;
		float dst;
		float minDst = MozaicPlayer.width; // large number
		float[] verts = getVerts();

		for (int i = 0; i < verts.length; i++) {
			vecs.add(new Vector2(verts[i++], verts[i]));
		}
		
		for (int i = 0; i < vecs.size; i++) {
			current = vecs.get(i);
			dst = current.dst(u);
			minDst = Math.min(dst, minDst);
			if (dst == minDst)
				currentMin = current;
		}
		
		return currentMin;
	}
	
	
	
	public class Star extends PenroseOriPiece {
		private static float ORIGINOFFSETX = (float) (MozaicPlayer.scale * 100 * Math.sin(Math.toRadians(54)));
		private static float ORIGINOFFSETY = (float) (MozaicPlayer.scale * 100 * (Math.cos(Math.toRadians(54)) + (Math.cos(Math.toRadians(72))/Math.sin(Math.toRadians(36)))));
		private Polygon polygon4;
		
		public Star(float[] triangle1, float[] triangle2, float[] triangle3, float[] triangle4, float rot, Color color) {
			super(triangle1, triangle2, triangle3, rot, color);
			float oX = triangle1[0] + ORIGINOFFSETX;
			float oY = triangle1[1] + ORIGINOFFSETY;
			polygon1.setOrigin(oX, oY);
			polygon2.setOrigin(oX, oY);
			polygon3.setOrigin(oX, oY);
			
			polygon4 = new Polygon(triangle4);
			polygon4.setOrigin(oX, oY);
		}
		
		// Doesn't need to change vert4, since only used for creating the clones
		public Star(float[] triangle1, float[] triangle2, float[] triangle3, float rot, Color color, float oX, float oY) {
			super(triangle1, triangle2, triangle3, rot, color);
			polygon1.setOrigin(oX, oY);
			polygon2.setOrigin(oX, oY);
			polygon3.setOrigin(oX, oY);
		}
	
		@Override
		public float[] getVerts() {
			float[] vert1 = polygon1.getTransformedVertices();
			float[] vert2 = polygon2.getTransformedVertices();
			float[] vert3 = polygon3.getTransformedVertices();
			float[] vert4 = polygon4.getTransformedVertices();
			float[] coords = new float[] {vert1[0], vert1[1], vert2[4], vert2[5], vert3[0], vert3[1], vert1[4], vert1[5], vert2[2], vert2[3],
												vert4[0], vert4[1], vert1[2], vert1[3], vert4[2], vert4[3], vert2[0], vert2[1], vert4[4], vert4[5]};
			return coords;
		}
	
		@Override
		public PenroseOriPiece clonef() {
			float[] vert1 = polygon1.getTransformedVertices();
			float[] vert2 = polygon2.getTransformedVertices();
			float[] vert3 = polygon3.getTransformedVertices();
			Color c = color.cpy();
			c.a = 0.5f;
			Star star = new Star(vert1, vert2, vert3, 0, c, polygon1.getOriginX(), polygon1.getOriginY());
			clone = star;
			return star;
		}
		
		@Override
		public boolean translate(float x, float y) {
			if (super.translate(x, y)) {
				polygon4.translate(x, y);
				return true;
			}
			else return false;
		}
		
		@Override
		public void translateWOC(float x, float y) {
			super.translateWOC(x, y);
			if (polygon4 != null)				// for translating the clones
				polygon4.translate(x, y);
		}
		
		@Override
		public void rotate(float degrees) {	
			super.rotate(degrees);
			polygon4.rotate(degrees);
		}
	}
	
	

Below is shown the main sections of code used in snapping original Penrose pieces	
	
	public static Tuple<Boolean, Vector2> snap(Piece dragging, Iterator<Piece> pieces) {
	
		Tuple<Boolean, Vector2> snapped = new Tuple<Boolean, Vector2>(false, new Vector2(0, 0));
		
		if(GAMEMODE == GameMode.PenroseOri) {
			d = MozaicPlayer.size/20;
			int id = dragging.getID();
			
			if (id < 3)
				snapPent(dragging, pieces, id, snapped);
			else if (id == 3)
				snapStar(dragging, pieces, snapped);
			else if (id == 4)
				snapBoat(dragging, pieces, snapped);
			else snapDiamond(dragging, pieces, snapped);
		}
		
		
	private static void snapDiamond(Piece dragging, Iterator<Piece> pieces, Tuple<Boolean, Vector2> snapped) {
		PenroseOriPiece u;
		float[] us, vs = dragging.getVerts();
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), 
				u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2(),	u4 = new Vector2();
		v0.x = vs[0]; v0.y = vs[1];
		v1.x = vs[2]; v1.y = vs[3];
		v2.x = vs[4]; v2.y = vs[5];
		v3.x = vs[6]; v3.y = vs[7];
		
		while (!snapped.l && pieces.hasNext()) {

			u = (PenroseOriPiece) pieces.next();
			if (u != dragging && u.getID() < 2) { // u != dragging is not actually required here, but is left in for clarity
				us = u.getVerts();					// can only snap to 2 kinds of pentagon, and no other shapes
				u0.x = us[0]; u0.y = us[1];
				u1.x = us[2]; u1.y = us[3];
				u2.x = us[4]; u2.y = us[5];
				u3.x = us[6]; u3.y = us[7];
				u4.x = us[8]; u4.y = us[9];
				
				snapped.l = snapDP(v0, v1, v2, v3, u0, u1, u2, u3, u4, dragging);
			}
		}
	}	
		
		
	private static void snapBoat(Piece dragging, Iterator<Piece> pieces, Tuple<Boolean, Vector2> snapped) {
		
		PenroseOriPiece u;
		float[] us, vs = dragging.getVerts();
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), v4 = new Vector2(), v5 = new Vector2(), v6 = new Vector2(), 
				u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2(),	u4 = new Vector2();
		v0.x = vs[0]; v0.y = vs[1];
		v1.x = vs[2]; v1.y = vs[3];
		v2.x = vs[4]; v2.y = vs[5];
		v3.x = vs[6]; v3.y = vs[7];
		v4.x = vs[8]; v4.y = vs[9];
		v5.x = vs[10]; v5.y = vs[11];
		v6.x = vs[12]; v6.y = vs[13];
		
		while (!snapped.l && pieces.hasNext()) {

			u = (PenroseOriPiece) pieces.next();
			if (u != dragging && u.getID() < 2) { // first condition not required, left in for clarity
				us = u.getVerts();					// snapping to two kinds of pentagon
				u0.x = us[0]; u0.y = us[1];
				u1.x = us[2]; u1.y = us[3];
				u2.x = us[4]; u2.y = us[5];
				u3.x = us[6]; u3.y = us[7];
				u4.x = us[8]; u4.y = us[9];
				
				if (u.getID() == 0) 	// snapping 'star edges' to only one kind of pentagon
					snapped.l = snapB1(v0, v1, v2, v3, v4, v5, v6, u0, u1, u2, u3, u4, dragging);
				
				if (!snapped.l)
					snapped.l = snapBP(v0, v1, v2, v3, v4, v5, v6, u0, u1, u2, u3, u4, dragging);
			}	
		}
	}
	
	
	private static void snapStar(Piece dragging, Iterator<Piece> pieces, Tuple<Boolean, Vector2> snapped) {
	
		PenroseOriPiece u;
		float[] us, vs = dragging.getVerts();
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), v4 = new Vector2(), 
				v5 = new Vector2(), v6 = new Vector2(), v7 = new Vector2(), v8 = new Vector2(),	v9 = new Vector2(),
				u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2(),	u4 = new Vector2();
		v0.x = vs[0]; v0.y = vs[1];
		v1.x = vs[2]; v1.y = vs[3];
		v2.x = vs[4]; v2.y = vs[5];
		v3.x = vs[6]; v3.y = vs[7];
		v4.x = vs[8]; v4.y = vs[9];
		v5.x = vs[10]; v5.y = vs[11];
		v6.x = vs[12]; v6.y = vs[13];
		v7.x = vs[14]; v7.y = vs[15];
		v8.x = vs[16]; v8.y = vs[17];
		v9.x = vs[18]; v9.y = vs[19];
		
		while (!snapped.l && pieces.hasNext()) {

			u = (PenroseOriPiece) pieces.next();
			if (u != dragging && u.getID() == 0) { // first condition not required, left in for clarity
				us = u.getVerts();					// snapping only to one kind of pentagon
				u0.x = us[0]; u0.y = us[1];
				u1.x = us[2]; u1.y = us[3];
				u2.x = us[4]; u2.y = us[5];
				u3.x = us[6]; u3.y = us[7];
				u4.x = us[8]; u4.y = us[9];
				
				snapped.l = snapS1(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, u0, u1, u2, u3, u4, dragging);
			}	
		}
	}	
		
		
	private static void snapPent(Piece dragging, Iterator<Piece> pieces, int id, Tuple<Boolean, Vector2> snapped) {
		
		PenroseOriPiece u;
		float[] us, vs = dragging.getVerts();
		Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), v4 = new Vector2(), 
				u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2(),	u4 = new Vector2(), 
				u5 = new Vector2(), u6 = new Vector2(), u7 = new Vector2(), u8 = new Vector2(),	u9 = new Vector2();
		
		v0.x = vs[0]; v0.y = vs[1];
		v1.x = vs[2]; v1.y = vs[3];
		v2.x = vs[4]; v2.y = vs[5];
		v3.x = vs[6]; v3.y = vs[7];
		v4.x = vs[8]; v4.y = vs[9];
		
		if (id < 2) {
			while (!snapped.l && pieces.hasNext()) {
	
				u = (PenroseOriPiece) pieces.next();
				if (u != dragging && u.getID() != id) {			// can only snap to other pieces
					us = u.getVerts();
					u0.x = us[0]; u0.y = us[1];
					u1.x = us[2]; u1.y = us[3];
					u2.x = us[4]; u2.y = us[5];
					u3.x = us[6]; u3.y = us[7];
					if (u.getID() != 5)	{						// unless diamond
						u4.x = us[8]; u4.y = us[9];
						if (u.getID() > 2) {					// boat or star
							u5.x = us[10]; u5.y = us[11];
							u6.x = us[12]; u6.y = us[13];
							if (u.getID() == 3) {				// star
								u7.x = us[14]; u7.y = us[15];
								u8.x = us[16]; u8.y = us[17];	
								u9.x = us[18]; u9.y = us[19];
								if (id == 0)
									snapped.l = snapPS(v0, v1, v2, v3, v4, u0, u1, u2, u3, u4, u5, u6, u7, u8, u9, dragging);
							}
							else {								// boat
								if (id == 0)
									snapped.l = snap1B(v0, v1, v2, v3, v4, u0, u1, u2, u3, u4, u5, u6, dragging);
								if (!snapped.l)
									snapped.l = snapPB(v0, v1, v2, v3, v4, u0, u1, u2, u3, u4, u5, u6, dragging);
							}							
						}
						else {									// pentagon
							snapped.l = snapPP(v0, v1, v2, v3, v4, u0, u1, u2, u3, u4, dragging);
						}
					}
					else {										// diamond
						snapped.l = snapPD(v0, v1, v2, v3, v4, u0, u1, u2, u3, dragging);
					}
				}	
			}
		}
		
		else {							// Can only snap to pentagons
			while (!snapped.l && pieces.hasNext()) {
				
				u = (PenroseOriPiece) pieces.next();
				if (u != dragging && u.getID() < 2) {			// only pentagons of different colours
					us = u.getVerts();
					u0.x = us[0]; u0.y = us[1];
					u1.x = us[2]; u1.y = us[3];
					u2.x = us[4]; u2.y = us[5];
					u3.x = us[6]; u3.y = us[7];
					u4.x = us[8]; u4.y = us[9];
					
					snapped.l = snapPP(v0, v1, v2, v3, v4, u0, u1, u2, u3, u4, dragging);
				}
			}
		}
	}



----- 05.01.14 -----

-------------- PENROSE RHOMBS (P3) --------------
					
The final, and simplest, penrose pieces. The pieces are (as with the classic pieces) convex, so the 'Piece' code is simpler, since we require
only one polygon. Also, there are only two kinds of piece, and they are very similar, so there is only one Factory.
Apart from the code snippets shown below, I also created a new GameScreen, a new World, and made minor changes to both WorldRenderer classes,
and also the InputHandler class.

Here is the code for the Piece implementation, I have only included code that is different from other Penrose Pieces, for brevity:

	public abstract class PenroseRhomb implements Piece {
		
		protected Polygon polygon;
		protected static Array<Piece> initPieces = new Array<Piece>(false, 2);
		
		private MinimumTranslationVector mtv;
	
		public PenroseRhomb(float[] coords, float rot, Color color) {
			polygon = new Polygon(new float[] {coords[0], coords[1], coords[2], coords[3], coords[4], coords[5], coords[6], coords[7]});
			this.color = color;
			this.rot = rot;
			id = 0;
			pieces.add(this);
		}
		
		public boolean translate(float x, float y) {
			polygon.translate(x, y);
			
			Iterator<Piece> iter = pieces.iterator();
			while (iter.hasNext()) {
				q = (PenroseRhomb) iter.next();
				
				if (this != q)		
					if (overlaps()) {
						polygon.translate(-x, -y);
						return false;
					}	
			}		
			
			return true;
		}
		
		public void translateWOC(float x, float y) {
			polygon.translate(x, y);
		}
		
		public boolean overlaps() {
			
			Array<MinimumTranslationVector> mtvs = new Array<MinimumTranslationVector>(false, MozaicPlayer.PIECES);
			
			Iterator<Piece> iter = pieces.iterator();
			while (iter.hasNext()) {
				q = (PenroseRhomb) iter.next();
							
				if (this != q) {
					mtv = new MinimumTranslationVector();
					Intersector.overlapConvexPolygons(polygon, q.get(), mtv);
					mtvs.add(mtv);
				}
			}
			
			max = 0;
			for (int i = 0; i < mtvs.size; i++) {
				mtv = mtvs.get(i);
				if (mtv == null)
					break;
							
				max = Math.max(max, mtv.depth);
			}
			
			if (max > 1)
				return true;
			else return false;
		}
		
		public void rotate(float degrees) {	
			polygon.rotate(degrees);
		}
		
		public float[] getVerts() {
			return polygon.getTransformedVertices();
		}
		
		public boolean contains(float x, float y) {
			return polygon.contains(x, y);
		}
		
		public Polygon get() {
			return polygon;
		}
		
		public void draw(ShapeRenderer sr) {
			float[] coords = getVerts();
			sr.setColor(color);
			sr.filledTriangle(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
			sr.filledTriangle(coords[0], coords[1], coords[6], coords[7], coords[4], coords[5]);
		}	
	}
	
	

Here is the code for the Rhombs themselves (he two classes are almost identical, it is worth considering only using a single class):

	public class RhombLarge extends PenroseRhomb {
	
		public RhombLarge(float[] coords, float rot, Color color) {
			super(coords, rot, color);
			polygon.setOrigin((coords[0] + coords[4])/2, (coords[1] + coords[5])/2);
		}
		
		public RhombLarge(float[] coords, float rot, Color color, float oX, float oY) {
			super(coords, rot, color);
			polygon.setOrigin(oX, oY);
		}
		
		@Override
		public PenroseRhomb clonef() {
			Color c = color.cpy();
			c.a = 0.5f;
			float[] coords = getVerts();
			RhombLarge rhomb = new RhombLarge(coords, 0, c, polygon.getOriginX(), polygon.getOriginY());
			clone = rhomb;
			return rhomb;
		}
	}
	

	public class RhombSmall extends PenroseRhomb {
		
		public RhombSmall(float[] coords, float rot, Color color) {
			super(coords, rot, color);
			polygon.setOrigin((coords[0] + coords[4])/2, (coords[1] + coords[5])/2);
		}
		
		public RhombSmall(float[] coords, float rot, Color color, float oX, float oY) {
			super(coords, rot, color);
			polygon.setOrigin(oX, oY);
		}
		
		@Override
		public PenroseRhomb clonef() {
			Color c = color.cpy();
			c.a = 0.5f;
			float[] coords = getVerts();
			RhombSmall rhomb = new RhombSmall(coords, 0, c, polygon.getOriginX(), polygon.getOriginY());
			clone = rhomb;
			return rhomb;
		}
	}	
	
	
	
And finally, we have the Factory class used to create the Rhombs:

	public class RhombFactory {
		private static final float WIDTH = (float) (MozaicPlayer.scale * 150);
		private static final float LHEIGHT = (float) (WIDTH * Math.sin(Math.toRadians(72)));
		private static final float LSLIDE = (float) (WIDTH * Math.cos(Math.toRadians(72)));
		private static final float SHEIGHT = (float) (WIDTH * Math.sin(Math.toRadians(36)));
		private static final float SSLIDE = (float) (WIDTH * Math.cos(Math.toRadians(36)));
		
		private RhombFactory() {}
	
		public static RhombLarge createLarge(float x, float y, float rot, Color color, int id) {
			RhombLarge rhomb = new RhombLarge(new float[] {x, y, x + WIDTH, y, x + WIDTH + LSLIDE, y + LHEIGHT, x + LSLIDE, y + LHEIGHT}, rot, color);
			rhomb.id = id;
			if(PenroseRhomb.initPieces.size == 2)
				PenroseRhomb.initPieces.removeIndex(id);
			PenroseRhomb.initPieces.insert(id, rhomb);
			return rhomb;
		}
		
		public static RhombSmall createSmall(float x, float y, float rot, Color color, int id) {
			RhombSmall rhomb = new RhombSmall(new float[] {x, y, x + WIDTH, y, x + WIDTH + SSLIDE, y + SHEIGHT, x + SSLIDE, y + SHEIGHT}, rot, color);
			rhomb.id = id;
			if(PenroseRhomb.initPieces.size == 2)
				PenroseRhomb.initPieces.removeIndex(id);
			PenroseRhomb.initPieces.insert(id, rhomb);
			return rhomb;
		}
		
		public static PenroseRhomb create(int id) {
			if (id == 0)
				return RhombFactory.createLarge(MozaicPlayer.width*0.15f, (MozaicPlayer.trans-LHEIGHT)/2, 0, Color.BLUE, id);
	
			else
				return RhombFactory.createSmall(MozaicPlayer.width*0.5f, (MozaicPlayer.trans-SHEIGHT)/2, 0, Color.CYAN, id);
		}
	}
	
	
	

The updates to the SnapTo class:	

	if (GAMEMODE == GameMode.PenroseRhomb) {
			d = MozaicPlayer.size/20;
			
			PenroseRhomb u;
			boolean id0 = (dragging.getID() == 0);
			float[] us, vs = dragging.getVerts();
			Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2();
			v0.x = vs[0]; v0.y = vs[1];
			v1.x = vs[2]; v1.y = vs[3];
			v2.x = vs[4]; v2.y = vs[5];
			v3.x = vs[6]; v3.y = vs[7];
					
			while (!snapped.l && pieces.hasNext()) {
				u = (PenroseRhomb) pieces.next();
				if (u != dragging) {
					us = u.getVerts();
					u0.x = us[0]; u0.y = us[1];
					u1.x = us[2]; u1.y = us[3];
					u2.x = us[4]; u2.y = us[5];
					u3.x = us[6]; u3.y = us[7];
					
					if (id0) {
						if (u.getID() == 0)
							snapped.l = snapR11(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
						else
							snapped.l = snapR12(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
					}
					else {
						if (u.getID() == 0)
							snapped.l = snapR21(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
						else
							snapped.l = snapR22(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
					}
				}
			}
			return snapped;
		}
		
		
	private static Boolean snapR22(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0, Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging) {
		
		if (v0.dst(u2) < d && v1.dst(u1) < d)
			dragging.fix(v0, v1, u2, u1);
		
		else if (v2.dst(u0) < d && v1.dst(u1) < d)
			dragging.fix(v2, v1, u0, u1);
		
		else if (v0.dst(u2) < d && v3.dst(u3) < d)
			dragging.fix(v0, v3, u2, u3);
		
		else if (v2.dst(u0) < d && v3.dst(u3) < d)
			dragging.fix(v2, v3, u0, u3);

		else return false;
		
		return true;
	}


	private static Boolean snapR21(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0, Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging) {
		
		if (v3.dst(u0) < d && v2.dst(u1) < d)
			dragging.fix(v3, v2, u0, u1);
		
		else if (v3.dst(u0) < d && v0.dst(u3) < d)
			dragging.fix(v2, v0, u0, u3);
		
		else if (v1.dst(u1) < d && v0.dst(u2) < d)
			dragging.fix(v1, v0, u1, u2);
		
		else if (v1.dst(u3) < d && v2.dst(u2) < d)
			dragging.fix(v1, v2, u3, u2);
		
		else return false;
		
		return true;
	}


	private static Boolean snapR12(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0, Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging) {
		
		if (v0.dst(u3) < d && v1.dst(u2) < d)
			dragging.fix(v0, v1, u3, u2);
		
		else if (v0.dst(u3) < d && v3.dst(u0) < d)
			dragging.fix(v0, v3, u3, u0);
		
		else if (v1.dst(u1) < d && v2.dst(u0) < d)
			dragging.fix(v1, v2, u1, u0);
		
		else if (v3.dst(u1) < d && v2.dst(u2) < d)
			dragging.fix(v3, v2, u1, u2);
		
		else return false;
		
		return true;
	}


	private static Boolean snapR11(Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 u0, Vector2 u1, Vector2 u2, Vector2 u3, Piece dragging) {

		if (v0.dst(u0) < d && v1.dst(u3) < d)
			dragging.fix(v0, v1, u0, u3);
		
		else if (v0.dst(u0) < d && v3.dst(u1) < d)
			dragging.fix(v0, v3, u0, u1);
		
		else if (v1.dst(u3) < d && v2.dst(u2) < d)
			dragging.fix(v1, v2, u3, u2);
		
		else if (v3.dst(u1) < d && v2.dst(u2) < d)
			dragging.fix(v3, v2, u1, u2);
		
		else return false;
		
		return true;
	}

		
----- 06.01.14 -----

-------------- SPRITES --------------
		
Make sprites with lines representing possible penrose matches instead of drawing triangles.

See screenshot of 07.01.14 / Project Backup V.0.1.3

Did in about 3 hours using photoshop. Previously tried to do it using paint for several hours, but results were poor.
Only small changes to the code were needed, and these are detailed below.

	public PenroseRhomb(float[] coords, float rot, Color color, Texture text) {
		polygon = new Polygon(new float[] {coords[0], coords[1], coords[2], coords[3], coords[4], coords[5], coords[6], coords[7]});
		this.color = color;
		this.rot = rot;
		id = 0;
		pieces.add(this);
		texture = text;
		//texture = new Texture("data/large_rhomb.png");
		texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);
		
		sprite = new Sprite(texture);
		sprite.setOrigin((coords[0] + coords[4])/2 - coords[0], (coords[1] + coords[5])/2 - coords[1]);
		sprite.setColor(1, 1, 1, color.a);
		sprite.setX(coords[0]);
		sprite.setY(coords[1]);
	}
	
	
	public class RhombSmall extends PenroseRhomb {
		
		private static final Texture texture = new Texture("data/small_rhomb.png");
		
		public RhombSmall(float[] coords, float rot, Color color) {
			super(coords, rot, color, texture);
			polygon.setOrigin((coords[0] + coords[4])/2, (coords[1] + coords[5])/2);
		}
		
		public RhombSmall(float[] coords, float rot, Color color, float oX, float oY, Sprite sprite_) {
			super(coords, rot, color, texture);
			polygon.setOrigin(oX, oY);
			
			sprite.setOrigin(sprite_.getOriginX(), sprite_.getOriginY());
			sprite.setX(sprite_.getX());
			sprite.setY(sprite_.getY());
			sprite.setRotation(sprite_.getRotation());
			sprite.setColor(1, 1, 1, color.a);
		}
		
		@Override
		public PenroseRhomb clonef() {
			Color c = color.cpy();
			c.a = 0.5f;
			float[] coords = getVerts();
			RhombSmall rhomb = new RhombSmall(coords, 0, c, polygon.getOriginX(), polygon.getOriginY(), sprite);
			clone = rhomb;
			return rhomb;
		}
	}
	
	
	public class RhombLarge extends PenroseRhomb {
		
		private static final Texture texture = new Texture("data/large_rhomb.png");
		
		public RhombLarge(float[] coords, float rot, Color color) {
			super(coords, rot, color, texture);
			polygon.setOrigin((coords[0] + coords[4])/2, (coords[1] + coords[5])/2);
		}
		
		public RhombLarge(float[] coords, float rot, Color color, float oX, float oY, Sprite sprite_) {
			super(coords, rot, color, texture);
			polygon.setOrigin(oX, oY);
			
			sprite.setOrigin(sprite_.getOriginX(), sprite_.getOriginY());
			sprite.setX(sprite_.getX());
			sprite.setY(sprite_.getY());
			sprite.setRotation(sprite_.getRotation());
			sprite.setColor(1, 1, 1, color.a);
		}
		
		@Override
		public PenroseRhomb clonef() {
			Color c = color.cpy();
			c.a = 0.5f;
			float[] coords = getVerts();
			RhombLarge rhomb = new RhombLarge(coords, 0, c, polygon.getOriginX(), polygon.getOriginY(), sprite);
			clone = rhomb;
			return rhomb;
		}
	}
	
	
	
----- 07.01.14 -----

-------------- BUG FIX --------------

Pieces are being deleted when below MozaicPlayer.trans on the zooming camera.

A very simple change was required to InputHandler, the addition of a Vector3 touchO:

	@Override
	public boolean touchUp(int screenX, int screenY, int pointer, int button) {
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCamera().unproject(touch);
			float x = touch.x; float y = touch.y;
			touchO.set(0, screenY, 0);
			world.getRenderer().getCameraO().unproject(touchO);
						
			if (dragging != null) {
				
				drag.delete();
				
				// If in the black area, delete the piece
				if (touchO.y < MozaicPlayer.trans) {

				
-------------- BUG FIX --------------
				
When pieces near their original positions, the new piece in that location shows up
and can be interacted with.

This required the creation of a new method underMouseInit, and an update of underMouse, so that it used getIterator()
instead of getFullIterator(). Whilst fixing this I decided to abstract these methods into World:

	public abstract class World {
		protected MozaicPlayer game;
		protected WorldRenderer wr;
		
		public World(MozaicPlayer game) {
			this.game = game;
			Gdx.input.setInputProcessor(new InputHandler(this));
		}
		
		public void update(){
		}
		
		public void setRenderer(WorldRenderer wr) {
			this.wr = wr;
		}
		
		public WorldRenderer getRenderer() {
			return wr;
		}
		
		public void dispose(){
			
		}
		
		public Piece underMouseInit(float x, float y) {
			Iterator<Piece> iter = getInitIterator();
			Piece p;
			
			while (iter.hasNext()) {
				p = (Piece) iter.next();
				if (p.contains(x, y)) {
					return p;
				}
			}
			return null;
		}
		
		public Piece underMouse(float x, float y) {
			Iterator<Piece> iter = getIterator();
			Piece p;
			
			while (iter.hasNext()) {
				p = (Piece) iter.next();
				if (p.contains(x, y)) {
					return p;
				}
			}
			return null;
		}
	
		protected abstract Iterator<Piece> getIterator();
		
		protected Iterator<Piece> getInitIterator() {
			return getIterator();
		}
	}	
		
		
	public class PenroseRhombWorld extends World {
		
		public PenroseRhombWorld(MozaicPlayer game) {
			super(game);
	
			RhombFactory.create(0);
			RhombFactory.create(1);
		}
		
		protected Iterator<Piece> getIterator() {
			return PenroseRhomb.getIterator();
		}
	 	
		protected Iterator<Piece> getInitIterator() {
			return PenroseRhomb.getInitIterator();
		}
	}
	
(The other World classes are similarly changed)	


(InputHandler)	
		public boolean touchDown(int screenX, int screenY, int pointer, int button) {
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCameraO().unproject(touch);
			
			if (touch.y >= MozaicPlayer.trans) {
				touch.set(screenX, screenY, 0);
				world.getRenderer().getCamera().unproject(touch);
				touchX = touch.x; touchY = touch.y;
				initX = touchX; initY = touchY;
				dragging = world.underMouse(touchX, touchY);
				if (dragging != null)
					drag = dragging.clonef();
			}
			
			else {
				touchX = touch.x; touchY = touch.y;
				initX = touchX; initY = touchY;
				dragging = world.underMouseInit(touchX, touchY);
				if (dragging != null) {
					drag = dragging.clonef();
					isNew = true;
				}
			}
		}
		...
	}


Whilst making these changes, I realised that the translate methods were iterating through all pieces and calling overlaps() on each,
or manually checking for each overlap instead of just calling overlaps() once. I changed all of the Piece abstract classes
apart from ReflectPiece which works differently.

(PenroseRhomb)
	public boolean translate(float x, float y) {
		polygon.translate(x, y);
		
		if (overlaps()) {
			polygon.translate(-x, -y);
			return false;
		}		
		sprite.translate(x, y);
		return true;
	}
	


----- 09.01.14 -----

-------------- ROTATION UPDATE --------------

All Penrose games (those with free rotation) currently allow rotation to create overlapping shapes, I would
prefer different behaviour.

In the process of fixing this, I decided to implement rotation by the same method for the Classic pieces, they now
have free rotation and snap to the nearest 45 degree angle when released.

In InputHandler, I added a new float originalRotation, used to reset the rotation if required.

(TouchDown)
		if (button == 1) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCamera().unproject(touch);
			touchX = touch.x; touchY = touch.y;
			rotating = world.underMouse(touchX, touchY);
			if (rotating != null) {
				rotation = rotating.getAngle(touchX, touchY);
				originalRotation = rotating.getRotation();
			}
		}
		
(TouchUp)		
		if (button == 1) {
			if (rotating != null)
				if (rotating.fixRotation(originalRotation))
					MozaicAudio.dragFail();
			rotating = null;
		}



This obviously required new methods in the Piece interface, to be added to each Piece class.
Here are the implementations in PenroseRhomb, the other Penrose classes have very similar implementations:

(PenroseRhomb)
	public void rotate(float degrees) {	
		polygon.rotate(degrees);
		sprite.rotate(degrees);
	}
	
	public float getRotation() {
		return polygon.getRotation();
	}
	
	public boolean fixRotation(float originalRot) {
		if (overlaps()) {
			polygon.setRotation(originalRot);
			sprite.setRotation(originalRot);
			return true;
		}
		return false;
	}
	

And here are the implementations in ClassicPiece and ReflectPiece (which extends ClassicPiece).

(ClassicPiece)
	public void rotate(float degrees) {	
		polygon.rotate(degrees);
	}
	
	public float getRotation() {
		return polygon.getRotation();
	}
	
	// never required, in theory
	protected void setRotation(float degrees) {
		polygon.setRotation(degrees);
	}
	
	public boolean fixRotation(float originalRot) {
		// set rotation to the nearest multiple of 45 that doesn't overlap
		boolean pos = false;
		int mul = 1;
		float rot = polygon.getRotation();
		float diff = rot % 45;
		if (diff < 22.5)
			rotate(-diff);
		else {
			rotate(45 - diff);
			pos = true;
		}
		while (overlaps()) {
			if (pos)
				rotate(-45 * mul);
			else 
				rotate(45 * mul);
			mul += 1;
			//TODO
			// safety net, shouldn't be required
			if (mul == 8) {
				setRotation(originalRot);
				break;
			}
			pos = !pos;
		}
		return false;
	}
	
	
(ReflectPiece)	
	protected void srotate(float degrees) {
		super.rotate(degrees);
	}
	
	protected void rotate_(float degrees) {
		//TODO safety net
		assert (refPieces.get(0) == this);
		srotate(degrees);
		if (ref == 1 || ref == 2 || ref == 3 || ref == 4 || ref == 5 || ref == 6)
			refPieces.get(1).srotate(-degrees);
		
		if (ref == 5 || ref == 6) {
			refPieces.get(2).srotate(-degrees);
			refPieces.get(3).srotate(degrees);
		}
	}
	
	@Override
	public void rotate(float degrees) {	
		if (refPieces.get(0) == this) 
			rotate_(degrees);
		if (refPieces.get(1) == this) 
			refPieces.get(0).rotate_(-degrees);
		if (refPieces.get(2) == this) {
			if (ref == 5 || ref == 6)
				refPieces.get(0).rotate_(-degrees);
		}
		if (refPieces.get(3) == this) {
			if (ref == 5 || ref == 6)
				refPieces.get(0).rotate_(degrees);
		}
	}
	
	
	// never required, in theory
	@Override
	protected void setRotation(float degrees) {
		float rot = (degrees - getRotation()) % 180;
		rotate(rot);
	}
	
	@Override
	public float getRotation() {
		return refPieces.get(0).get().getRotation();
	}


-------------- BUG FIX --------------
	
Modes other than PenroseRhomb do not allow pieces to be moved.

This was obviously an error in the underMouse(x, y) method in the World classes.
It turned out to be a copy/paste error, all the World classes had:

	protected Iterator<Piece> getIterator() {
		return PenroseRhomb.getIterator();
	}
 	
 	@Override
	protected Iterator<Piece> getInitIterator() {
		return PenroseRhomb.getInitIterator();
	}
	
	
whereas, for example, ClassicWorld should have:		
	
	protected Iterator<Piece> getIterator() {
		return ClassicPiece.getIterator();
	}


Also, ReflectWorld needed to override the underMouse methods (to check for isSpawned, to avoid picking up reflected pieces):

	@Override
	public Piece underMouse(float x, float y) {
		Iterator<Piece> iter = ReflectPiece.getIterator();
		ReflectPiece p;
		while (iter.hasNext()) {
		p = (ReflectPiece) iter.next();
			if (p.isSpawned() && p.contains(x, y)) {
				return p;
			}
		}
		return null;
	}
	
	@Override
	public Piece underMouseInit(float x, float y) {
		return underMouse(x, y);
	}


-------------- BUG FIX --------------

Pieces would not rotate after a different piece was deleted, until a piece was left-clicked again.

This was due to the way the input handler works when dragging:

	@Override
	public boolean touchDragged(int screenX, int screenY, int pointer) {
		touch.set(screenX, screenY, 0);
		world.getRenderer().getCamera().unproject(touch);
		
		float x = touch.x; float y = touch.y;
		if (dragging != null) {
			drag.translateWOC(x - touchX, y - touchY);
			touchX = x; touchY = y;
		}
		else if (rotating != null) {
			newRotation = rotating.getAngle(x, y);
			rotating.rotate(-(rotation - newRotation));
			rotation = newRotation;
		}
		
		return true;
	}
	
dragging was appearing as non-null, despite being deleted. The required change was here:

	@Override
	public boolean touchUp(int screenX, int screenY, int pointer, int button) {
		...
				// If in the black area, delete the piece
				if (touchO.y < MozaicPlayer.trans) {
					...
					
					dragging.delete();
					dragging = null;
					MozaicAudio.delete();
					return true;
				}

The line "dragging = null;" had to be added.



----- 16-17.01.14 -----

-------------- MAIN MENU UPDATE --------------

Create new main menu, allowing full functionality.
Allow the options to be changed during game.

I decided to add (to the Play button) a 'Choose Mode' button and an 'Options' button. These lead to new screens, ModeChoosingScreen
and OptionsScreen respectively.

Clicking on 'Choose Mode' has the effect of clearing any mozaic in progress, and allows to choose from the different
options: 'Classic', 'Reflect', 'Penrose P1', 'Penrose P2' and 'Penrose P3'. Clicking on the 'Reflect' button, will open
a new screen, ReflectChoiceScreen, which has a button for each kind of reflection implemented. Clicking on one of these or any
of the other buttons on the ModeChoosingScreen will set the game to play the chosen mode, and return to the main menu.

The OptionsScreen has two checkboxes, 'Mute Music' and 'Mute SFX'. These are by default checked. Unchecking them will have the obvious
effect. There is also an 'Okay' button, which will return to the main menu. This screen can also be accessed by pressing the 'Menu' key
on Android devices (or 'o' on a keyboard) during a game, in which case the 'Okay' button will return to the game when pressed.

Also pressing the 'Back' key on Android devices (or 'Esc' on a keyboard) during a game will return to the main menu, clicking on the 
'Play' button without first clicking on 'Choose Mode' will result in returning to the game in progress.


Firstly, for clarity, here is the updated MozaicPlayer class. I have changed to a private static gameMode, which has a getter and a setter,
and there are a few new methods which were required by this update.

	public class MozaicPlayer extends Game {
		
		public static final String VERSION = "0.2.0";
		public static final String LOG = "Mozaic Player";
		public static final int PIECES = 100;
		public static final int assumeWidth = 683;
		public static final int assumeHeight = 683;
		public static int width;
		public static int height;
		public static int size;
		public static float scale;
		public static int trans;
		
		private static GameMode gameMode = GameMode.Classic;
		private static int reflection = 1;
		
		public static final int ClassicID = 5;
		public static final int PenroseID = 1;
		
		public enum GameMode{Classic, PenroseKD, PenroseOri, PenroseRhomb, Reflect}
		
		private static boolean musicOn = false;
		private static boolean sfxOn = false;

		FPSLogger log;
		
		@Override
		public void create() {
			
			width = Gdx.graphics.getWidth(); 
			height = Gdx.graphics.getHeight();
			size = width; // Math.min(width, height);
			scale = (float) size/assumeWidth;
			trans = height - width; // Math.max(width, height) - size;
					
			log = new FPSLogger();
			//setScreen(new SplashScreen(this));
			setScreen(new MainMenu(this));
		}
		
		public void reset() {
			if (gameMode == GameMode.PenroseKD) {
				PenrosePiece.reset();
			}
			else if (gameMode == GameMode.PenroseOri) {
				PenroseOriPiece.reset();
			}
			else if (gameMode == GameMode.PenroseRhomb) {
				PenroseRhomb.reset();
			}
			else {
				ClassicPiece.reset();
			}
		}
	
		public static void setGameMode(GameMode mode) {
			gameMode = mode;
		}
		
		public static GameMode getMode() {
			return gameMode;
		}
		
		public void play() {
		if (gameMode == GameMode.Classic)
			setScreen(new ClassicGameScreen(this));
		else if (gameMode == GameMode.PenroseKD)
			setScreen(new PenroseGameScreen(this));
		else if (gameMode == GameMode.PenroseOri)
			setScreen(new PenroseOriGameScreen(this));
		else if (gameMode == GameMode.PenroseRhomb)
			setScreen(new PenroseRhombGameScreen(this));
		else if (gameMode == GameMode.Reflect)
			setScreen(new ReflectGameScreen(this));
		}
		
		@Override
		public void dispose() {
			super.dispose();
			MozaicAudio.dispose();
		}
	
		@Override
		public void render() {
			super.render();
			//log.log();
		}
		
		@Override
		public void resize(int width, int height) {
			super.resize(width, height);
		}
	
		@Override
		public void pause() {
			super.pause();
		}
	
		@Override
		public void resume() {
			super.resume();
		}
	
		public void toggleMusic() {
			musicOn = !musicOn;
			if (musicOn)
				MozaicAudio.playMusic(true);
			else MozaicAudio.stopMusic();
		}
		
		public void toggleSFX() {
			MozaicAudio.toggleSFX();
			sfxOn = !sfxOn;
		}
	
		public boolean isMusicMuted() {
			return !musicOn;
		}
	
		public boolean isSFXMuted() {
			return !sfxOn;
		}
	
		public static int getReflection() {
			return reflection;
		}
	
		public static void setReflection(int reflection) {
			MozaicPlayer.reflection = reflection;
		}
	}


The only differences in the screens (other than declarations) is the resize method, so that is all I will show.
Here is the updated MainMenu resize method:

	@Override
	public void resize(int width, int height) {
		if(stage == null)
			stage = new Stage(width, height, true);
		stage.clear();
		
		Gdx.input.setInputProcessor(stage);
		
		TextButtonStyle style = new TextButtonStyle();
		style.up = skin.getDrawable("buttonnormal");
		style.down = skin.getDrawable("buttonpressed");
		style.font = black;
		
		playButton = new TextButton("Play", style);
		modeButton = new TextButton("Choose Mode", style);
		optionsButton = new TextButton("Options", style);
		
		playButton.setWidth(400);
		playButton.setHeight(100);
		modeButton.setWidth(400);
		modeButton.setHeight(100);
		optionsButton.setWidth(400);
		optionsButton.setHeight(100);
		
		playButton.setX(Gdx.graphics.getWidth()/2 - playButton.getWidth()/2);
		playButton.setY(Gdx.graphics.getHeight()/2 - playButton.getHeight()/2);
		modeButton.setX(Gdx.graphics.getWidth()/2 - modeButton.getWidth()/2);
		modeButton.setY(Gdx.graphics.getHeight()/2 - modeButton.getHeight()*1.6f);
		optionsButton.setX(Gdx.graphics.getWidth()/2 - optionsButton.getWidth()/2);
		optionsButton.setY(Gdx.graphics.getHeight()/2 - optionsButton.getHeight()*2.7f);
		
		LabelStyle ls = new LabelStyle(white, Color.WHITE);
		label = new Label("Mozaic Player\n" + MozaicPlayer.VERSION, ls);
		label.setX(0);
		label.setY(Gdx.graphics.getHeight()/2 +100);
		label.setWidth(width);
		label.setAlignment(Align.center);
		
		playButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				game.play();
			}
		});
		
		modeButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				game.reset();
				game.setScreen(new ModeChoosingScreen(game));
			}
		});
		
		optionsButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				game.setScreen(new OptionsScreen(game));
			}
		});
		
		stage.addActor(playButton);
		stage.addActor(modeButton);
		stage.addActor(optionsButton);
		stage.addActor(label);
	}

	
Here is the ModeChoosingScreen resize method:

	@Override
	public void resize(int width, int height) {
		if(stage == null)
			stage = new Stage(width, height, true);
		stage.clear();
		
		Gdx.input.setInputProcessor(stage);
		
		TextButtonStyle style = new TextButtonStyle();
		style.up = skin.getDrawable("buttonnormal");
		style.down = skin.getDrawable("buttonpressed");
		style.font = black;
		
		classicButton = new TextButton("Classic", style);
		reflectButton = new TextButton("Reflect", style);
		p1Button = new TextButton("Penrose P1", style);
		p2Button = new TextButton("Penrose P2", style);
		p3Button = new TextButton("Penrose P3", style);
		
		classicButton.setWidth(400);
		classicButton.setHeight(100);
		reflectButton.setWidth(400);
		reflectButton.setHeight(100);
		p1Button.setWidth(400);
		p1Button.setHeight(100);
		p2Button.setWidth(400);
		p2Button.setHeight(100);
		p3Button.setWidth(400);
		p3Button.setHeight(100);

		classicButton.setX(Gdx.graphics.getWidth()/2 - classicButton.getWidth()/2);
		classicButton.setY(Gdx.graphics.getHeight()/2 - classicButton.getHeight()*(-0.6f));
		reflectButton.setX(Gdx.graphics.getWidth()/2 - reflectButton.getWidth()/2);
		reflectButton.setY(Gdx.graphics.getHeight()/2 - reflectButton.getHeight()*0.5f);
		p1Button.setX(Gdx.graphics.getWidth()/2 - p1Button.getWidth()/2);
		p1Button.setY(Gdx.graphics.getHeight()/2 - p1Button.getHeight()*1.6f);
		p2Button.setX(Gdx.graphics.getWidth()/2 - p2Button.getWidth()/2);
		p2Button.setY(Gdx.graphics.getHeight()/2 - p2Button.getHeight()*2.7f);
		p3Button.setX(Gdx.graphics.getWidth()/2 - p3Button.getWidth()/2);
		p3Button.setY(Gdx.graphics.getHeight()/2 - p3Button.getHeight()*3.8f);
		
		LabelStyle ls = new LabelStyle(white, Color.WHITE);
		label = new Label("Mozaic Player\n" + MozaicPlayer.VERSION, ls);
		label.setX(0);
		label.setY(Gdx.graphics.getHeight()/2 +250);
		label.setWidth(width);
		label.setAlignment(Align.center);
		
		classicButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setGameMode(GameMode.Classic);
				game.setScreen(new MainMenu(game));
			}
		});
		
		reflectButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setGameMode(GameMode.Reflect);
				game.setScreen(new ReflectChoiceScreen(game));
			}
		});
		
		p1Button.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setGameMode(GameMode.PenroseOri);
				game.setScreen(new MainMenu(game));
			}
		});
		
		p2Button.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setGameMode(GameMode.PenroseKD);
				game.setScreen(new MainMenu(game));
			}
		});
		
		p3Button.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setGameMode(GameMode.PenroseRhomb);
				game.setScreen(new MainMenu(game));
			}
		});
		
		stage.addActor(classicButton);
		stage.addActor(reflectButton);
		stage.addActor(p1Button);
		stage.addActor(p2Button);
		stage.addActor(p3Button);
		stage.addActor(label);
	}

	
Here is the ReflectChoiceScreen resize method:

@Override
	public void resize(int width, int height) {
		if(stage == null)
			stage = new Stage(width, height, true);
		stage.clear();
		
		Gdx.input.setInputProcessor(stage);
		
		TextButtonStyle style = new TextButtonStyle();
		style.up = skin.getDrawable("buttonnormal");
		style.down = skin.getDrawable("buttonpressed");
		style.font = black;
		
		y0 = new TextButton("Y = 0", style);
		x0 = new TextButton("X = 0", style);
		y_x = new TextButton("Y = -X", style);
		yx = new TextButton("Y = X", style);
		y0x0 = new TextButton("Y = 0  &  X = 0", style);
		y_xyx = new TextButton("Y = -X  &  Y = X", style);
		
		y0.setWidth(400);
		y0.setHeight(100);
		x0.setWidth(400);
		x0.setHeight(100);
		y_x.setWidth(400);
		y_x.setHeight(100);
		yx.setWidth(400);
		yx.setHeight(100);
		y0x0.setWidth(400);
		y0x0.setHeight(100);
		y_xyx.setWidth(400);
		y_xyx.setHeight(100);

		y0.setX(Gdx.graphics.getWidth()/2 - y0.getWidth()/2);
		y0.setY(Gdx.graphics.getHeight()/2 - y0.getHeight()*(-1.3f));
		x0.setX(Gdx.graphics.getWidth()/2 - x0.getWidth()/2);
		x0.setY(Gdx.graphics.getHeight()/2 - x0.getHeight()*-0.2f);
		y_x.setX(Gdx.graphics.getWidth()/2 - y_x.getWidth()/2);
		y_x.setY(Gdx.graphics.getHeight()/2 - y_x.getHeight()*0.9f);
		yx.setX(Gdx.graphics.getWidth()/2 - yx.getWidth()/2);
		yx.setY(Gdx.graphics.getHeight()/2 - yx.getHeight()*2f);
		y0x0.setX(Gdx.graphics.getWidth()/2 - y0x0.getWidth()/2);
		y0x0.setY(Gdx.graphics.getHeight()/2 - y0x0.getHeight()*3.1f);
		y_xyx.setX(Gdx.graphics.getWidth()/2 - y_xyx.getWidth()/2);
		y_xyx.setY(Gdx.graphics.getHeight()/2 - y_xyx.getHeight()*4.2f);
		
		LabelStyle ls = new LabelStyle(white, Color.WHITE);
		label = new Label("Mozaic Player\n" + MozaicPlayer.VERSION, ls);
		label.setX(0);
		label.setY(Gdx.graphics.getHeight()/2 +300);
		label.setWidth(width);
		label.setAlignment(Align.center);
		
		y0.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setReflection(1);
				game.setScreen(new MainMenu(game));
			}
		});
		
		x0.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setReflection(2);
				game.setScreen(new MainMenu(game));
			}
		});
		
		y_x.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setReflection(3);
				game.setScreen(new MainMenu(game));
			}
		});
		
		yx.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setReflection(4);
				game.setScreen(new MainMenu(game));
			}
		});
		
		y0x0.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setReflection(5);
				game.setScreen(new MainMenu(game));
			}
		});
		
		y_xyx.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.setReflection(6);
				game.setScreen(new MainMenu(game));
			}
		});
		
		stage.addActor(y0);
		stage.addActor(x0);
		stage.addActor(y_x);
		stage.addActor(yx);
		stage.addActor(y0x0);
		stage.addActor(y_xyx);
		stage.addActor(label);
	}	

	
Here is the OptionsScreen resize method:

	@Override
	public void resize(int width, int height) {
		if(stage == null)
			stage = new Stage(width, height, true);
		stage.clear();
		
		Gdx.input.setInputProcessor(stage);
		
		TextButtonStyle style = new TextButtonStyle();
		style.up = skin.getDrawable("buttonnormal");
		style.down = skin.getDrawable("buttonpressed");
		style.font = black;
		
		CheckBoxStyle style2 = new CheckBoxStyle();
		style2.checkboxOff = skin2.getDrawable("unchecked");
		style2.checkboxOn = skin2.getDrawable("checked");
		style2.font = white;
		
		muteMusicButton = new CheckBox("Mute Music", style2);
		muteSFXButton = new CheckBox("Mute SFX", style2);
		okayButton = new TextButton("Okay", style);
		
		muteMusicButton.setWidth(400);
		muteMusicButton.setHeight(100);
		muteSFXButton.setWidth(400);
		muteSFXButton.setHeight(100);
		okayButton.setWidth(400);
		okayButton.setHeight(100);
		
		muteMusicButton.setChecked(game.isMusicMuted());
		muteSFXButton.setChecked(game.isSFXMuted());
		
		muteMusicButton.setX(Gdx.graphics.getWidth()/2 - muteMusicButton.getWidth()/2);
		muteMusicButton.setY(Gdx.graphics.getHeight()/2 - muteMusicButton.getHeight()/2);
		muteSFXButton.setX(Gdx.graphics.getWidth()/2 - muteSFXButton.getWidth()/2);
		muteSFXButton.setY(Gdx.graphics.getHeight()/2 - muteSFXButton.getHeight()*1.6f);
		okayButton.setX(Gdx.graphics.getWidth()/2 - okayButton.getWidth()/2);
		okayButton.setY(Gdx.graphics.getHeight()/2 - okayButton.getHeight()*2.7f);
		
		LabelStyle ls = new LabelStyle(white, Color.WHITE);
		label = new Label("Mozaic Player\n" + MozaicPlayer.VERSION, ls);
		label.setX(0);
		label.setY(Gdx.graphics.getHeight()/2 +100);
		label.setWidth(width);
		label.setAlignment(Align.center);
		
		muteMusicButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				game.toggleMusic();
			}
		});
		
		muteSFXButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				game.toggleSFX();
			}
		});
		
		okayButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				if (inGame)
					game.play();
				else game.setScreen(new MainMenu(game));
			}
		});
		
		stage.addActor(muteMusicButton);
		stage.addActor(muteSFXButton);
		stage.addActor(okayButton);
		stage.addActor(label);
	}
	
	
OptionsScreen also has an alternative constructor, allowing to differentiate between an OptionsScreen in game and out of game.

	public OptionsScreen(MozaicPlayer game, boolean inGame){
		this.inGame = inGame;
		this.game = game;	
	}
	
	
There were also some minor changes to the World and InputHandler classes:

	public World(MozaicPlayer game) {
		this.game = game;
		Gdx.input.setInputProcessor(new InputHandler(this));
		Gdx.input.setCatchBackKey(true);
		Gdx.input.setCatchMenuKey(true);
	}
	
	public void mainMenu() {
		game.setScreen(new MainMenu(game));
	}
	
	public void optionsScreen() {
		game.setScreen(new OptionsScreen(game, true));
	}	
	
	
	@Override
	public boolean keyDown(int keycode) {
		if (keycode == Keys.BACK || keycode == Keys.ESCAPE) {
			world.mainMenu();
		}
		else if (keycode == Keys.MENU || keycode == Keys.O) {
			world.optionsScreen();
		}
		return false;
	}
	
	
And finally a static method reset() was	required for each of the Piece abstract classes:
	
(ClassicPiece)	
	public static void reset() {
		classicPieces = new Array<Piece>(false, MozaicPlayer.PIECES);
	}

(PenroseOriPiece)
	public static void reset() {
		pieces = new Array<Piece>(false, MozaicPlayer.PIECES);
		initPieces = new Array<Piece>(false, 6);
		clone = null;
	}
	
(PenrosePiece)
	public static void reset() {
		pieces = new Array<Piece>(false, MozaicPlayer.PIECES);
		initPieces = new Array<Piece>(false, 4);
		clone = null;
	}
	
(PenroseRhomb)
	public static void reset() {
		pieces = new Array<Piece>(false, MozaicPlayer.PIECES);
		initPieces = new Array<Piece>(false, 2);
		clone = null;
	}



----- 19.01.14 -----

-------------- MENU RESIZING --------------	
	*** I ALSO INCREASED THE VOLUME OF FAIL.WAV USING AUDACITY, AND CREATED NEW CHECKBOX IMAGES USING PHOTOSHOP ***

Buttons etc need to be a function of device size, rather than fixed sizes.

Fairly simple to implement in general, there were a few issues with resizing the checkboxes, however.


Changes to MainMenu code:
	public void resize(int width, int height) {
	...
		playButton.setX(Gdx.graphics.getWidth()/2 - playButton.getWidth()/2);
		playButton.setY(Gdx.graphics.getHeight()/2 - playButton.getHeight()/2);
		modeButton.setX(Gdx.graphics.getWidth()/2 - modeButton.getWidth()/2);
		modeButton.setY(Gdx.graphics.getHeight()/2 - modeButton.getHeight()*1.6f);
		optionsButton.setX(Gdx.graphics.getWidth()/2 - optionsButton.getWidth()/2);
		optionsButton.setY(Gdx.graphics.getHeight()/2 - optionsButton.getHeight()*2.7f);
	...	
		LabelStyle ls = new LabelStyle(white, Color.WHITE);
		label = new Label("Mozaic Player\n" + MozaicPlayer.VERSION, ls);
		label.setX(0);
		label.setY(Gdx.graphics.getHeight()*.65f);
		label.setWidth(width);
		label.setAlignment(Align.center);
	...
	}
	
	public void show() {	
	...
		black = new BitmapFont(Gdx.files.internal("data/font.fnt"), false);
		black.setScale(1.5f*MozaicPlayer.scale);
		white = new BitmapFont(Gdx.files.internal("data/whitefont.fnt"), false);
		white.setScale(2f*MozaicPlayer.scale);
	}
	
	
Changes to ModeChoosingScreen code:
	public void resize(int width, int height) {
	...
		classicButton.setWidth(440*MozaicPlayer.scale);
		classicButton.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
		reflectButton.setWidth(440*MozaicPlayer.scale);
		reflectButton.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
		p1Button.setWidth(440*MozaicPlayer.scale);
		p1Button.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
		p2Button.setWidth(440*MozaicPlayer.scale);
		p2Button.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
		p3Button.setWidth(440*MozaicPlayer.scale);
		p3Button.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
	...		
		LabelStyle ls = new LabelStyle(white, Color.WHITE);
		label = new Label("Mozaic Player\n" + MozaicPlayer.VERSION, ls);
		label.setX(0);
		label.setY(Gdx.graphics.getHeight()*.75f);
		label.setWidth(width);
		label.setAlignment(Align.center);	
	...
	}
	
	public void show() {
	...
		black = new BitmapFont(Gdx.files.internal("data/font.fnt"), false);
		black.setScale(1.5f*MozaicPlayer.scale);
		white = new BitmapFont(Gdx.files.internal("data/whitefont.fnt"), false);
		white.setScale(2f*MozaicPlayer.scale);
	}
	
	
Changes to ReflectChoiceScreen code (also changed the text on buttons representing multiple lines of reflection
to be spread accross 2 lines to fit with the resizing of buttons):
	public void resize(int width, int height) {
	...	
		y0x0 = new TextButton("Y = 0\nX = 0", style);
		y_xyx = new TextButton("Y = -X\nY = X", style);
		
		y0.setWidth(440*MozaicPlayer.scale);
		y0.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
		x0.setWidth(440*MozaicPlayer.scale);
		x0.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
		y_x.setWidth(440*MozaicPlayer.scale);
		y_x.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
		yx.setWidth(440*MozaicPlayer.scale);
		yx.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
		y0x0.setWidth(440*MozaicPlayer.scale);
		y0x0.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
		y_xyx.setWidth(440*MozaicPlayer.scale);
		y_xyx.setHeight(Math.min(110*MozaicPlayer.scale, 0.11f*Gdx.graphics.getHeight()));
	...
		LabelStyle ls = new LabelStyle(white, Color.WHITE);
		label = new Label("Mozaic Player\n" + MozaicPlayer.VERSION, ls);
		label.setX(0);
		label.setY(Gdx.graphics.getHeight()*.75f);
		label.setWidth(width);
		label.setAlignment(Align.center);
	...
	}
	
	public void show() {
	...
		black = new BitmapFont(Gdx.files.internal("data/font.fnt"), false);
		black.setScale(1.5f*MozaicPlayer.scale);
		white = new BitmapFont(Gdx.files.internal("data/whitefont.fnt"), false);
		white.setScale(2f*MozaicPlayer.scale);
	}
	
	
Changes to OptionsScreen code (these included the creation of a different sized white font to use for the CheckBox text,
restricting the size of the cell containing the checkbox images so that aspect ratio is maintained, and
applying texture filters to the checkbox images to remove jagged edges):
	public void resize(int width, int height) {
	...
		CheckBoxStyle style2 = new CheckBoxStyle();
		style2.checkboxOff = skin2.getDrawable("unchecked");
		style2.checkboxOn = skin2.getDrawable("checked");
		style2.font = white;
		
		muteMusicButton = new CheckBox("Mute Music", style2);
		muteSFXButton = new CheckBox("Mute SFX", style2);
		okayButton = new TextButton("Okay", style);
		
		muteMusicButton.setWidth(440*MozaicPlayer.scale);
		muteMusicButton.setHeight(84);
		muteMusicButton.getCells().get(0).size(90*MozaicPlayer.scale, 90*MozaicPlayer.scale);
		muteSFXButton.setWidth(440*MozaicPlayer.scale);
		muteSFXButton.setHeight(84);
		muteSFXButton.getCells().get(0).size(90*MozaicPlayer.scale, 90*MozaicPlayer.scale);
		okayButton.setWidth(440*MozaicPlayer.scale);
		okayButton.setHeight(110*MozaicPlayer.scale);
	...		
		LabelStyle ls = new LabelStyle(white2, Color.WHITE);
		label = new Label("Mozaic Player\n" + MozaicPlayer.VERSION, ls);
		label.setX(0);
		label.setY(Gdx.graphics.getHeight()*.65f);
		label.setWidth(width);
		label.setAlignment(Align.center);
	...
	}

	public void show() {
	...
		Iterator<Texture> iter = atlas2.getTextures().iterator();
		while (iter.hasNext()) {
			iter.next().setFilter(TextureFilter.Linear, TextureFilter.Linear);
		}
	...
		black = new BitmapFont(Gdx.files.internal("data/font.fnt"), false);
		black.setScale(1.5f*MozaicPlayer.scale);
		white = new BitmapFont(Gdx.files.internal("data/whitefont.fnt"), false);
		white.setScale(1.5f*MozaicPlayer.scale);
		white2 = new BitmapFont(Gdx.files.internal("data/whitefont.fnt"), false);
		white2.setScale(2f*MozaicPlayer.scale);
	}
	


----- 20.01.14 -----

-------------- SAVING --------------	

Implement session saving.
Change so that instead of Play we have Resume when a session has begun and not been reset.

The second change was very simple, only requiring the creation of a boolean started, which is manipulated and
checked by the MainMenu class, and is also saved and loaded when quitting.

As for the first change, I researched how to save libgdx games and the following method seemed the best idea: 
using the libgdx library class Json to convert an object containing the required variables into String format and
then storing that as a local text file using a FileHandle, another libgdx library class.
I created a class called Save, which looked like this:

public class Save {
	final MozaicPlayer.GameMode mode;
	final Array<Piece> pieces;
	final boolean musicOn, sfxOn, started;
	
	public Save(MozaicPlayer.GameMode mode, boolean started, Array<Piece> pieces, boolean musicOn, boolean sfxOn) {
		this.mode = mode;
		this.started = started;
		this.pieces = pieces;
		this.musicOn = musicOn;
		this.sfxOn = sfxOn;
	}
}

However, Json requires an empty constructor, so was changed to this:

public class Save {
	MozaicPlayer.GameMode mode;
	Array<Piece> pieces;
	boolean musicOn, sfxOn, started;
	
	public Save(MozaicPlayer.GameMode mode, boolean started, Array<Piece> pieces, boolean musicOn, boolean sfxOn) {
		this.mode = mode;
		this.started = started;
		this.pieces = pieces;
		this.musicOn = musicOn;
		this.sfxOn = sfxOn;
	}
	
	public Save() {
	}
}

To deal with retrieving the pieces, I created a method in MozaicPlayer getPieces():
(and the obvious, very similar method loadPieces)

	private Array<Piece> getPieces() {
		Array<Piece> pieces = null;
		if (gameMode == GameMode.Classic)
			pieces = ClassicPiece.getPieces();
		else if (gameMode == GameMode.PenroseKD)
			pieces = PenrosePiece.getPieces();
		else if (gameMode == GameMode.PenroseOri)
			pieces = PenroseOriPiece.getPieces();
		else if (gameMode == GameMode.PenroseRhomb)
			pieces = PenroseRhomb.getPieces();
		else if (gameMode == GameMode.Reflect)
			pieces = ClassicPiece.getPieces();
		return pieces;
	}

Along with the obvious methods in the Piece classes:

	public static void setPieces(Array<Piece> newPieces) {
		pieces = newPieces;
	}
	
	public static Array<Piece> getPieces() {
		return pieces;
	}
	
However, because of the way Json works, this was not good enough. Json required all of the pieces to have blank constructors,
and then if those were added it required a blank constructor for the libgdx library class Polygon. So I gave up on this
approach and tried to think of another.
I soon realised that each piece is easily defined by and easily created from its ID, translation and rotation. So I created a new
class SavePiece and changed Save to take an Array of type SavePiece instead of Piece:

public class SavePiece {
	public int id;
	public float transX;
	public float transY;
	public float rot;
	
	public SavePiece(int id, float transX, float transY, float rot) {
		this.id = id;
		this.transX = transX;
		this.transY = transY;
		this.rot = rot;
	}
	
	public SavePiece() {
	}
}

public class Save {
	MozaicPlayer.GameMode mode;
	Array<SavePiece> pieces;
	boolean musicOn, sfxOn, started;
	
	public Save(MozaicPlayer.GameMode mode, boolean started, Array<SavePiece> pieces, boolean musicOn, boolean sfxOn) {
		this.mode = mode;
		this.started = started;
		this.pieces = pieces;
		this.musicOn = musicOn;
		this.sfxOn = sfxOn;
	}
	
	public Save() {
	}
}

I then created methods in the Piece classes:

	public static Array<SavePiece> save() {
		Iterator<Piece> iter = pieces.iterator();
		Piece p;
		Array<SavePiece> savePieces = new Array<SavePiece>(pieces.size);
		while (iter.hasNext()) {
			p = iter.next();
			savePieces.add(new SavePiece(p.getID(), p.getTransX(), p.getTransY(), p.getRotation()));
		}
		return savePieces;
	}
	
	public static void load(Array<SavePiece> savePieces) {
		reset();
		Iterator<SavePiece> iter = savePieces.iterator();
		SavePiece s;
		Piece p;
		while (iter.hasNext()) {
			s = iter.next();
			p = create(s.id);
			p.translateWOC(s.transX, s.transY);
			p.rotate(s.rot);
		}
	}
	
	private static Piece create(int id) {
		if (id > MozaicPlayer.ClassicID) {
			return RhombusFactory.create(id);
		}
		else 
			return TriangleFactory.create(id);
	}
	
	public float getTransY() {
		return polygon.getY();
	}
	
	public float getTransX() {
		return polygon.getX();
	}

which are very similar for each class.
This worked, with a couple of updates to the Triangle class (changing the create method from creating and translating to
simply creating a triangle in the correct location), although this meant duplicate starting pieces were created each time
the game was loaded. To fix this, ClassicPiece required the following change:
		
		while (iter.hasNext()) {
			s = iter.next();
			if (s.transY != 0)
				p = create(s.id);
				p.translateWOC(s.transX, s.transY);
				p.rotate(s.rot);
			}
		}
		
while the others required the even more simple change from
		Iterator<Piece> iter = pieces.iterator();
to
		Iterator<Piece> iter = getIterator();
	
(which I also changed in ClassicPiece for consistency).


Here are the finalised changes to the MozaicPlayer class:

public static boolean started = false;
	...
	public void create() {
	...
		try { load(); }
		catch (SerializationException exception) { exception.printStackTrace(); }
		//setScreen(new SplashScreen(this));
		setScreen(new MainMenu(this));
	}
	
	private void load() {
		Json json = new Json();
		FileHandle saveFile = Gdx.files.local("data/save_file.txt");
		String saveString = saveFile.readString();
		Save save = json.fromJson(Save.class, saveString);
		if (save != null) {
			gameMode = save.mode;
			started = save.started;
			if (started) loadPieces(save.pieces);
			musicOn = save.musicOn;
			sfxOn = save.sfxOn;
		}
	}
	
	public void saveAndQuit() {
		Json json = new Json();
		Array<SavePiece> pieces = savePieces();
		Save save = new Save(gameMode, started, pieces, musicOn, sfxOn);
		String saveString = json.toJson(save, Save.class);
		FileHandle saveFile = Gdx.files.local("data/save_file.txt");
		saveFile.writeString(saveString, false);
		System.exit(0);
	}
	
	private Array<SavePiece> savePieces() {
		Array<SavePiece> pieces = null;
		if (gameMode == GameMode.PenroseKD) {
			pieces = PenrosePiece.save();
		}
		else if (gameMode == GameMode.PenroseOri) {
			pieces = PenroseOriPiece.save();
		}
		else if (gameMode == GameMode.PenroseRhomb) {
			pieces = PenroseRhomb.save();
		}
		else {
			pieces = ClassicPiece.save();
		}
		return pieces;
	}
	
	private void loadPieces(Array<SavePiece> pieces) {
		if (gameMode == GameMode.PenroseKD) {
			PenrosePiece.load(pieces);
		}
		else if (gameMode == GameMode.PenroseOri) {
			PenroseOriPiece.load(pieces);
		}
		else if (gameMode == GameMode.PenroseRhomb) {
			PenroseRhomb.load(pieces);
		}
		else {
			ClassicPiece.load(pieces);
		}
	}
	
	public void reset() {
		started = false;
		FileHandle saveFile = Gdx.files.local("data/save_file.txt");
		saveFile.writeString("", false);
	...
	}


This implementation was not sufficient for correct behaviour of Reflect Pieces. I added if clauses to distinguish the Classic
and Reflect GameModes when loading and saving, and added the following methods to ReflectPiece:

public static Array<SavePiece> save() {
		Iterator<Piece> iter = getIterator();
		ReflectPiece p;
		Array<SavePiece> savePieces = new Array<SavePiece>(pieces.size);
		while (iter.hasNext()) {
			p = (ReflectPiece) iter.next();
			if (p.getRefs().get(0) == p)	// If not a reflection
				savePieces.add(new SavePiece(p.getID(), p.getTransX(), p.getTransY(), p.getRotation()));
		}
		return savePieces;
	}

	public static void load(Array<SavePiece> savePieces) {
		reset();
		Iterator<SavePiece> iter = savePieces.iterator();
		SavePiece s;
		ReflectPiece p;
		while (iter.hasNext()) {
			s = iter.next();
			if (s.transY > 0) { // Works because of the implementation of the RefFactories.
				p = (ReflectPiece) create(s.id);
				p.spawn();
				p.translateWOC(s.transX - p.getTransX(), s.transY - p.getTransY()); // Translate by the difference, since ReflectPieces are created
				p.rotate(s.rot);													// with a translation
			}
		}
	}
	
	private static Piece create(int id) {
		if (id > MozaicPlayer.ClassicID) {
			return RefRhombusFactory.create(MozaicPlayer.getReflection(), id);
		}
		else 
			return RefTriangleFactory.create(MozaicPlayer.getReflection(), id);
	}
	
	@Override
	public float getTransY() {
		return polygon.getY();
	}
	
	@Override
	public float getTransX() {
		return polygon.getX();
	}
	
	
	
----- 21.01.14 -----

-------------- BUGFIX --------------	

Rhombus xy and x-y reflections have incorrect orientations.

This issue arose and was not noticed for such a long time, because the code was originally just taken from RefTriangle, which was working perfectly,
and the translations modified to fit the different kind of piece. And these simple modifications worked for the x0 and y0 reflections, which are the
ones I most frequently used. However, these only worked for the triangles because of the properties of the triangles, the rhombuses instead required
a rotation of 45 degrees along with a more complicated translation to place the piece correctly.

The reflection creation in RefRhombus now uses the following code to construct the relevent pieces:

		if (ref == 3 || ref == 6)
			RefRhombusFactory.reflect(MozaicPlayer.width - WIDTH/2 - SLIDE, MozaicPlayer.height - MozaicPlayer.trans - WIDTH/2 - SLIDE, 1, 1, (-rot + 45) % 360, refPieces, color, ref, id);

		if (ref == 4 || ref == 6)
			RefRhombusFactory.reflect(-WIDTH/2, WIDTH/2, 1, 1, (-rot+45) % 360, refPieces, color, ref, id);
			


----- 22.01.14 -----

-------------- CAMERA SCROLLING --------------	

Need to implement camera scrolling.

This was simple to implement, it might be possible to find a better solution for controlling it, but I am happy with this for now.
I decided on the fairly obvious solution of dragging blank space to scroll. I created a blank method scroll(x,y) in WorldRenderer, 
and the following method scroll in ZoomingWorldRenderer:

	@Override
	public void scroll(float x, float y) {
		cam.translate(x/3, y/3);
		cam.update();
	}
	
The /3 is fairly arbitrary, I just chose a value that made the camera scroll at what I felt was an appropriate speed.
I also updated the input handler, with:

(touchDown)
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCameraO().unproject(touch);
			
			if (touch.y >= MozaicPlayer.trans) {
				touch.set(screenX, screenY, 0);
				world.getRenderer().getCamera().unproject(touch);
				touchX = touch.x; touchY = touch.y;
				initX = touchX; initY = touchY;
				dragging = world.underMouse(touchX, touchY);
				if (dragging != null)
					drag = dragging.clonef();
				else
					scrolling = true;
			}
			...
		}

(touchUp)		
		if (button == 0) {
			touch.set(screenX, screenY, 0);
			world.getRenderer().getCamera().unproject(touch);
			float x = touch.x; float y = touch.y;
			touchO.set(0, screenY, 0);
			world.getRenderer().getCameraO().unproject(touchO);
						
			if (dragging != null) {
			...
			}
			else 
				scrolling = false;							
		}
		
	public boolean touchDragged(int screenX, int screenY, int pointer) {
		touch.set(screenX, screenY, 0);
		world.getRenderer().getCamera().unproject(touch);
		
		float x = touch.x; float y = touch.y;
		if (scrolling == true) {
			world.getRenderer().scroll((x - touchX), (y - touchY));
			touchX = x; touchY = y;
		}
	...
	}
	
	
-------------- BUGFIX --------------
	
The following message appears on exit: "AL lib: alc_cleanup: 1 device not closed"
			
Googling this message I found out that this meant that the application was not cleaning up the audio before exiting,
since System.exit(0) does not correctly dispose audio.

Instead the code (in MozaicPlayer) is now:

	public void saveAndQuit() {
	...
		Gdx.app.exit();
	}
	
	
-------------- BUGFIX --------------

Kite/Dart (P2) snapping is not working.

This was a very simple fix, I quickly narrowed the error down to the SnapTo class, this clause was never running:

		else if(MozaicPlayer.GAMEMODE == GameMode.PenroseKD) {
		...
		}
		
This was due to a change I had made a while back, all the other clauses check the SnapTo variable GAMEMODE, rather than 
MozaicPlayer.GAMEMODE. And since I recently changed the variable to a private variable gameMode, and GAMEMODE is no longer used,
this needed to be changed:

		else if(GAMEMODE == GameMode.PenroseKD) {		
		...
		}		



----- 26.01.14 -----

-------------- BUGFIX --------------

Translations failing when pieces dragged 'below 0' after zooming out.
Issues with spawn pieces appearing.

This was due to a couple of related issues.

The first change I made, which fixed the first of the two issues, was changing the line in the overlaps() method
of the piece classes to
	Iterator<Piece> iter = getIterator();
from
	Iterator<Piece> iter = pieces.iterator();
(apart from PenroseRhomb which already used this implementation)

I then narrowed the problem of the pieces appearing down to the section in the InputHandler class where penrose pieces have
successful snaps (changes are noted by -- EXPLANATION OF CHANGE):

	// Penrose snapping does the snap itself, including a rotation if necessary
	else {
		if (dragging.overlaps()) {
			-- I uncommented the following line, I believe it was commented out for debugging purposes and I forgot about it
			dragging.translateWOC(initX - x, initY - y);
			
			// Necessary if the piece was originally bordering another shape, but may
			// cause 'new snaps' to take place, although in theory this should not happen
			
			// SnapTo.snap(dragging, getIterator());
			
			MozaicAudio.dragFail();
		}
		
		else {
			MozaicAudio.dragSnap();
			-- I added this if statement, previously replace was always called, which was causing the bug
			if (isNew) 
				replace(dragging);
		}
	}
	
	
	
----- 03.02.14 -----

-------------- BUGFIX --------------	

Camera scrolling is 'backwards'.

This was a very simple fix in ZoomingWorldRenderer:

From
	@Override
	public void scroll(float x, float y) {
		cam.translate(x/3, y/3);
		cam.update();
	}
	
To	
	@Override
	public void scroll(float x, float y) {
		cam.translate(-x/3, -y/3);
		cam.update();
	}
	
I also changed to this, to increase speed slightly.
	@Override
	public void scroll(float x, float y) {
		cam.translate(-x/2, -y/2);
		cam.update();
	}



----- 07-09.02.14 -----

Complete restructuring of code after discussion with my tutor and project supervisor. The aim was to generalise the pieces as much as possible.
This required changing Piece to an abstract class, and moving most of the implementation to this level. Since the original pieces on the fixed
grid is quite different and only requires convex pieces, I then have seperate PenrosePiece and OriginalPiece abstract classes. These are then
extended by the abstract classes representing each kind of piece, which now have very little code in them. And finally these, as before
are extended by the individual classes representing each piece.

Firstly, here is the new Piece class:

	We have a few new variables: triangles is similar to the old representation of the non-convex pieces, it contains several (triangular) polygons,
	which together make up the shape, (polygon is a polygon representing the entire shape). size is the number of triangles representing the polygon,
	it is set as the size of the array triangles.
	When translating, we first translate the triangles, and run an overlaps check (since overlaps uses these convex shapes in its calculations), and
	if the overlaps check passes, the polygon representing the entire piece is also translated, otherwise the triangles are translated back.
	When getting the vertices of the entire shape, (for snapping among other things) we simply use the polygon variable.
	For further abstraction, the Classic and Reflect puzzles both now store initPieces and have 3 different getIterator methods, as the Penrose puzzles
	had.
	Overlaps now works by running a for loop through each array of triangles, and comparing all of them together.
	
public abstract class Piece {
	
	protected Polygon polygon;
	protected Array<Polygon> triangles;
	protected Color color;
	protected static Array<Piece> initPieces = new Array<Piece>(false, 10);
	public static Piece clone;
	protected float rot;
	protected static Array<Piece> pieces = new Array<Piece>(false, MozaicPlayer.PIECES);
	private int id;
	private int size;
	
	public Piece(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		this.polygon = polygon;
		this.triangles = triangles;
		this.color = color;
		this.rot = rot;
		polygon.setRotation(rot);
		this.id = id;
		pieces.add(this);
		size = triangles.size;
	}
	
	public static void reset() {
		pieces = new Array<Piece>(false, MozaicPlayer.PIECES);
		initPieces = new Array<Piece>(false, 6);
		clone = null;
	}
	
	public static Iterator<Piece> getInitIterator() {
		return initPieces.iterator();
	}
	
	public static Iterator<Piece> getFullIterator() {
		return pieces.iterator();
	}
	
	public void delete() {
		pieces.removeValue(this, true);
		initPieces.removeValue(this, true);
	}
	
	public static Piece getClone() {
		return clone;
	}
	
	public static Iterator<Piece> getIterator() {
		Array<Piece> temp = new Array<Piece>(false, pieces.size);
		for(Piece p : pieces) {
			temp.add(p);
		}
		temp.removeAll(initPieces, true);
		return temp.iterator();	
	}
	

	
	protected void setOrigin(float x, float y) {
		polygon.setOrigin(x, y);
		for (Polygon triangle : triangles)
			triangle.setOrigin(x, y);
	}

	public static Array<SavePiece> save() {
		Iterator<Piece> iter = getIterator();
		Piece p;
		Array<SavePiece> savePieces = new Array<SavePiece>(pieces.size);
		while (iter.hasNext()) {
			p = iter.next();
			savePieces.add(new SavePiece(p.getID(), p.getTransX(), p.getTransY(), p.getRotation()));
		}
		return savePieces;
	}
	
	protected abstract Piece create(int id);
	
	public float getTransY() {
		return polygon.getY();
	}
	
	public float getTransX() {
		return polygon.getX();
	}
	
	public boolean translate(float x, float y) {
		for (Polygon triangle : triangles)
			triangle.translate(x, y);
			
		if (overlaps()) {
			for (Polygon triangle : triangles)
				triangle.translate(-x, -y);
			return false;
		}	
		
		polygon.translate(x, y);
		
		return true;
	}
	
	public void translateWOC(float x, float y) {
		for (Polygon triangle : triangles)
			triangle.translate(x, y);
		
		polygon.translate(x, y);
	}
	
	public float getAngle(float x, float y) {
		Vector2 centre = centre(getVerts());
		float rx = x - centre.x;
		float ry = y - centre.y;
		float rot = (float) Math.toDegrees(Math.atan(ry / rx));
		if (rot < 0)
			rot += 180;
		if (ry < 0)
			rot += 180;
		return rot;
	}
	
	private Vector2 centre(float[] transformedVertices) {
		int n = transformedVertices.length;
		float x = 0, y = 0;
		for (int i = 0; i < n; i+=2) {
			x += transformedVertices[i];
			y += transformedVertices[i+1];
		}
		x /= (n/2);
		y /= (n/2);
		return new Vector2(x, y);
	}
	
	public boolean contains(float x, float y) {
		for (Polygon triangle : triangles) {
			if (triangle.contains(x, y))
				return true;
		}
		return false;
	}
	
	public Polygon get(int i) {
		return triangles.get(i);
	}
	
	public Piece clonef() {
		Color c = color.cpy();
		c.a = 0.5f;
		Polygon triangle_;
		Array<Polygon> triangles_ = new Array<Polygon>(false, 4);
		for (Polygon triangle: triangles) {
			triangle_ = new Polygon(triangle.getTransformedVertices());
			triangles_.add(triangle_);
		}
		Piece piece = clonef_(new Polygon(getVerts()), triangles_, 0, c, -1, polygon.getOriginX(), polygon.getOriginY());
		clone = piece;
		return piece;
	}
	
	public abstract Piece clonef_(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, float oX, float oY);
	
	public int getID() {
		return id;
	}
	
	public void setID(int id) {
		this.id = id;
	}
	
	public void rotate(float degrees) {	
		polygon.rotate(degrees);
		for (Polygon triangle : triangles)
			triangle.rotate(degrees);
	}
	
	public float getRotation() {
		return polygon.getRotation();
	}
	
	protected void setRotation(float degrees) {
		polygon.setRotation(degrees);
		for (Polygon triangle : triangles)
			triangle.setRotation(degrees);
	}
	
	public float[] getVerts() {
		return polygon.getTransformedVertices();
	}
	
	public int getSize() {
		return size;
	}
	
	public boolean overlaps() {
		Piece q;
		float max;
		MinimumTranslationVector mtv;
		
		Array<MinimumTranslationVector> mtvs = new Array<MinimumTranslationVector>(false, 9*MozaicPlayer.PIECES); //TODO choose value
		
		Iterator<Piece> iter = getIterator();
		while (iter.hasNext()) {
			q = iter.next();
						
			if (this != q) {
				for (int i = 0; i < size; i++) {
					for (int j = 0; j < q.getSize(); j++) {
						mtv = new MinimumTranslationVector();
						Intersector.overlapConvexPolygons(get(i), q.get(j), mtv);
						mtvs.add(mtv);
					}
				}
			}
		}
		
		max = 0;
		for (int i = 0; i < mtvs.size; i++) {
			mtv = mtvs.get(i);
			// If we have already checked all values
			if (mtv == null)
				break;
						
			max = Math.max(max, mtv.depth);
		}
		
		// Should 'tighten' this value later
		if (max > 1)
			return true;
		else return false;
	}
	
	public void draw(ShapeRenderer sr) {
		float [] verts;
		sr.setColor(color);
		for (Polygon triangle : triangles) {
			verts = triangle.getTransformedVertices();
			sr.filledTriangle(verts[0], verts[1], verts[2], verts[3], verts[4], verts[5]);
		}
	}

	public abstract void fix(Vector2 v0, Vector2 v1, Vector2 u0, Vector2 u1);
	
	public abstract boolean fixRotation(float originalRot);
}


Secondly we have the OriginalPiece class:
	
	We have a separate load method, since this kind of piece has the requirement that the shape is off the black rectangle.
	(However, this needs reviewing, does this mean PenrosePieces create more and more shapes on the black rectangle?)
	The 'fix' method is blank, since it is not required by the original pieces, which have fixed rotations.
	It also has a fixRotation method, to deal with these fixed rotations, PenrosePieces simply set the rotation to the new value.
	Overlaps is overridden, since OriginalPieces use the simpler representation where triangles is an empty array, and
	operations only affect the polygon variable.
	Because of this, we also override the translate methods, the get methods, and the contains method.
	
public abstract class OriginalPiece extends Piece {

	protected static final Array<Polygon> EMPTY = new Array<Polygon> (false, 0);

	private static final int bottom1 = MozaicPlayer.trans;
	private static final int bottom2 = -100;
	private static final int left1 = 0;
	private static final int left2 = -100;
	private static final int right1 = MozaicPlayer.size;
	private static final int right2 = right1 + 100;
	private static final int top1 = MozaicPlayer.height;
	private static final int top2 = top1 + 100;
	
	protected static final Polygon LEFT = new Polygon(new float[] {left1, bottom2, left1, top2, left2, top2, left2, bottom2} );
	protected static final Polygon RIGHT = new Polygon(new float[] {right1, bottom2, right1, top2, right2, top2, right2, bottom2} );
	protected static final Polygon TOP = new Polygon(new float[] {left2, top1, right2, top1, right2, top2, left2, top2} );
	protected static final Polygon BOTTOM = new Polygon(new float[] {left2, bottom1, right2, bottom1, right2, bottom2, left2, bottom2} );
	
	OriginalPiece q;
	
	private MinimumTranslationVector mtv;
	private float max;
	
	public OriginalPiece(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		super(polygon, triangles, rot, color, id);
	}
	
	public static void load(Array<SavePiece> savePieces, Piece q) {
		reset();
		Iterator<SavePiece> iter = savePieces.iterator();
		SavePiece s;
		Piece p;
		while (iter.hasNext()) {
			s = iter.next();
			if (s.transY != 0 || s.transX != 0) { //TODO only need to check y!= 0, since no x only exist...
				p = q.create(s.id);
				p.translateWOC(s.transX, s.transY);
				p.rotate(s.rot);
			}
		}
	}
	
	public void fix(Vector2 v0, Vector2 v1, Vector2 u0, Vector2 u1){
		
	}

	public boolean fixRotation(float originalRot) {
		// set rotation to the nearest multiple of 45 that doesn't overlap
		boolean pos = false;
		int mul = 1;
		float rot = polygon.getRotation();
		float diff = rot % 45;
		if (diff < 22.5)
			rotate(-diff);
		else {
			rotate(45 - diff);
			pos = true;
		}
		while (overlaps()) {
			if (pos)
				rotate(-45 * mul);
			else 
				rotate(45 * mul);
			mul += 1;
			//TODO
			// safety net, shouldn't be required
			if (mul == 8) {
				setRotation(originalRot);
				break;
			}
			pos = !pos;
		}
		return false;
	}
	
	@Override
	public boolean overlaps() {
		
		Array<MinimumTranslationVector> mtvs = new Array<MinimumTranslationVector>(false, MozaicPlayer.PIECES + 4);
		
		mtv = new MinimumTranslationVector();
		Intersector.overlapConvexPolygons(polygon, LEFT, mtv);
		mtvs.add(mtv);
		mtv = new MinimumTranslationVector();
		Intersector.overlapConvexPolygons(polygon, RIGHT, mtv);
		mtvs.add(mtv);
		mtv = new MinimumTranslationVector();		
		Intersector.overlapConvexPolygons(polygon, TOP, mtv);
		mtvs.add(mtv);
		mtv = new MinimumTranslationVector();		
		Intersector.overlapConvexPolygons(polygon, BOTTOM, mtv);
		mtvs.add(mtv);
		
		Iterator<Piece> iter = getIterator();
		while (iter.hasNext()) {
			q = (OriginalPiece) iter.next();
						
			if (this != q) {
				mtv = new MinimumTranslationVector();
				Intersector.overlapConvexPolygons(polygon, q.get(0), mtv);
				mtvs.add(mtv);
			}
		}
		
		max = 0;
		for (int i = 0; i < mtvs.size; i++) {
			mtv = mtvs.get(i);
			// If we have already checked all values
			if (mtv == null)
				break;
						
			max = Math.max(max, mtv.depth);
		}
		
		// Should 'tighten' this value later
		if (max > 1)
			return true;
		else return false;
	}
	
	@Override
	public boolean contains(float x, float y) {
		return polygon.contains(x, y);
	}
	
	@Override
	public Polygon get(int i) {
		return polygon;
	}
	
	public Polygon get() {
		return polygon;
	}
	
	@Override
	public boolean translate(float x, float y) {
		polygon.translate(x, y);
		if (overlaps()) {
			polygon.translate(-x, -y);
			return false;
		}
		return true;
	}
	
	@Override
	public void translateWOC(float x, float y) {
		polygon.translate(x, y);
	}
	
	@Override
	public abstract void draw(ShapeRenderer sr);
}

		
Thirdly we have the PenrosePiece class (which should maybe be called GeneralPiece?):

	We have the load method here, as in the OriginalPiece class, since it is slightly different.
	Note: after trying a couple of different methods of getting the correct 'create' method, the main one being a method getInstance() 
	(which I was also using to deal with the static method getIterator, which at the time called getInstance().getIterator()) which 
	returned the first Piece in the Array pieces, I decided to pass in a Piece (we will see how later).
	We also have the getClosest method, since this method is required for the fix method, used in snapping Penrose (free rotating) pieces;
	the fix() method, and the simple fixRotation method.
	
public abstract class PenrosePiece extends Piece {

	PenrosePiece q;
	
	public PenrosePiece(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		super(polygon, triangles, rot, color, id);
	}
	
	public static void load(Array<SavePiece> savePieces, Piece q) {
		reset();
		Iterator<SavePiece> iter = savePieces.iterator();
		SavePiece s;
		Piece p;
		while (iter.hasNext()) {
			s = iter.next();
			p = q.create(s.id);
			p.translateWOC(s.transX, s.transY);
			p.rotate(s.rot);
		}
	}
	
	private Vector2 getClosest(Vector2 u) {
		
		float[] coords = getVerts();
		int l = coords.length/2;
		Array<Vector2> verts = new Array<Vector2>(false, l);
		float[] dsts = new float[l];
		Vector2 v;
		float min = 1000;
		
		for (int i = 0; i < l*2; i++) {
			v = new Vector2(coords[i], coords[++i]);
			verts.add(v);
			dsts[i/2] = v.dst(u);
			min = Math.min(dsts[i/2], min);
		}

		for (int i = 0; i < l; i++) {
			if (dsts[i] == min)
				return verts.get(i);
		}
				
		return null;
	}
	
	public void fix(Vector2 v0, Vector2 v1, Vector2 u0, Vector2 u1){
		float d0 = v0.dst(u0);
		float d1 = v1.dst(u1);
		
		if (d0 > d1) {
			Vector2 v = v0;
			v0 = v1;
			v1 = v;
			v = u0;
			u0 = u1;
			u1 = v;
		}
				
		//TODO
		// Could use i.e Math.abs(d0 - d1) < 0.05 instead of computing rot?
		if (d0 != d1) {
			
			float a = (float) ( Math.pow((v1.x - v0.x), 2) + Math.pow((v1.y - v0.y), 2) );
			float b = (float) ( Math.pow((u1.x - u0.x), 2) + Math.pow((u1.y - u0.y), 2) );
			float c = (float) ( Math.pow(((u1.x + v0.x - u0.x) - v1.x), 2) + Math.pow(((u1.y + v0.y - u0.y) - v1.y), 2) );
			float rot = (float) Math.toDegrees( Math.acos( (a+b-c) / (2 * Math.sqrt(a) * Math.sqrt(b)) ) );
			if ( rot > 0.5 ) {
			
			float dx = u1.x - u0.x;
			float dx2 = dx * dx;
			float dy = u1.y - u0.y;
			float dy2 = dy * dy;
			float ax = v0.x;
			float ay = v0.y;
			float bx = v1.x;
			float by = v1.y;
			float s_ = ( dy2 * dx * (bx - ax) - dx2 * dy * (by - ay) ) / ( dy2 - dx2 );
			float s = ( bx - ax - s_ / dx ) / dx;
			
			Vector2 x_ = new Vector2(s * dx + ax, s * dy + ay);
			
			if (Math.abs(dy) > Math.abs(dx)) {			
				if (dy > 0 && v1.x < x_.x)
					rot = - rot;
				if (dy < 0 && v1.x > x_.x)
					rot = - rot;
			}
			
			else {
				if (dx > 0 && v1.y > x_.y)
					rot = - rot;
				if (dx < 0 && v1.y < x_.y)
					rot = - rot;
			}
			
			rotate(rot);
			}
		}
		Vector2 v_ = getClosest(u1);
		translateWOC(u1.x - v_.x, u1.y - v_.y);
	}
	
	public boolean fixRotation(float originalRot) {
		if (overlaps()) {
			setRotation(originalRot);
			return true;
		}
		return false;
	}
}



Next we have the third and final layer of abstract classes, starting with ClassicPiece:

This simply calls the super method for construction, and refers the create method to the correct Factory class.
There is also a static nullPiece method, this is called by MozaicPlayer to pass the correct class to the load method.

public abstract class ClassicPiece extends OriginalPiece {
	
	public ClassicPiece(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		super(polygon, triangles, rot, color, id);
	}
	
	public static ClassicPiece nullPiece() {
		return TriangleFactory.create(0);
	}
	
	protected Piece create(int id) {
		if (id > MozaicPlayer.ClassicID) {
			return RhombusFactory.create(id);
		}
		else 
			return TriangleFactory.create(id);
	}
}


And we have the far more complicated ReflectPiece class:

	Firstly we have several new variables, these are the same extra variables that used to exist in this class,
	along with an id variable used to store a visible id required for the creation of reflection.
	We have a blank implementation of clonef_, since ReflectPieces need their own clonef method, this is also
	why we override clonef with an abstract method.
	The 'main' constructor calls the super constructor, assigns the ref and (visible) id variables, creates 
	the refPieces array, and populates it by calling the createReflections method.
	The secondary constructor calls the super constructor, assigns the ref, id and refPieces, and adds 
	the Piece to refPieces.
	We then have the methods for spawning etc. which are very basic.
	And then we have the complicated methods for translation and rotation, and a deletion method which calls
	the super.delete method for each of the pieces in refPieces.

public abstract class ReflectPiece extends OriginalPiece {

	// An array containing all the reflected pieces corresponding to this one
	protected Array<ReflectPiece> refPieces;
	// An integer identifying the type of reflection
	protected int ref;
	
	// Variables required later
	protected OriginalPiece p;
	protected Polygon poly;
	protected Iterator<ReflectPiece> iter1;
	protected Iterator<Piece> iter2;
	protected boolean spawned;
	
	protected int id;
	
	public Piece clonef_(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, float oX, float oY) {
		return null;
	}
	
	@Override
	public abstract Piece clonef();
	
	public ReflectPiece(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, int ref) {
		super(polygon, triangles, rot, color, id);
		this.ref = ref;
		this.id = id;
		
		int size = 2;
		if (ref > 4)
			size += 2;
		refPieces = new Array<ReflectPiece>(false, size);
		refPieces.add(this);
		createReflections();
		spawned = true;
	}
	
	public ReflectPiece(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, int ref, Array<ReflectPiece> refPieces) {
		super(polygon, triangles, rot, color, id);
		this.ref = ref;
		this.id = id;
		
		this.refPieces = refPieces;
		refPieces.add(this);
		spawned = false;
	}
	
	protected abstract void createReflections();
	
	public static ReflectPiece nullPiece() {
		return RefTriangleFactory.create(1, 0);
	}
	
	@Override
	protected Piece create(int id) {
		if (id > MozaicPlayer.ClassicID) {
			return RefRhombusFactory.create(MozaicPlayer.getReflection(), id);
		}
		else 
			return RefTriangleFactory.create(MozaicPlayer.getReflection(), id);
	}
	
	protected void spawn_() {
		spawned = true;
	}
	
	public void spawn() {
		for (ReflectPiece p : refPieces)
			p.spawn_();
	}
	
	public boolean isSpawned() {
		return spawned;
	}
	
	public Array<ReflectPiece> getRefs() {
		return refPieces;
	}
	
	public int getRef() {
		return ref;
	}
	
	// This helper method translates all the pieces in the refPieces array appropriately given the translation for the first piece.
	private void translateWOC_(float x, float y) {
		ReflectPiece p = refPieces.get(0);
		p.get().translate(x, y);
		p = refPieces.get(1);
		if (ref == 1 || ref == 5)
			p.get().translate(x, -y);
		if (ref == 2)
			p.get().translate(-x, y);
		if (ref == 3 || ref == 6)
			p.get().translate(-y, -x);
		if (ref == 4)
			p.get().translate(y, x);
			
		if (ref > 4) {
			p = refPieces.get(2);
			if (ref == 5)
				p.get().translate(-x, y);
			if (ref == 6)
				p.get().translate(y, x);
			
			p = refPieces.get(3);
			if (ref == 5)
				p.get().translate(-x, -y);
			if (ref == 6)
				p.get().translate(-x, -y);
		}
	}
	
	// This calculates the appropriate translation to be applied to the first piece, given a translation on a different piece,
	// and calls the helper method translateWOC_() with this new translation.
	@Override
	public void translateWOC(float x, float y) {
		if (refPieces.get(0) == this) 
			translateWOC_(x, y);
		if (refPieces.get(1) == this) {
			if (ref == 1 || ref == 5)
				translateWOC_(x, -y);
			if (ref == 2)
				translateWOC_(-x, y);
			if (ref == 3 || ref == 6)
				translateWOC_(-y, -x);
			if (ref == 4)
				translateWOC_(y, x);
		}
		if (ref > 4) {
			if (refPieces.get(2) == this) {
				if (ref == 5)
					translateWOC_(-x, y);
				if (ref == 6)
					translateWOC_(y, x);
			}
			if (refPieces.get(3) == this) {
				if (ref == 5)
					translateWOC_(-x, -y);
				if (ref == 6)
					translateWOC_(-x, -y);
			}
		}
	}
	
	// This is a translation that also checks for collisions and undoes the translation if a collision exists, returning
	// true if the translation was successful, and false if there was a collision and the translation was undone.
	@Override
	public boolean translate(float x, float y) {
		translateWOC(x, y);

		boolean f = true;
		iter1 = refPieces.iterator();
		
		while(iter1.hasNext() && f) {
			poly = iter1.next().get();
			if(Intersector.overlapConvexPolygons(poly, LEFT) || Intersector.overlapConvexPolygons(poly, RIGHT) ||
					Intersector.overlapConvexPolygons(poly, TOP) || Intersector.overlapConvexPolygons(poly, BOTTOM))
				f = false;
		}
		
		if (!f) {
			translateWOC(-x, -y);
			return false;
		}
		
		iter1 = refPieces.iterator();
		while (iter1.hasNext() && f) {
			p = iter1.next();
			poly = p.get();
			iter2 = pieces.iterator();
			
			while (iter2.hasNext() && f) {					
				q = (OriginalPiece) iter2.next();
				
				if (p != q && Intersector.overlapConvexPolygons(poly, q.get()))		
					f = false;
			}
		}
		
		if (!f) {
			translateWOC(-x, -y);
			return false;
		}
		return true;
	}
	
	private void superDelete() {
		super.delete();
	}
	
	@Override
	public void delete() {
		iter1 = refPieces.iterator();
		while (iter1.hasNext())
			iter1.next().superDelete();
	}

	protected OriginalPiece getRefPiece(int i) {
		return refPieces.get(i);
	}
	
	protected void srotate(float degrees) {
		super.rotate(degrees);
	}
	
	protected void rotate_(float degrees) {
		//TODO safety net
		assert (refPieces.get(0) == this);
		srotate(degrees);
		if (ref == 1 || ref == 2 || ref == 3 || ref == 4 || ref == 5 || ref == 6)
			refPieces.get(1).srotate(-degrees);
		
		if (ref == 5 || ref == 6) {
			refPieces.get(2).srotate(-degrees);
			refPieces.get(3).srotate(degrees);
		}
	}
	
	@Override
	public void rotate(float degrees) {	
		if (refPieces.get(0) == this) 
			rotate_(degrees);
		else if (refPieces.get(1) == this) 
			refPieces.get(0).rotate_(-degrees);
		else if (refPieces.get(2) == this) {
			if (ref == 5 || ref == 6)
				refPieces.get(0).rotate_(-degrees);
		}
		else if (refPieces.get(3) == this) {
			if (ref == 5 || ref == 6)
				refPieces.get(0).rotate_(degrees);
		}
	}
	
	@Override
	public float getRotation() {
		return refPieces.get(0).get().getRotation();
	}
}


Moving on, we have the PenroseOriPiece class:
	
	This is very much similar to the ClassicPiece class, with a create method, a nullPiece method, and a call to the super constructor.

public abstract class PenroseOriPiece extends PenrosePiece {
	
	public PenroseOriPiece(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		super(polygon, triangles, rot, color, id);
	}
	
	public static PenroseOriPiece nullPiece() {
		return PentagonFactory.create(0);
	}
	
	protected Piece create(int id) {
		if (id < 3)
			return PentagonFactory.create(id);
		else if (id == 3)
			return StarFactory.create(id);
		else if (id == 4)
			return BoatFactory.create(id);
		else 
			return DiamondFactory.create(id);
	}
}


And the PenroseKDPiece class:

	Which again is a very simple class, very similar to ClassicPiece and PenroseOriPiece.

public abstract class PenroseKDPiece extends PenrosePiece {
	
	public PenroseKDPiece(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		super(polygon, triangles, rot, color, id);
	}
	
	public static PenroseKDPiece nullPiece() {
		return KiteFactory.create(0);
	}
	
	protected Piece create(int id) {
		if (id > MozaicPlayer.PenroseID)
			return DartFactory.create(id);
		else 
			return KiteFactory.create(id);
	}
}


And we have the more complicated (since it uses sprites) PenroseRhomb class:
	
	The constructor calls the super constructor, then sets the texture and sets the texture's filter, then creates the 
	sprite and sets the origin, color and coordinates to match that of the representative polygon.
	The secondary constructor takes origins and a sprite also, and sets the origin of the polygon and the new sprite, and
	sets the new sprites coordinates and rotation to that of the old sprites.
	The overlaps method is overridden again, and is in fact identical to the one found in the OriginalPiece abstract class,
	this is because the shapes in PenroseRhomb are both convex, and therefore can be simply represented by a single polygon.
	Because of this, it also overrides the translation and rotation methods, as in the OriginalPiece class.
	Finally it overrides the draw(ShapeRenderer) method with a blank one, since it uses sprites.
	
public abstract class PenroseRhomb extends PenrosePiece {
	
	private Texture texture;
	protected Sprite sprite;
	
	private MinimumTranslationVector mtv;
	private float max;
	
	public PenroseRhomb(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, Texture text) {
		super(polygon, triangles, rot, color, id);
		texture = text;
		texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);
		
		//TODO Does this work?
		float[] coords = polygon.getVertices();
		
		sprite = new Sprite(texture);
		sprite.setOrigin((coords[0] + coords[4])/2 - coords[0], (coords[1] + coords[5])/2 - coords[1]);
		sprite.setColor(1, 1, 1, color.a);
		sprite.setX(coords[0]);
		sprite.setY(coords[1]);
	}
	
	public PenroseRhomb(Polygon polygon, Array<Polygon> triangles, float rot,
			Color color, int id, float oX, float oY, Texture text, Sprite sprite_) {
		super(polygon, triangles, rot, color, id);
		setOrigin(oX, oY);
		
		sprite = new Sprite(text);
		sprite.setOrigin(sprite_.getOriginX(), sprite_.getOriginY());
		sprite.setX(sprite_.getX());
		sprite.setY(sprite_.getY());
		sprite.setRotation(sprite_.getRotation());
		sprite.setColor(1, 1, 1, color.a);
	}
	
	@Override
	protected Piece create(int id) {
		return RhombFactory.create(id);
	}

	public static PenroseRhomb nullPiece() {
		return RhombFactory.create(0);
	}
	
	@Override
	public boolean overlaps() {
		
		Array<MinimumTranslationVector> mtvs = new Array<MinimumTranslationVector>(false, MozaicPlayer.PIECES + 2);
		
		mtv = new MinimumTranslationVector();
		
		Iterator<Piece> iter = getIterator();
		while (iter.hasNext()) {
			q = (PenrosePiece) iter.next();
						
			if (this != q) {
				mtv = new MinimumTranslationVector();
				Intersector.overlapConvexPolygons(polygon, q.get(0), mtv);
				mtvs.add(mtv);
			}
		}
		
		max = 0;
		for (int i = 0; i < mtvs.size; i++) {
			mtv = mtvs.get(i);
			// If we have already checked all values
			if (mtv == null)
				break;
						
			max = Math.max(max, mtv.depth);
		}
		
		// Should 'tighten' this value later
		if (max > 1)
			return true;
		else return false;
	}

	public void draw(SpriteBatch batch) {
		sprite.draw(batch);
	}
	
	@Override
	public boolean translate(float x, float y) {
		polygon.translate(x, y);
		if (overlaps()) {
			polygon.translate(-x, -y);
			return false;
		}
		sprite.translate(x, y);
		return true;
	}
	
	@Override
	public void translateWOC(float x, float y) {
		polygon.translate(x, y);
		sprite.translate(x, y);
	}
	
	@Override
	public void rotate(float degrees) {
		super.rotate(degrees);
		sprite.rotate(degrees);
	}

	@Override
	protected void setRotation(float degrees) {
		super.setRotation(degrees);
		sprite.setRotation(degrees);
	}

	@Override
	public void draw(ShapeRenderer sr) {}
	
	@Override
	public boolean contains(float x, float y) {
		return polygon.contains(x, y);
	}
	
	@Override
	public Polygon get(int i) {
		return polygon;
	}
}


-------------------------------------------------------------------------------------------------------------------------------------

The concrete Piece classes are rather simple, so I will not show all of them.

The Triangle class shows us how the clonef_ method is implemented, as is used by the Piece.clone() method.
Also in the Triangle class, as is required, we have a draw method, since it uses a single polygon for its representation.

public class Triangle extends ClassicPiece {
	private static float ORIGINOFFSET = (float) (MozaicPlayer.scale*100/3);
	
	public Triangle(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		super(polygon, triangles, rot, color, id);
		float [] coords = polygon.getVertices();
		setOrigin(coords[0] + ORIGINOFFSET, coords[1] + ORIGINOFFSET);
	}	
	
	public Triangle(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, float oX, float oY) {
		super(polygon, triangles, rot, color, id);
		setOrigin(oX, oY);
	}

	public void draw(ShapeRenderer sr) {
		float[] coords = getVerts();
		sr.setColor(color);
		sr.filledTriangle(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
	}

	public Piece clonef_(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, float oX, float oY) {
		Piece triangle = new Triangle(polygon, EMPTY, rot, color, id, oX, oY);
		return triangle;
	}
}


The RefRhombus class shows us how the order of id and ref were swapped in the methods for consistency.
Much of the code is the same as it used to be, and is still required because this type of piece needs reflection.

public class RefRhombus extends ReflectPiece {	

	private static float ORIGINOFFSET = (float) (MozaicPlayer.scale*100/Math.sqrt(2)/2);
	private static final float HEIGHT = (float) (MozaicPlayer.scale * (100 / Math.sqrt(2)));
	private static float WIDTH = (float) (MozaicPlayer.scale * 100);
	private static float SLIDE = HEIGHT;

	// Constructor for making an entirely new RefRhombus (i.e. not a reflection)
	public RefRhombus(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, int ref) {
		super(polygon, triangles, rot, color, id, ref);
		float [] coords = polygon.getVertices();
		setOrigin((coords[2] + coords[6]) / 2, coords[1] + ORIGINOFFSET);
	}	
	
	// Constructor for making a reflected RefRhombus, it takes the refPieces from the original RefRhombus as a parameter
	public RefRhombus(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, int ref, Array<ReflectPiece> refPieces) {
		super(polygon, triangles, rot, color, id, ref, refPieces);
		float [] coords = polygon.getVertices();
		setOrigin((coords[2] + coords[6]) / 2, coords[1] + ORIGINOFFSET);
	}
	
	// Called by the first constructor, this creates the required reflections by calling on factory methods
	protected void createReflections() {
		if (ref == 1 || ref == 5)
			RefRhombusFactory.reflect(0, MozaicPlayer.height - MozaicPlayer.trans - HEIGHT, 1, -1, (-rot) % 360, refPieces, color, id, ref);
		
		if (ref == 2 || ref == 5)
			RefRhombusFactory.reflect(MozaicPlayer.width - WIDTH - SLIDE , 0, -1, 1, (-rot) % 360, refPieces, color, id, ref);
		
		if (ref == 3 || ref == 6)
			RefRhombusFactory.reflect(MozaicPlayer.width - WIDTH/2 - SLIDE, MozaicPlayer.height - MozaicPlayer.trans - WIDTH/2 - SLIDE, 1, 1, (-rot + 45) % 360, refPieces, color, id, ref);

		if (ref == 4 || ref == 6)
			RefRhombusFactory.reflect(-WIDTH/2, WIDTH/2, 1, 1, (-rot+45) % 360, refPieces, color, id, ref);
		
		if (ref == 5 || ref == 6)
			RefRhombusFactory.reflect(MozaicPlayer.width - WIDTH - SLIDE, MozaicPlayer.height - MozaicPlayer.trans - HEIGHT, -1, -1, rot, refPieces, color, id, ref);
	}

	// Works as one might expect, note that rhombus.spawn() is called to make all the pieces visible, and how the piece returned
	// depends which piece was cloned, since the RefRhombus is created based on the first piece.
	public OriginalPiece clonef() {
		Color c = color.cpy();
		c.a = 0.5f;
		Polygon p = refPieces.first().get();
		float t = MozaicPlayer.trans;
		RefRhombus rhombus = new RefRhombus(new Polygon(new float[] {0, t, SLIDE, t + HEIGHT, SLIDE + WIDTH, t + HEIGHT, WIDTH, t}), 
									OriginalPiece.EMPTY, getRotation(), c, -1, ref);
		rhombus.translateWOC(p.getX(), p.getY());
		rhombus.spawn();
		
		if (this == refPieces.get(0))
			return rhombus;
		if (this == refPieces.get(1))
			return rhombus.getRefPiece(1);
		if (this == refPieces.get(2))
			return rhombus.getRefPiece(2);
		else return rhombus.getRefPiece(3);
	}
	
	public void draw(ShapeRenderer sr) {
		if (spawned) {
			float[] coords = getVerts();
			sr.setColor(color);
			sr.filledTriangle(coords[0], coords[1], coords[2], coords[3], coords[6], coords[7]);
			sr.filledTriangle(coords[2], coords[3], coords[4], coords[5], coords[6], coords[7]);
		}
	}
}


The Star class is an example of a very basic class, this is all that would currently be required to implement a new shape following standard rules.]
The PenroseKDPiece classes are equally basic.

public class Star extends PenroseOriPiece {
	private static float ORIGINOFFSETX = (float) (MozaicPlayer.scale * 100 * Math.sin(Math.toRadians(54)));
	private static float ORIGINOFFSETY = (float) (MozaicPlayer.scale * 100 * (Math.cos(Math.toRadians(54)) + (Math.cos(Math.toRadians(72))/Math.sin(Math.toRadians(36)))));
	
	public Star(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		super(polygon, triangles, rot, color, id);
		float [] coords = polygon.getVertices();
		setOrigin(coords[0] + ORIGINOFFSETX, coords[1] + ORIGINOFFSETY);
	}
	
	public Star(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, float oX, float oY) {
		super(polygon, triangles, rot, color, id);
		setOrigin(oX, oY);
	}

	public Piece clonef_(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, float oX, float oY) {
		Star star = new Star(polygon, triangles, rot, color, id, oX, oY);
		return star;
	}
}


The Rhomb classes are also very simple, but a little different because of the use of Sprites.

public class RhombLarge extends PenroseRhomb {
	
	private static final Texture texture = new Texture("data/large_rhomb.png");
	
	public RhombLarge(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		super(polygon, triangles, rot, color, id, texture);
		float [] coords = polygon.getVertices();
		setOrigin((coords[0] + coords[4])/2, (coords[1] + coords[5])/2);
	}
	
	private RhombLarge(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, float oX, float oY, Sprite sprite_) {
		super(polygon, triangles, rot, color, id, oX, oY, texture, sprite_);
	}
	
	public Piece clonef_(Polygon polygon, Array<Polygon> triangles, float rot,
			Color color, int id, float oX, float oY) {
		RhombLarge rhomb = new RhombLarge(polygon, triangles, rot, color, id, oX, oY, sprite);
		return rhomb;
	}
}


There have been few changes to the Factory classes, as demonstrated by the StarFactory class:

	The program now defines coordinates making a star shape, creates a polygon using them, creates triangles using them, creates the Star,
	then checks initPieces as before and returns the Star.

public class StarFactory {
	private static final float COS54 = (float) Math.cos(Math.toRadians(54));
	private static final float COS36 = (float) Math.cos(Math.toRadians(36));
	private static final float COS72 = (float) Math.cos(Math.toRadians(72));
	private static final float SIN72 = (float) Math.sin(Math.toRadians(72));
	
	private static final float X1 = (float) (MozaicPlayer.scale * 100 * (COS72 * (2*COS72 + 2)));
	private static final float X2 = (float) (MozaicPlayer.scale * 100 * COS72);
	private static final float X3 = (float) (MozaicPlayer.scale * 100 * (COS36 - COS72));

	private static final float Y1 = (float) (MozaicPlayer.scale * 100 * (SIN72 * (2*COS72 + 2)));
	private static final float Y2 = (float) (MozaicPlayer.scale * 100 * SIN72);
	private static final float Y3 = (float) (MozaicPlayer.scale * 100 * COS54);
	
	private StarFactory() {}
	
	public static Star create(float x, float y, float rot, Color color, int id) {
		float[] coords = new float[] {x, y, x + X1, y + Y3, x + 2*X1, y, x + 2*X1 - X2, y + Y2, x + 2*X1 + X3, y + Y1 - Y2,
										x + X1 + X2, y + Y1 - Y2, x + X1, y + Y1, x + X1 - X2, y + Y1 - Y2, x - X3, y + Y1 - Y2, x + X2, y + Y2};
		Polygon polygon = new Polygon(coords);
		Array<Polygon> triangles = new Array<Polygon>(false, 4);
		
		triangles.add(new Polygon(new float[] {coords[0], coords[1], coords[12], coords[13], coords[6], coords[7]}));
		triangles.add(new Polygon(new float[] {coords[16], coords[17], coords[8], coords[9], coords[2], coords[3]}));
		triangles.add(new Polygon(new float[] {coords[4], coords[5], coords[6], coords[7], coords[2], coords[3]}));
		triangles.add(new Polygon(new float[] {coords[10], coords[11], coords[14], coords[15], coords[18], coords[19]}));

		Star star = new Star(polygon, triangles, rot, color, id);
		if(PenroseOriPiece.initPieces.size == 6)
			PenroseOriPiece.initPieces.removeIndex(id);
		PenroseOriPiece.initPieces.insert(id, star);
		return star;
	}

	public static Star create(int id) {
		return StarFactory.create(MozaicPlayer.width*18/32, MozaicPlayer.trans/2, 0, Color.YELLOW, id);
	}
}


TriangleFactory creates a piece using the OriginalPiece.EMPTY empty Array instead of creating a triangles array, and since
the original puzzles now use the same initPieces/pieces/2-camera representation as the other pieces, we have the initPieces
check and insert as with those other pieces.

public class TriangleFactory {
	private static final float HEIGHT = (float) (MozaicPlayer.scale * 100);
	private static final float WIDTH = HEIGHT;
	
	private TriangleFactory() {}
	
	public static Triangle create(float x, float y, float rot, Color color, int id) {
		Triangle triangle = new Triangle(new Polygon(new float[] {x, y, x + WIDTH, y, x, y + HEIGHT}), OriginalPiece.EMPTY, rot, color, id);
		if(Piece.initPieces.size == 10) 
			Piece.initPieces.removeIndex(id);
		Piece.initPieces.insert(id, triangle);
		return triangle;
	}
	
	public static Triangle create(int id) {
		if (id == 0)
			return TriangleFactory.create(MozaicPlayer.width*3/32, MozaicPlayer.trans/2 - HEIGHT/3, 0, Color.BLUE, id);

		else if(id == 1)
			return TriangleFactory.create(MozaicPlayer.width*10/32, MozaicPlayer.trans/2 - HEIGHT/3, 0, Color.GREEN, id);
		
		else if (id == 2)
			return TriangleFactory.create(MozaicPlayer.width*3/32, (MozaicPlayer.trans/2 - HEIGHT/3)/3, 0, Color.YELLOW, id);

		else if(id == 3)
			return TriangleFactory.create(MozaicPlayer.width*10/32, (MozaicPlayer.trans/2 - HEIGHT/3)/3, 0, Color.RED, id);
		
		else if (id == 4)
			return TriangleFactory.create(MozaicPlayer.width*3/32, MozaicPlayer.trans/2 - HEIGHT/3 + 2*(MozaicPlayer.trans/2 - HEIGHT/3)/3, 0, Color.CYAN, id);

		else
			return TriangleFactory.create(MozaicPlayer.width*10/32, MozaicPlayer.trans/2 - HEIGHT/3 + 2*(MozaicPlayer.trans/2 - HEIGHT/3)/3, 0, Color.MAGENTA, id);
	}
}


The ReflectPiece Factory methods also had the order of some parameters changed to match the changes to the ReflectPieces and improve consistency.
	

-------------------------------------------------------------------------------------------------------------------------------------


In MozaicPlayer, there were a couple of changes:

		The calls to the load static methods now are simply to either PenrosePiece or OriginalPiece, and also pass a 'nullPiece' along with the
		Array of SavePieces, which allows the call to the correct create methods.
		Also the reset method now calls Piece.reset rather than going through a chain of else ifs as loadPieces does.

	private void loadPieces(Array<SavePiece> pieces) {
		if (gameMode == GameMode.PenroseKD) {
			PenrosePiece.load(pieces, PenroseKDPiece.nullPiece());
		}
		else if (gameMode == GameMode.PenroseOri) {
			PenrosePiece.load(pieces, PenroseOriPiece.nullPiece());
		}
		else if (gameMode == GameMode.PenroseRhomb) {
			PenrosePiece.load(pieces, PenroseRhomb.nullPiece());
		}
		else if (gameMode == GameMode.Classic) {
			OriginalPiece.load(pieces, ClassicPiece.nullPiece());
		}
		else if (gameMode == GameMode.Reflect) {
			OriginalPiece.load(pieces, ReflectPiece.nullPiece());
		}
	}
	
	public void reset() {
		started = false;
		FileHandle saveFile = Gdx.files.local("data/save_file.txt");
		saveFile.writeString("", false);
		Piece.reset();
	}


There is no longer a ZoomingWorldRenderer, instead we have an abstract WorldRenderer, used by general puzzles, which is extended by
StaticWorldRenderer for the original puzzles, and SpriteWorldRenderer for those puzzles drawn using sprites instead of triangles.
The Screen classes have been changed to match these changes, e.g.

public class ClassicGameScreen extends GameScreen {
	
	public ClassicGameScreen(MozaicPlayer game){	
		super(game);
		render = new StaticWorldRenderer(world);
	}

	@Override
	protected World createWorld(MozaicPlayer game) {
		SnapTo.setMode(MozaicPlayer.GameMode.Classic);
		return new ClassicWorld(game);
	}
}


The implementation of the WorldRenderer is a mixture of the old WorldRenderer and the old ZoomingWorldRenderer, although the methods getIterator,
getInitIterator and getClone now simply call the method of the same name from the Piece class, instead of using else if statements.

public class WorldRenderer {
	
	World world;
	SpriteBatch batch;
	OrthographicCamera cam, camO;
	float width, height;
	ShapeRenderer sr;
	Iterator<Piece> iter;
	Polygon p, q;
	MinimumTranslationVector mtv = new Intersector.MinimumTranslationVector();
	Piece clone;
	
	public WorldRenderer(World world) {
		this.world = world;
		
		world.setRenderer(this);
		
		width = Gdx.graphics.getWidth();
		height = Gdx.graphics.getHeight();
		
		cam = new OrthographicCamera();
		cam.setToOrtho(false, width, height);		
		cam.update();
		
		camO = new OrthographicCamera();
		camO.setToOrtho(false, width, height);
		camO.update();

		batch = new SpriteBatch();
		batch.setProjectionMatrix(cam.combined);
		
		sr = new ShapeRenderer();
	}
	
	public void render() {
		Gdx.gl.glClearColor(1, 1, 1, 1);
		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
		
		Gdx.gl.glEnable(GL10.GL_BLEND);
		Gdx.gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
		
		iter = getIterator();
		
		sr.setProjectionMatrix(cam.combined);
		// Gdx.gl.glEnable(GL10.GL_BLEND);
		  //  Gdx.gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
		
		sr.begin(ShapeType.FilledTriangle);
		while (iter.hasNext()) {
			Piece next = iter.next();
			if (next == getClone())
				clone = next;
			else
				next.draw(sr);
		}
		sr.end();
		
		sr.setProjectionMatrix(camO.combined);
		sr.begin(ShapeType.FilledRectangle);
		sr.setColor(Color.BLACK);
		sr.filledRect(0, 0, MozaicPlayer.size, MozaicPlayer.trans);
		sr.end();   

		sr.begin(ShapeType.FilledTriangle);
		iter = getInitIterator();
		while (iter.hasNext()) {
			iter.next().draw(sr);
		}
		sr.end();
		
		if (clone != null) {
			sr.setProjectionMatrix(cam.combined);
			sr.begin(ShapeType.FilledTriangle);
			clone.draw(sr);
			clone = null;
			sr.end();
		}
	    Gdx.gl.glDisable(GL10.GL_BLEND);
	}
	
	protected Iterator<Piece> getIterator() {
		return Piece.getIterator();
	}
	
	protected Iterator<Piece> getInitIterator() {
		return Piece.getInitIterator();
	}
	
	protected Piece getClone() {
		return Piece.getClone();
	}

	public OrthographicCamera getCamera() {
		return cam;
	}
	
	public OrthographicCamera getCameraO() {
		return camO;
	}
	
	public void dispose(){
		batch.dispose();
	}

	public void zoom(int amount) {
		cam.zoom += (float) amount/10;
		cam.update();
	}
	
	public void scroll(float x, float y) {
		cam.translate(-x/2, -y/2);
		cam.update();
	}
}


The StaticWorldRenderer simply overrides the zoom and scroll methods, so that both cameras are fixed (and identical).

public class StaticWorldRenderer extends WorldRenderer {
	
	public StaticWorldRenderer(World world) {
		super(world);
	}

	@Override
	public void zoom(int amount) {
	}
	
	@Override
	public void scroll(float x, float y) {
	}
}


The SpriteWorldRenderer overrides the render() method with the code previously used in an if statement of ZoomingWorldRenderer, which
required the gameMode be PenroseRhomb.

public class SpriteWorldRenderer extends WorldRenderer {
	
	public SpriteWorldRenderer(World world) {
		super(world);
	}
	
	@Override
	public void render() {
		Gdx.gl.glClearColor(1, 1, 1, 1);
		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
		
		Gdx.gl.glEnable(GL10.GL_BLEND);
		Gdx.gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
		
		batch.setProjectionMatrix(cam.combined);
		batch.begin();
		iter = getIterator();
		while (iter.hasNext()) {
			PenroseRhomb next = (PenroseRhomb) iter.next();
			if (next == getClone())
				clone = next;
			else
				next.draw(batch);
		}
		batch.end();
		
		sr.setProjectionMatrix(camO.combined);
		sr.begin(ShapeType.FilledRectangle);
		sr.setColor(Color.BLACK);
		sr.filledRect(0, 0, MozaicPlayer.size, MozaicPlayer.trans);
		sr.end(); 
		
		batch.setProjectionMatrix(camO.combined);
		batch.begin();
		iter = getInitIterator();
		while (iter.hasNext()) {
			((PenroseRhomb) iter.next()).draw(batch);
		}
		batch.end();
		
		if (clone != null) {
			batch.setProjectionMatrix(cam.combined);
			batch.begin();
			((PenroseRhomb) clone).draw(batch);
			clone = null;
			batch.end();
		}
	}
}
			
			
			
----- 11.02.14 -----

-------------- ELIMINATING FAR AWAY SHAPES --------------	

Improve SnapTo by eliminating shapes that are obviously too far away, e.g. take a sample vertex and ignore if far enough away.
Overlaps should ignore pieces clearly too far away, just as SnapTo should.

Firstly did rough calculation of what the maximum distance between two vertices might be, assuming a star/pentagon meeting, my estimation was around 356.9,
since this is an overestimation, I used 356 in the calculation for dMax:		100 * cos(18) + 200 + 100 * sin(18)
	
	private static float dMax = MozaicPlayer.scale*356;

	
Here is an example of how I used this value for snapping:	

		if (GAMEMODE == GameMode.PenroseRhomb) {
			d = MozaicPlayer.size/20;
			
			PenroseRhomb u;
			boolean id0 = (dragging.getID() == 0);
			float[] us, vs = dragging.getVerts();
			Vector2 v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2(), u0 = new Vector2(), u1 = new Vector2(), u2 = new Vector2(), u3 = new Vector2();
			v0.x = vs[0]; v0.y = vs[1];
			v1.x = vs[2]; v1.y = vs[3];
			v2.x = vs[4]; v2.y = vs[5];
			v3.x = vs[6]; v3.y = vs[7];
					
			while (!snapped.l && pieces.hasNext()) {
				u = (PenroseRhomb) pieces.next();
				if (u != dragging) {
					us = u.getVerts();
					u0.x = us[0]; u0.y = us[1];
					if (v0.dst(u0) < dMax + d) {
						u1.x = us[2]; u1.y = us[3];
						u2.x = us[4]; u2.y = us[5];
						u3.x = us[6]; u3.y = us[7];
						
						if (id0) {
							if (u.getID() == 0)
								snapped.l = snapR11(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
							else
								snapped.l = snapR12(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
						}
						else {
							if (u.getID() == 0)
								snapped.l = snapR21(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
							else
								snapped.l = snapR22(v0, v1, v2, v3, u0, u1, u2, u3, dragging);
						}
					}
				}
			}
			return snapped;
		}


And here is the Piece overlapping method, using the value 400 + 400 * sin(18) ~ 523.6 instead:

	public boolean overlaps() {
		Piece q;
		float max;
		MinimumTranslationVector mtv;
		
		Array<MinimumTranslationVector> mtvs = new Array<MinimumTranslationVector>(false, 9*MozaicPlayer.PIECES); //TODO choose value
		
		Iterator<Piece> iter = getIterator();
		while (iter.hasNext()) {
			q = iter.next();
			if (this != q && new Vector2(q.get(0).getTransformedVertices()[0], q.get(0).getTransformedVertices()[1]).dst
					(polygon.getTransformedVertices()[0], polygon.getTransformedVertices()[1]) < dMax) {
				for (int i = 0; i < size; i++) {
					for (int j = 0; j < q.getSize(); j++) {
						mtv = new MinimumTranslationVector();
						Intersector.overlapConvexPolygons(get(i), q.get(j), mtv);
						mtvs.add(mtv);
					}
				}
			}
		}
		
		max = 0;
		for (int i = 0; i < mtvs.size; i++) {
			mtv = mtvs.get(i);
			// If we have already checked all values
			if (mtv == null)
				break;
						
			max = Math.max(max, mtv.depth);
		}
		
		// Should 'tighten' this value later
		if (max > 1)
			return true;
		else return false;
	}
	
	
I also edited the if statements in OriginalPiece and PenroseKDPiece, they are the same as the one used here.
			


----- 13.02.14 -----

-------------- SNAP CHANGES --------------	

Parameterise snapping and move to Piece class.

This has not yet been tested, but should work in theory. Also the data structure is not a final decision.

public boolean snap(int[][] matches) {
		Tuple<Boolean, Vector2> snapped = new Tuple<Boolean, Vector2>(false, new Vector2(0, 0));
		Array<Vector2> vs = new Array<Vector2>(false, size);
		Array<Vector2> us = new Array<Vector2>(false, size);
		Vector2 v, v0, u0, v1, v2, u1, u2;
		float[] verts = getVerts();
		Iterator<Piece> pieces = getIterator();
		Piece u;
		int uSize;
		int[] uMatches;
		float d = MozaicPlayer.size/20;
		
		for (int i = 0; i < 2*size; i += 2) {
			v = new Vector2(verts[i], verts[i+1]);
			vs.add(v);
		}
		
		v0 = vs.first();
		
		while (!snapped.l && pieces.hasNext()) {
			u = pieces.next();
			if (u != this) {
				uSize = u.getSize();
				uMatches = matches[u.getID()];
				
				for (int i = 0; i < 2*uSize; i += 2) {
					v = new Vector2(verts[i], verts[i+1]);
					us.add(v);
				}
				
				u0 = us.first();
				
				// Small optimisation
				if (v0.dst(u0) > dMaxSnap) {
					for (int i = 0; i < uMatches.length; i++) {
						v1 = vs.get(uMatches[i++]);
						v2 = vs.get(uMatches[i++]);
						u1 = us.get(uMatches[i++]);
						u2 = us.get(uMatches[i]);
						if (v1.dst(u1) < d && v2.dst(u2) < d) {
							fix(v1, v2, u1, u2);
							return true;
						}
					}
				}
			}
		}
		
		return false;
	}			



----- 15.02.14 -----

-------------- REMOVE CLASSIC COUNT LIMITATION --------------	

One could argue that the only reason the pieces were limited in the original puzzle was because having excess pieces
would be rather pointless and induce an extra cost. However with a virtual puzzle, it actually saves cost to not limit the number
of each piece allowed to be used in a puzzle.

I simply removed the relevant code from the InputHandler.


-------------- BUGFIX --------------

Every time a game is 'esc'ed from and resumed, another set of initial pieces is created.

One key change was required in the implementation of the main menu, I swapped the order of the call to game.play and the assignment of the boolean
started to true. This is because play() creates a GameScreen, which creates a World, which is responsible for creating the initial pieces.

		playButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				game.play();
				MozaicPlayer.started = true;
			}
		});


Then all we need to do is to encapsulate the creation of the initial pieces in the World classes in an if statement, as follows:

	public PenroseOriWorld(MozaicPlayer game) {
		super(game);
		if (!MozaicPlayer.started) {
			PentagonFactory.create(0);
			PentagonFactory.create(1);
			PentagonFactory.create(2);
			StarFactory.create(3);
			BoatFactory.create(4);
			DiamondFactory.create(5);
		}
	}
	

-------------- BUGFIX --------------
	
Now upon loading the initial pieces are not created.
	
The previous bugfix created another issue, which was fixed by adding a separate boolean variable to manage creation of pieces:
	
		playButton.addListener(new InputListener(){
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			
			public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
				MozaicPlayer.started = true;
				game.play();
				MozaicPlayer.initiated = true;
			}
		});
				
	
	
	public PenroseOriWorld(MozaicPlayer game) {
		super(game);
		if (!MozaicPlayer.initiated) {
			PentagonFactory.create(0);
			PentagonFactory.create(1);
			PentagonFactory.create(2);
			StarFactory.create(3);
			BoatFactory.create(4);
			DiamondFactory.create(5);
		}
	}
	
	public void reset() {
		started = false;
		initiated = false;
		FileHandle saveFile = Gdx.files.local("data/save_file.txt");
		saveFile.writeString("", false);
		Piece.reset();
	}





----- ?-27.02.14 -----

-------------- OVERHAUL --------------

Each puzzle has an instance of a Puzzle class with static behaviours of Piece class, that also performs snapping. It also takes the place of the
World class. So far, there exists the 'generic' puzzle class, a puzzle class for the original game, a puzzle class for the reflection game, and a
puzzle class for the new 'pixel' puzzle. These all extend the generic puzzle class, apart from the reflect puzzle class, which extends the original
puzzle class (and therefore also the generic puzzle class).

For each piece available in a puzzle, there is an instance of a PuzzlePiece class, containing the information required to create the pieces,
effectively taking the place of the Factory classes. So far, there is the generic PuzzlePiece class, along with a ReflectPuzzlePiece class, 
which extends the PuzzlePiece class.

The model now consists of three classes, Piece, OriginalPiece and ReflectPiece. All are concrete, and they inherit in the previous, obvious order.

The GameScreen is now responsible for linking the puzzle with the InputHandler, as was previously the World's job. There is the generic GameScreen,
along with a ColourGameScreen (pixel puzzle) and an OriginalGameScreen, both of which extend GameScreen in order to set up the puzzle with the 
correct type of WorldRenderer.

There are now four kinds of renderer, the generic WorldRenderer, the StaticWorldRenderer and SpriteWorldRenderer as before, and a new ReflectWorldRenderer,
this new class extends the StaticWorldRenderer and only differs in behaviour because it checks that pieces are spawned.

All that remains to be done is to fix the translation method in ReflectPiece, and to sort out the underMouse methods and make sure all the correct classes
are connected.








ReflectPuzzle snapping methods:

	@Override
	public boolean snap(Piece piece2) {
		
		ReflectPiece piece = ((ReflectPiece) piece2).getRefs().first();
		
		int shape = 0;
		if (piece.getID() > 5)
			shape = 1;
		float[] verts = piece.getVerts();
		int size = verts.length;
	// Snap to pieces which are not reflections of this piece first, this is required for snapping 4 (2 non-ref) pieces together
		Iterator<ReflectPiece> pieces = getNonRefIterator(piece);
		float d1, d2;
		
		Array<Vector2> vs = new Array<Vector2>(false, size/2);
		Array<Vector2> us;
		Vector2 v, v0, u0, v1, v2, u1, u2;

		ReflectPiece u;
		int uSize;
		int uShape;
		int[] uMatches;
		float d = MozaicPlayer.size/20;
		
		for (int i = 0; i < size; i ++) {
			v = new Vector2(verts[i++], verts[i]);
			vs.add(v);
		}
		
		v0 = vs.first();
		
		for (Vector2 corner : corners) {
			if (v0.dst(corner) < dMaxSnap) {
				for (Vector2 v_ : vs) {
					if (v_.dst(corner) < d) {
						piece.translateWOC(corner.x - v_.x, corner.y - v_.y);
						return true;
					}
				}
			}
		}
		
		while (pieces.hasNext()) {
			u = pieces.next();
			verts = u.getVerts();
			uSize = verts.length;
			uShape = 0;
			if (u.getID() > 5)
				uShape = 1;

			us = new Array<Vector2>(false, uSize);
			uMatches = matches[shape][uShape];
			
			for (int i = 0; i < uSize; i++) {
				v = new Vector2(verts[i++], verts[i]);
				us.add(v);
			}
			
			u0 = us.first();
			
			// Small optimisation
			if (v0.dst(u0) < dMaxSnap) {
				for (int i = 0; i < uMatches.length; i++) {
					v1 = vs.get(uMatches[i++]);
					v2 = vs.get(uMatches[i++]);
					u1 = us.get(uMatches[i++]);
					u2 = us.get(uMatches[i]);
					d1 = v1.dst(u1);
					d2 = v2.dst(u2);
					if (d1 < d && d2 < d) {
						piece.fix(v1, v2, u1, u2);
						if (piece.getRef() > 4) {
							snap4(piece, u, uMatches);
						}
						return true;
					}
				}
			}
		}
		
	// Snapping to reflections, we already know the shape and only want half the translation
		Array<ReflectPiece> refs = piece.getRefs();
		pieces = refs.iterator();
		while (pieces.hasNext()) {
			u = pieces.next();
			if (u != piece) {
				verts = u.getVerts();

				us = new Array<Vector2>(false, size);
				uMatches = matches[shape][shape];
				
				for (int i = 0; i < size; i++) {
					v = new Vector2(verts[i++], verts[i]);
					us.add(v);
				}
				
				u0 = us.first();
				
				// Small optimisation
				if (v0.dst(u0) < dMaxSnap) {
					for (int i = 0; i < uMatches.length; i++) {
						v1 = vs.get(uMatches[i++]);
						v2 = vs.get(uMatches[i++]);
						u1 = us.get(uMatches[i++]);
						u2 = us.get(uMatches[i]);
						d1 = v1.dst(u1);
						d2 = v2.dst(u2);
						if (d1 < d && d2 < d) {
						// The translation is halved
							piece.fixHalf(v1, v2, u1, u2);
						// If possibility of 4 snapping together, call snap4
							if (piece.getRef() > 4) {
								snap4(piece, u, uMatches);
							}
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	
// Effectively performs another snap if required because 4 pieces are close enough together
	private void snap4(ReflectPiece piece, ReflectPiece q, int[] uMatches) {
		ReflectPiece u = null;
		Iterator<ReflectPiece> iter = piece.getRefs().iterator();
		
		while (iter.hasNext()) {
			u = iter.next();
			if (u != q && u != piece)
				break;
		}

		Vector2 v, v1, v2, u1, u2;
		float d1, d2, d = MozaicPlayer.size/20;
		float[] verts = piece.getVerts();
		int size = verts.length;
		
	// Need to recalculate vertices of piece
		Array<Vector2> vs = new Array<Vector2>(false, size/2);
		Array<Vector2> us = new Array<Vector2>(false, size/2);
		
		for (int i = 0; i < verts.length; i++) {
			v = new Vector2(verts[i++], verts[i]);
			vs.add(v);
		}
		
		verts = u.getVerts();
		
		for (int i = 0; i < verts.length; i++) {
			v = new Vector2(verts[i++], verts[i]);
			us.add(v);
		}
		
		for (int i = 0; i < uMatches.length; i++) {
			v1 = vs.get(uMatches[i++]);
			v2 = vs.get(uMatches[i++]);
			u1 = us.get(uMatches[i++]);
			u2 = us.get(uMatches[i]);
			d1 = v1.dst(u1);
			d2 = v2.dst(u2);
			if (d1 < d && d2 < d)
				piece.fixHalf(v1, v2, u1, u2);
		}
	}

// Required for snapping 4 (2 non-ref) pieces together
	public Iterator<ReflectPiece> getNonRefIterator(ReflectPiece piece) {
		Array<ReflectPiece> temp = new Array<ReflectPiece>(false, pieces.size);
		for(Piece p : pieces) {
			temp.add(((ReflectPiece) p));
		}
		temp.removeAll(piece.getRefs(), true);
		return temp.iterator();	
	}




ReflectPiece methods:

Most of the methods are the same as the old ones, or have very minor changes only.

// Works as one might expect, note that piece.spawn() is called to make all the pieces visible, and which piece 
// is returned depends which piece was cloned, since the ReflectPiece is created based on the first piece.
	public Piece clonef() {
		Color c = color.cpy();
		c.a = 0.5f;
		
		ReflectPiece piece = ((ReflectPuzzle) puzzle).clone(refPieces.first());
		
		piece.spawn();
		
		if (this == refPieces.get(0))
			return piece;
		if (this == refPieces.get(1))
			return piece.getRefPiece(1);
		if (this == refPieces.get(2))
			return piece.getRefPiece(2);
		else return piece.getRefPiece(3);
	}

	public void fixHalf(Vector2 v0, Vector2 v1, Vector2 u0, Vector2 u1) {
		translateWOC((u0.x - v0.x)/2, (u0.y - v0.y)/2);
	}




The ReflectPuzzlePiece class is fairly complex, since it takes the place of the old Factories it is responsible for creating reflections
and for a large part of the cloning method. It also overrides the underMouse methods to check that the piece is spawned.

public class ReflectPuzzlePiece extends PuzzlePiece {

	int ref;
	float x;
	float y;
	float offX;
	float offY;
	
	public ReflectPuzzlePiece(Puzzle puzzle, float oX, float oY, float[] coords, int noTriangles, int[] triangles, Color color, int id, int ref, float offX, float offY) {
		super(puzzle, oX, oY, coords, noTriangles, triangles, color, id);
		this.ref = ref;
		this.coords = coords;
		for (int i = 1; i < coords.length; i+=2) {
			this.coords[i] = coords[i] + MozaicPlayer.trans;
		}
		x = this.oX;
		y = this.oY - MozaicPlayer.trans;
		
		this.offX = offX;
		this.offY = offY;
	}

	public ReflectPiece create() {
		Polygon temp;
		Polygon polygon;
		Array<Polygon> tris = new Array<Polygon> (false, noTriangles);
		
		polygon = new Polygon(coords);
		for (int i = 0; i < noTriangles; i++) {
			temp = new Polygon(new float[] {coords[triangles[3*i]*2], coords[triangles[3*i]*2 + 1], coords[triangles[3*i + 1]*2], coords[triangles[3*i + 1]*2 + 1],
													coords[triangles[3*i + 2]*2], coords[triangles[3*i + 2]*2 + 1]});
			tris.add(temp);
		}
		
		Array<ReflectPiece> refPieces = new Array<ReflectPiece>(false, 4);
		ReflectPiece piece =  new ReflectPiece(puzzle, polygon, tris, 0, color, id, 0, MozaicPlayer.trans, ref, refPieces);
		
		createReflections(refPieces);
		piece.translateWOC(x, y);
		
		piece.spawn_();
		return piece;
	}
	
	private void createReflections(Array<ReflectPiece> refPieces) {
		if (id < 6) {
			if (ref == 1 || ref == 5)
				reflect(0, MozaicPlayer.height - MozaicPlayer.trans, 1, -1, refPieces);
			
			if (ref == 2 || ref == 5)
				reflect(MozaicPlayer.width, 0, -1, 1, refPieces);
			
			if (ref == 3 || ref == 6)
				reflect(MozaicPlayer.width, MozaicPlayer.height - MozaicPlayer.trans, -1, -1, refPieces);
	
			if (ref == 4 || ref == 6)
				reflect(0, 0, 1, 1, refPieces);
			
			if (ref == 5 || ref == 6)
				reflect(MozaicPlayer.width, MozaicPlayer.height - MozaicPlayer.trans, -1, -1, refPieces);
		}
		else {
			if (ref == 1 || ref == 5)
				reflect(0, MozaicPlayer.height - MozaicPlayer.trans, 1, -1, refPieces);
			
			if (ref == 2 || ref == 5)
				reflect(MozaicPlayer.width, 0, -1, 1, refPieces);
			
			if (ref == 3 || ref == 6)
				reflect(MozaicPlayer.width, MozaicPlayer.height - MozaicPlayer.trans, 1, 1, refPieces).srotate(45);

			if (ref == 4 || ref == 6)
				reflect(0, 0, 1, 1, refPieces).srotate(45);
			
			if (ref == 5 || ref == 6)
				reflect(MozaicPlayer.width, MozaicPlayer.height - MozaicPlayer.trans, -1, -1, refPieces);
		}
	}
	
	private ReflectPiece reflect(float transX, float transY, float scaleX, float scaleY, Array<ReflectPiece> refPieces) {
		Polygon temp;
		Polygon polygon;
		Array<Polygon> tris = new Array<Polygon> (false, noTriangles);
		
		polygon = new Polygon(coords);
		for (int i = 0; i < noTriangles; i++) {
			temp = new Polygon(new float[] {coords[triangles[3*i]*2], coords[triangles[3*i]*2 + 1], coords[triangles[3*i + 1]*2], coords[triangles[3*i + 1]*2 + 1],
													coords[triangles[3*i + 2]*2], coords[triangles[3*i + 2]*2 + 1]});
			tris.add(temp);
		}
		
		polygon.setScale(scaleX, scaleY);
		polygon.translate(transX, transY);
		
		for (Polygon tri : tris) {
			tri.setScale(scaleX, scaleY);
			tri.translate(transX, transY);
		}
		
		return new ReflectPiece(puzzle, polygon, tris, 0, color, id, 0, MozaicPlayer.trans, ref, refPieces);
	}
	
	public ReflectPiece createClone(ReflectPiece piece) {
		ReflectPiece clone = create_();
		
		float rot = piece.getRotation();
		piece.rotate(-rot);

		float[] verts = piece.getVerts();
		clone.translateWOC(verts[0] + offX, verts[1] - MozaicPlayer.trans + offY);
		
		piece.rotate(rot);
		clone.rotate(rot);
		return clone;
	}
	
	public ReflectPiece create_() {
		Polygon temp;
		Polygon polygon;
		Array<Polygon> tris = new Array<Polygon> (false, noTriangles);
		
		polygon = new Polygon(coords);
		for (int i = 0; i < noTriangles; i++) {
			temp = new Polygon(new float[] {coords[triangles[3*i]*2], coords[triangles[3*i]*2 + 1], coords[triangles[3*i + 1]*2], coords[triangles[3*i + 1]*2 + 1],
													coords[triangles[3*i + 2]*2], coords[triangles[3*i + 2]*2 + 1]});
			tris.add(temp);
		}
		
		Color c = color;
		color = color.tmp();
		color.a = 0.5f;

		Array<ReflectPiece> refPieces = new Array<ReflectPiece>(false, 4);
		ReflectPiece piece =  new ReflectPiece(puzzle, polygon, tris, 0, color, id, 0, MozaicPlayer.trans, ref, refPieces);
		createReflections(refPieces);
		color = c;
		
		return piece;
	}
	
	@Override
	public Piece underMouseInit(float x, float y) {
		Iterator<Piece> iter = getInitIterator();
		ReflectPiece p;
		
		while (iter.hasNext()) {
			p = (ReflectPiece) iter.next();
			if (p.isSpawned() && p.contains(x, y)) {
				return p;
			}
		}
		return null;
	}

	@Override
	public Piece underMouse(float x, float y) {
		Iterator<Piece> iter = getIterator();
		ReflectPiece p;
		
		while (iter.hasNext()) {
			p = (ReflectPiece) iter.next();
			if (p.isSpawned() && p.contains(x, y)) {
				return p;
			}
		}
		return null;
	}
}




Overrides create because we need to call a different method in PuzzlePiece which returns an OriginalPiece rather than a Piece.
Overrides overlaps to stop the pieces overlapping the edge of the screen. Overrides snap to allow the pieces to snap to the
corners of the screen, as well as to simplify the definition of the matches array, since there are ten different pieces
but only two different shapes.

public class OriginalPuzzle extends Puzzle {
	
	private static final Vector2 bl = new Vector2(0, MozaicPlayer.trans);
	private static final Vector2 tl = new Vector2(0, MozaicPlayer.height);
	private static final Vector2 tr = new Vector2(MozaicPlayer.size, MozaicPlayer.height);
	private static final Vector2 br = new Vector2(MozaicPlayer.size, MozaicPlayer.trans);
	protected static final Vector2[] corners = {bl, tl, tr, br};

	private static final int bottom1 = MozaicPlayer.trans;
	private static final int bottom2 = -100;
	private static final int left1 = 0;
	private static final int left2 = -100;
	private static final int right1 = MozaicPlayer.size;
	private static final int right2 = right1 + 100;
	private static final int top1 = MozaicPlayer.height;
	private static final int top2 = top1 + 100;
	
	protected static final Polygon LEFT = new Polygon(new float[] {left1, bottom2, left1, top2, left2, top2, left2, bottom2} );
	protected static final Polygon RIGHT = new Polygon(new float[] {right1, bottom2, right1, top2, right2, top2, right2, bottom2} );
	protected static final Polygon TOP = new Polygon(new float[] {left2, top1, right2, top1, right2, top2, left2, top2} );
	protected static final Polygon BOTTOM = new Polygon(new float[] {left2, bottom1, right2, bottom1, right2, bottom2, left2, bottom2} );
	
	public OriginalPuzzle(int noPieces, Array<PuzzlePiece> puzzlePieces, int[][][] matches) {
		super(noPieces, puzzlePieces, matches);
	}

	@Override
	public Piece create(int id) {
		Piece p = puzzlePieces.get(id).createOri();
		if (initPieces.size == noPieces)
			initPieces.removeIndex(id);
		initPieces.insert(id, p);
		return p;
	}
	
	@Override
	public boolean snap(Piece piece) {
		int shape = 0;
		if (piece.getID() > 5)
			shape = 1;
		float[] verts = piece.getVerts();
		int size = verts.length;
		Iterator<Piece> pieces = getIterator();
		float d1, d2;
		
		Array<Vector2> vs = new Array<Vector2>(false, size/2);
		Array<Vector2> us;
		Vector2 v, v0, u0, v1, v2, u1, u2;

		Piece u;
		int uSize;
		int uShape;
		int[] uMatches;
		float d = MozaicPlayer.size/20;
		
		for (int i = 0; i < size; i ++) {
			v = new Vector2(verts[i++], verts[i]);
			vs.add(v);
		}
		
		v0 = vs.first();
		
		for (Vector2 corner : corners) {
			if (v0.dst(corner) < dMaxSnap) {
				for (Vector2 v_ : vs) {
					if (v_.dst(corner) < d) {
						piece.translateWOC(corner.x - v_.x, corner.y - v_.y);
						return true;
					}
				}
			}
		}
		
		while (pieces.hasNext()) {
			u = pieces.next();
			if (u != piece) {
				verts = u.getVerts();
				uSize = verts.length;
				uShape = 0;
				if (u.getID() > 5)
					uShape = 1;
				us = new Array<Vector2>(false, uSize);
				uMatches = matches[shape][uShape];
				
				for (int i = 0; i < uSize; i++) {
					v = new Vector2(verts[i++], verts[i]);
					us.add(v);
				}
				
				u0 = us.first();
				
				if (v0.dst(u0) < dMaxSnap) {
					for (int i = 0; i < uMatches.length; i++) {
						v1 = vs.get(uMatches[i++]);
						v2 = vs.get(uMatches[i++]);
						u1 = us.get(uMatches[i++]);
						u2 = us.get(uMatches[i]);
						d1 = v1.dst(u1);
						d2 = v2.dst(u2);
						if (d1 < d && d2 < d) {
							piece.fix(v1, v2, u1, u2);
							return true;
						}
					}
				}
			}
		}
		return false;
	}
	
	@Override
	public boolean overlaps(Piece piece) {
		MinimumTranslationVector mtv;
		Array<MinimumTranslationVector> mtvs = new Array<MinimumTranslationVector>(false, MozaicPlayer.PIECES + 4);
		
		OriginalPiece oPiece = ((OriginalPiece) piece);
		
		mtv = new MinimumTranslationVector();
		Intersector.overlapConvexPolygons(oPiece.get(), LEFT, mtv);
		mtvs.add(mtv);
		mtv = new MinimumTranslationVector();
		Intersector.overlapConvexPolygons(oPiece.get(), RIGHT, mtv);
		mtvs.add(mtv);
		mtv = new MinimumTranslationVector();		
		Intersector.overlapConvexPolygons(oPiece.get(), TOP, mtv);
		mtvs.add(mtv);
		mtv = new MinimumTranslationVector();		
		Intersector.overlapConvexPolygons(oPiece.get(), BOTTOM, mtv);
		mtvs.add(mtv);
		
		float max = 0;
		for (int i = 0; i < mtvs.size; i++) {
			mtv = mtvs.get(i);
			if (mtv == null)
				break;
						
			max = Math.max(max, mtv.depth);
		}
		
		if (max > 1)
			return true;
		else return super.overlaps(piece);
	}
}






Here is the PuzzlePiece class:

An instance stores the information required to create pieces of a specific kind, and can then create those pieces.

public class PuzzlePiece {

	Puzzle puzzle;
	
	float oX;
	float oY;
	float[] coords;
	int noTriangles;
	int[] triangles;
	Color color;
	int id;
	
	public PuzzlePiece(Puzzle puzzle, float oX, float oY, float[] coords, int noTriangles, int[] triangles, Color color, int id) {
		this.puzzle = puzzle;
		this.oX = oX*MozaicPlayer.width;
		this.oY = oY*MozaicPlayer.trans;
		this.coords = new float[coords.length];
		for (int i = 0; i < coords.length; i++) {
			this.coords[i] = coords[i++] + this.oX;
			this.coords[i] = coords[i] + this.oY;
		}
		this.noTriangles = noTriangles;
		this.triangles = triangles;
		this.color = color;
		this.id = id;
	}
	
	public Piece create() {
		Polygon temp;
		Polygon polygon;
		Array<Polygon> tris = new Array<Polygon> (false, noTriangles);
		
		polygon = new Polygon(coords);
		for (int i = 0; i < noTriangles; i++) {
			temp = new Polygon(new float[] {coords[triangles[3*i]*2], coords[triangles[3*i]*2 + 1], coords[triangles[3*i + 1]*2], coords[triangles[3*i + 1]*2 + 1],
													coords[triangles[3*i + 2]*2], coords[triangles[3*i + 2]*2 + 1]});
			tris.add(temp);
		}
		return new Piece(puzzle, polygon, tris, 0, color, id, oX, oY);
	}
	
	public OriginalPiece createOri() {
		Polygon temp;
		Polygon polygon;
		Array<Polygon> tris = new Array<Polygon> (false, noTriangles);
		
		polygon = new Polygon(coords);
		for (int i = 0; i < noTriangles; i++) {
			temp = new Polygon(new float[] {coords[triangles[3*i]*2], coords[triangles[3*i]*2 + 1], coords[triangles[3*i + 1]*2], coords[triangles[3*i + 1]*2 + 1],
													coords[triangles[3*i + 2]*2], coords[triangles[3*i + 2]*2 + 1]});
			tris.add(temp);
		}
		return new OriginalPiece(puzzle, polygon, tris, 0, color, id, oX, oY);
	}
}



Contains methods for setting the colour to be used for new pieces.

public class ColourPuzzle extends Puzzle {
	
	Color currentColor;
	public float x;
	public float y;
	
	public ColourPuzzle(int noPieces, Array<PuzzlePiece> puzzlePieces, int[][][] matches) {
		super(noPieces, puzzlePieces, matches);
	}

	public void setColor(Color color) {
		currentColor = color;
		puzzlePieces.get(0).color = currentColor;
		initPieces.removeIndex(0);
		create(0);
	}
	
	public void setColor(float x, float y) {
		if (ColourWorldRenderer.sprite.getBoundingRectangle().contains(x, y)) {
			setColor(ColourWorldRenderer.getColor(x, y));
		}
	}
}




Renders a colour picker after everything else, and uses a Sprite and a Pixmap together to make it easy
to choose a colour. Pixmaps return 32-bit integer colours, so conversion is required.

public class ColourWorldRenderer extends WorldRenderer {
	
	private static final FileHandle fileHandle = Gdx.files.internal("data/colour_picker.png"); 
	private static final Pixmap pixmap = new Pixmap(fileHandle);
	private static final Texture texture = new Texture("data/colour_picker.png");
	public static Sprite sprite;
	private static float x, y, w, h;
	
	public ColourWorldRenderer(ColourPuzzle puzzle) {
		super(puzzle);

		texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);

		w = MozaicPlayer.scale*264;
		h = MozaicPlayer.scale*231;
		x = MozaicPlayer.width*0.5f;
		y =  MozaicPlayer.trans*0.5f - h/2;
		
		sprite = new Sprite(texture);
		sprite.setBounds(x, y, w, h);
		sprite.setColor(1, 1, 1, 1);
	}
	
	@Override
	public void render() {
		super.render();
		
		batch.setProjectionMatrix(camO.combined);
		batch.begin();
		sprite.draw(batch);
		batch.end();
		
	    Gdx.gl.glDisable(GL10.GL_BLEND);
	}

	public static Color getColor(float x2, float y2) {
		float pixX = x2 - x;
		float pixY = h - (y2 - y); // inverse y coordinates
		pixX *= 256;
		pixX /= w;
		pixY *= 224;
		pixY /= h;
		int x3 = Math.round(pixX);
		int y3 = Math.round(pixY);
		int c = pixmap.getPixel(x3, y3);
		
		Color color = new Color();
		color.r = ((c & 0xff000000) >>> 24) / 255f;
		color.g = ((c & 0x00ff0000) >>> 16) / 255f;
		color.b = ((c & 0x0000ff00) >>> 8) / 255f;
		color.a = ((c & 0x000000ff)) / 255f;
		return color;
	}
}




ReflectWorldRenderer overrides render(), but the only change is that it checks if the piece is spawned before drawing it.



WorldRenderer has been changed to use Puzzle instead of multiple other classes.

	public WorldRenderer(Puzzle puzzle) {
		this.puzzle = puzzle;
		
		puzzle.setRenderer(this);
		
		width = Gdx.graphics.getWidth();
		height = Gdx.graphics.getHeight();
		
		cam = new OrthographicCamera();
		cam.setToOrtho(false, width, height);		
		cam.update();
		
		camO = new OrthographicCamera();
		camO.setToOrtho(false, width, height);
		camO.update();

		batch = new SpriteBatch();
		batch.setProjectionMatrix(cam.combined);
		
		sr = new ShapeRenderer();
	}
	
	protected Iterator<Piece> getIterator() {
		return puzzle.getIterator();
	}
	
	protected Iterator<Piece> getInitIterator() {
		return puzzle.getInitIterator();
	}
	
	protected Piece getClone() {
		return puzzle.getClone();
	}



GameScreen has the behaviour that used to be in the World class:

	public GameScreen(MozaicPlayer game, Puzzle puzzle){	
		this.game = game;
		this.puzzle = puzzle;
		render = new WorldRenderer(puzzle);

		Gdx.input.setInputProcessor(new InputHandler(puzzle, this));
		Gdx.input.setCatchBackKey(true);
		Gdx.input.setCatchMenuKey(true);
		
	}
	
	public void mainMenu() {
		game.setScreen(new MainMenu(game));
	}
	
	public void optionsScreen() {
		game.setScreen(new OptionsScreen(game, true));
	}
	

There are also ColourGameScreen and StaticGameScreen classes which just set render to the correct kind of WorldRenderer.




The OriginalPiece class overrides a few methods, some as a necessity and some are just optimisations.

public class OriginalPiece extends Piece {

	public OriginalPiece(Puzzle puzzle, Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, float oX, float oY) {
		super(puzzle, polygon, triangles, rot, color, id, oX, oY);
	}
	
	@Override
	public void fix(Vector2 v0, Vector2 v1, Vector2 u0, Vector2 u1){
		translateWOC(u0.x - v0.x, u0.y - v0.y);
	}

	@Override
	public boolean fixRotation(float originalRot) {
		// set rotation to the nearest multiple of 45 that doesn't overlap
		boolean pos = false;
		int mul = 1;
		float rot = polygon.getRotation();
		float diff = rot % 45;
		if (diff < 22.5)
			rotate(-diff);
		else {
			rotate(45 - diff);
			pos = true;
		}
		while (puzzle.overlaps(this)) {
			if (pos)
				rotate(-45 * mul);
			else 
				rotate(45 * mul);
			mul += 1;
			//TODO
			// safety net, shouldn't be required
			if (mul == 8) {
				setRotation(originalRot);
				break;
			}
			pos = !pos;
		}
		return false;
	}
	
	// Reverse ordering of translating the polygon and the triangles, because of different overlaps methods.
	@Override
	public boolean translate(float x, float y) {
		polygon.translate(x, y);
		if (puzzle.overlaps(this)) {	
			polygon.translate(-x, -y);
			return false;
		}
		
		for (Polygon triangle : triangles)
			triangle.translate(x, y);
			
		return true;
	}
	
	public Polygon get() {
		return polygon;
	}
}





Here is the Piece class, which along with Puzzle, WorldRenderer and InputHandler encapsulates a lot of the required behaviour:

public class Piece {
	
	protected Polygon polygon;
	protected Array<Polygon> triangles;
	protected Color color;
	protected Puzzle puzzle;
	
	protected static Array<Piece> initPieces = new Array<Piece>(false, 10);
	public static Piece clone;
	protected float rot;
	public static Array<Piece> pieces = new Array<Piece>(false, MozaicPlayer.PIECES);
	private int id;
	
	protected static float dMaxOverlaps = MozaicPlayer.scale*524;
	protected static float dMaxSnap = MozaicPlayer.scale*356;
	private int size;
	float oX, oY;
	
	public Piece(Puzzle puzzle, Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id, float oX, float oY) {
		this.puzzle = puzzle;
		this.polygon = polygon;
		this.triangles = triangles;
		this.rot = rot;
		polygon.setRotation(rot);
		this.color = color;
		this.id = id;
		this.oX = oX;
		this.oY = oY;
		setOrigin(oX, oY);
		puzzle.pieces.add(this);
		size = triangles.size;
	}
	
	public boolean fixRotation(float originalRot) {
		if (puzzle.overlaps(this)) {
			setRotation(originalRot);
			return true;
		}
		return false;
	}
	
	public Piece(Polygon polygon, Array<Polygon> triangles, float rot, Color color, int id) {
		this.polygon = polygon;
		this.triangles = triangles;
		this.color = color;
		this.rot = rot;
		polygon.setRotation(rot);
		this.id = id;
		pieces.add(this);
		size = triangles.size;
	}
	
	protected void setOrigin(float x, float y) {
		polygon.setOrigin(x, y);
		for (Polygon triangle : triangles)
			triangle.setOrigin(x, y);
	}

	public float getTransY() {
		return polygon.getY();
	}
	
	public float getTransX() {
		return polygon.getX();
	}
	
	public boolean translate(float x, float y) {
		for (Polygon triangle : triangles)
			triangle.translate(x, y);
			
		if (puzzle.overlaps(this)) {
			for (Polygon triangle : triangles)
				triangle.translate(-x, -y);
			return false;
		}	
		polygon.translate(x, y);
		return true;
	}
	
	public void translateWOC(float x, float y) {
		for (Polygon triangle : triangles)
			triangle.translate(x, y);
		polygon.translate(x, y);
	}
	
	public float getAngle(float x, float y) {
		Vector2 centre = centre(getVerts());
		float rx = x - centre.x;
		float ry = y - centre.y;
		float rot = (float) Math.toDegrees(Math.atan(ry / rx));
		if (rot < 0)
			rot += 180;
		if (ry < 0)
			rot += 180;
		return rot;
	}
	
	private Vector2 centre(float[] transformedVertices) {
		int n = transformedVertices.length;
		float x = 0, y = 0;
		for (int i = 0; i < n; i+=2) {
			x += transformedVertices[i];
			y += transformedVertices[i+1];
		}
		x /= (n/2);
		y /= (n/2);
		return new Vector2(x, y);
	}
	
	public boolean contains(float x, float y) {
		for (Polygon triangle : triangles) {
			if (triangle.contains(x, y))
				return true;
		}
		return false;
	}
	
	public Polygon get(int i) {
		return triangles.get(i);
	}
	
	public Piece clonef() {
		Color c = color.cpy();
		c.a = 0.5f;
		Polygon triangle_;
		Array<Polygon> triangles_ = new Array<Polygon>(false, 4);
		for (Polygon triangle: triangles) {
			triangle_ = new Polygon(triangle.getTransformedVertices());
			triangles_.add(triangle_);
		}
		Piece piece = new Piece(puzzle, new Polygon(getVerts()), triangles_, 0, c, -1, polygon.getOriginX(), polygon.getOriginY());
		clone = piece;
		return piece;
	}
	
	public int getID() {
		return id;
	}
	
	public void setID(int id) {
		this.id = id;
	}
	
	public void rotate(float degrees) {	
		polygon.rotate(degrees);
		for (Polygon triangle : triangles)
			triangle.rotate(degrees);
	}
	
	public float getRotation() {
		return polygon.getRotation();
	}
	
	protected void setRotation(float degrees) {
		polygon.setRotation(degrees);
		for (Polygon triangle : triangles)
			triangle.setRotation(degrees);
	}
	
	public float[] getVerts() {
		return polygon.getTransformedVertices();
	}
	
	public int getSize() {
		return size;
	}
	
	public void draw(ShapeRenderer sr) {
		float [] verts;
		sr.setColor(color);
		for (Polygon triangle : triangles) {
			verts = triangle.getTransformedVertices();
			sr.filledTriangle(verts[0], verts[1], verts[2], verts[3], verts[4], verts[5]);
		}
	}

	public void fix(Vector2 v0, Vector2 v1, Vector2 u0, Vector2 u1){
		float d0 = v0.dst(u0);
		float d1 = v1.dst(u1);
		
		if (d0 > d1) {
			Vector2 v = v0;
			v0 = v1;
			v1 = v;
			v = u0;
			u0 = u1;
			u1 = v;
		}
				
		if (d0 != d1) {
			float a = (float) ( Math.pow((v1.x - v0.x), 2) + Math.pow((v1.y - v0.y), 2) );
			float b = (float) ( Math.pow((u1.x - u0.x), 2) + Math.pow((u1.y - u0.y), 2) );
			float c = (float) ( Math.pow(((u1.x + v0.x - u0.x) - v1.x), 2) + Math.pow(((u1.y + v0.y - u0.y) - v1.y), 2) );
			float rot = (float) Math.toDegrees( Math.acos( (a+b-c) / (2 * Math.sqrt(a) * Math.sqrt(b)) ) );
			if ( rot > 0.5 ) {
			
			float dx = u1.x - u0.x;
			float dx2 = dx * dx;
			float dy = u1.y - u0.y;
			float dy2 = dy * dy;
			float ax = v0.x;
			float ay = v0.y;
			float bx = v1.x;
			float by = v1.y;
			float s_ = ( dy2 * dx * (bx - ax) - dx2 * dy * (by - ay) ) / ( dy2 - dx2 );
			float s = ( bx - ax - s_ / dx ) / dx;
			
			Vector2 x_ = new Vector2(s * dx + ax, s * dy + ay);
			
			if (Math.abs(dy) > Math.abs(dx)) {			
				if (dy > 0 && v1.x < x_.x)
					rot = - rot;
				if (dy < 0 && v1.x > x_.x)
					rot = - rot;
			}
			
			else {
				if (dx > 0 && v1.y > x_.y)
					rot = - rot;
				if (dx < 0 && v1.y < x_.y)
					rot = - rot;
			}
			
			rotate(rot);
			}
		}
		Vector2 v_ = getClosest(u1);
		translateWOC(u1.x - v_.x, u1.y - v_.y);
	}
	
	private Vector2 getClosest(Vector2 u) {
		float[] coords = getVerts();
		int l = coords.length/2;
		Array<Vector2> verts = new Array<Vector2>(false, l);
		float[] dsts = new float[l];
		Vector2 v;
		float min = 1000;
		
		for (int i = 0; i < l*2; i++) {
			v = new Vector2(coords[i], coords[++i]);
			verts.add(v);
			dsts[i/2] = v.dst(u);
			min = Math.min(dsts[i/2], min);
		}

		for (int i = 0; i < l; i++) {
			if (dsts[i] == min)
				return verts.get(i);
		}
		return null;
	}
}





And finally, the MozaicPlayer class. I have omitted the declaration and definition of the static floats used in construction for brevity.
I have also omitted those methods currently unused, e.g. saving/loading methods

public class MozaicPlayer extends Game {
	
	public static final String VERSION = "0.4.0";
	public static final String LOG = "Mozaic Player";
	public static final int PIECES = 100;
	public static final boolean DEBUG = false;
	public static final int assumeWidth = 683;
	public static final int assumeHeight = 683;
	public static int width;
	public static int height;
	public static int size;
	public static float scale;
	public static int trans;
	
	private static GameMode gameMode = GameMode.Classic;
	private static int reflection = 0;
	
	public static final int ClassicID = 5;
	public static final int PenroseID = 1;
	
	public enum GameMode{Classic, PenroseKD, PenroseOri, PenroseRhomb, Reflect}
	
	private static boolean musicOn = false;
	private static boolean sfxOn = false;
	public static boolean started = false;
	public static boolean initiated = false;
	
	FPSLogger log;
	
	private Puzzle rhombPuzzle;
	private Puzzle oriPuzzle;
	private Puzzle kiteDartPuzzle;
	private ColourPuzzle pixelPuzzle;
	private OriginalPuzzle classicPuzzle;
	private ReflectPuzzle reflectPuzzle;
	
	@Override
	public void create() {
		//reset();
		width = Gdx.graphics.getWidth(); 
		height = Gdx.graphics.getHeight();
		size = width; // Math.min(width, height);
		scale = (float) size/assumeWidth;
		trans = height - width; // Math.max(width, height) - size;
				
		log = new FPSLogger();
/*		try {
			load();
		}
		catch (SerializationException exception) { System.out.println("fail");
		exception.printStackTrace();}*/
		
//      setScreen(new SplashScreen(this));
//		setScreen(new MainMenu(this));
		
//		createRhombPuzzle();
//		createOriPuzzle();
//		createKiteDartPuzzle();
//		createPixelPuzzle();
//		createClassicPuzzle();
		createReflectPuzzle(6);

		
		setScreen (new StaticGameScreen(this, reflectPuzzle));
//		setScreen (new OriginalGameScreen(this, classicPuzzle));
//		setScreen(new ColourGameScreen(this, pixelPuzzle));
//		setScreen(new GameScreen(this, kiteDartPuzzle));
//		setScreen(new GameScreen(this, oriPuzzle));
//		setScreen(new GameScreen(this, rhombPuzzle));
	}
	
	public static void setGameMode(GameMode mode) {
		gameMode = mode;
	}
	
	public static GameMode getMode() {
		return gameMode;
	}
	
	@Override
	public void dispose() {
		super.dispose();
		MozaicAudio.dispose();
	}

	@Override
	public void render() {
		super.render();
		//log.log();
	}
	
	@Override
	public void resize(int width, int height) {
		super.resize(width, height);
	}

	@Override
	public void pause() {
		super.pause();
	}

	@Override
	public void resume() {
		super.resume();
	}

	public void toggleMusic() {
		musicOn = !musicOn;
		if (musicOn)
			MozaicAudio.playMusic(true);
		else MozaicAudio.stopMusic();
	}
	
	public void toggleSFX() {
		MozaicAudio.toggleSFX();
		sfxOn = !sfxOn;
	}

	public boolean isMusicMuted() {
		return !musicOn;
	}

	public boolean isSFXMuted() {
		return !sfxOn;
	}

	public static int getReflection() {
		return reflection;
	}

	public static void setReflection(int reflection) {
		MozaicPlayer.reflection = reflection;
	}
	
	private void createReflectPuzzle(int ref) {
		
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 10);
		
		int[][][] matches = new int[][][] {{{0,1,0,1, 0,1,1,0, 0,1,2,0, 0,1,0,2,
											 1,2,1,2, 1,2,2,1,
											 2,0,0,1, 2,0,1,0, 2,0,2,0, 2,0,0,2},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 2,0,0,1, 2,0,1,0, 2,0,1,2, 2,0,2,1, 2,0,2,3, 2,0,3,2, 2,0,3,0, 2,0,0,3}},
											 
										   {{0,1,0,1, 0,1,1,0, 0,1,2,0, 0,1,0,2,
											 1,2,0,1, 1,2,1,0, 1,2,2,0, 1,2,0,2,
											 2,3,0,1, 2,3,1,0, 2,3,2,0, 2,3,0,2,
											 3,0,0,1, 3,0,1,0, 3,0,2,0, 3,0,0,2},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
											 3,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
											 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,0, 3,0,0,3}}};

		
		reflectPuzzle = new ReflectPuzzle(10, puzzlePieces, matches);
		
		
		float[] coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		int[] triangles = new int[] {0,1,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.15f, 0.7f, coords, 1, triangles, color1, 0, ref, square/3, square/3));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color2 = Color.GREEN;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.35f, 0.7f, coords, 1, triangles, color2, 1, ref, square/3, square/3));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color3 = Color.YELLOW;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.15f, 0.45f, coords, 1, triangles, color3, 2, ref, square/3, square/3));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color4 = Color.RED;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.35f, 0.45f, coords, 1, triangles, color4, 3, ref, square/3, square/3));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color5 = Color.CYAN;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.15f, 0.2f, coords, 1, triangles, color5, 4, ref, square/3, square/3));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color6 = Color.MAGENTA;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.35f, 0.2f, coords, 1, triangles, color6, 5, ref, square/3, square/3));
		
		
		coords = new float[] {-(square + CH)/2, -CH/2, (square - CH)/2, -CH/2, (square + CH)/2, CH/2, (CH - square)/2, CH/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.6f, 0.7f, coords, 2, triangles, color1, 6, ref, (square + CH)/2, CH/2));
		
		coords = new float[] {-(square + CH)/2, -CH/2, (square - CH)/2, -CH/2, (square + CH)/2, CH/2, (CH - square)/2, CH/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.8f, 0.7f, coords, 2, triangles, color2, 7, ref, (square + CH)/2, CH/2));
		
		coords = new float[] {-(square + CH)/2, -CH/2, (square - CH)/2, -CH/2, (square + CH)/2, CH/2, (CH - square)/2, CH/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.6f, 0.45f, coords, 2, triangles, color3, 8, ref, (square + CH)/2, CH/2));
		
		coords = new float[] {-(square + CH)/2, -CH/2, (square - CH)/2, -CH/2, (square + CH)/2, CH/2, (CH - square)/2, CH/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.8f, 0.45f, coords, 2, triangles, color4, 9, ref, (square + CH)/2, CH/2));
		
		reflectPuzzle.initiate();
	}



	private void createClassicPuzzle() {
		
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 10);
		
		int[][][] matches = new int[][][] {{{0,1,0,1, 0,1,1,0, 0,1,2,0, 0,1,0,2,
											 1,2,1,2, 1,2,2,1,
											 2,0,0,1, 2,0,1,0, 2,0,2,0, 2,0,0,2},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 2,0,0,1, 2,0,1,0, 2,0,1,2, 2,0,2,1, 2,0,2,3, 2,0,3,2, 2,0,3,0, 2,0,0,3}},
											 
										   {{0,1,0,1, 0,1,1,0, 0,1,2,0, 0,1,0,2,
											 1,2,0,1, 1,2,1,0, 1,2,2,0, 1,2,0,2,
											 2,3,0,1, 2,3,1,0, 2,3,2,0, 2,3,0,2,
											 3,0,0,1, 3,0,1,0, 3,0,2,0, 3,0,0,2},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
											 3,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
											 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,0, 3,0,0,3}}};

		
		classicPuzzle = new OriginalPuzzle(10, puzzlePieces, matches);

		
		float[] coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		int[] triangles = new int[] {0,1,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.15f, 0.7f, coords, 1, triangles, color1, 0));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color2 = Color.GREEN;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.35f, 0.7f, coords, 1, triangles, color2, 1));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color3 = Color.YELLOW;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.15f, 0.45f, coords, 1, triangles, color3, 2));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color4 = Color.RED;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.35f, 0.45f, coords, 1, triangles, color4, 3));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color5 = Color.CYAN;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.15f, 0.2f, coords, 1, triangles, color5, 4));
		
		coords = new float[] {-square/3, -square/3, 2*square/3, -square/3, -square/3, 2*square/3};
		triangles = new int[] {0,1,2};
		Color color6 = Color.MAGENTA;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.35f, 0.2f, coords, 1, triangles, color6, 5));
		
		
		coords = new float[] {-(square + CH)/2, -CH/2, (square - CH)/2, -CH/2, (square + CH)/2, CH/2, (CH - square)/2, CH/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.6f, 0.7f, coords, 2, triangles, color1, 6));
		
		coords = new float[] {-(square + CH)/2, -CH/2, (square - CH)/2, -CH/2, (square + CH)/2, CH/2, (CH - square)/2, CH/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.8f, 0.7f, coords, 2, triangles, color2, 7));
		
		coords = new float[] {-(square + CH)/2, -CH/2, (square - CH)/2, -CH/2, (square + CH)/2, CH/2, (CH - square)/2, CH/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.6f, 0.45f, coords, 2, triangles, color3, 8));
		
		coords = new float[] {-(square + CH)/2, -CH/2, (square - CH)/2, -CH/2, (square + CH)/2, CH/2, (CH - square)/2, CH/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.8f, 0.45f, coords, 2, triangles, color4, 9));
		
		classicPuzzle.initiate();
	}
	
	
	
	private void createPixelPuzzle() {
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 1);
		
		int[][][] matches = new int[][][] {{{0,1,3,2, 1,2,0,3, 3,2,0,1, 0,3,1,2}}};
		
		pixelPuzzle = new ColourPuzzle(1, puzzlePieces, matches);
		
		float[] coords = new float[] {-square, -square, square, -square, square, square, -square, square};
		int[] triangles = new int[] {0,1,2, 0,3,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(pixelPuzzle, 0.25f, 0.5f, coords, 2, triangles, color1, 0));
		
		pixelPuzzle.initiate();
	}
	
	
	
	private void createKiteDartPuzzle() {
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 2);
		
		int[][][] matches = new int[][][] {{{1,2,1,2, 1,2,3,2, 2,3,2,3, 2,3,2,1, 0,1,0,1, 0,1,0,3, 0,3,0,3, 0,3,0,1}, 
											{0,1,1,0, 0,1,3,0, 0,3,1,0, 0,3,3,0, 2,1,1,2, 2,1,3,2, 2,3,1,2, 2,3,3,2}},
											
				 						   {{0,1,1,0, 0,1,3,0, 0,3,1,0, 0,3,3,0, 2,1,1,2, 2,1,3,2, 2,3,1,2, 2,3,3,2}, 
										    {0,1,0,1, 0,1,0,3, 0,3,0,3, 0,3,0,1}}};
		
		kiteDartPuzzle = new Puzzle(2, puzzlePieces, matches);
		
		float[] coords = new float[] {-KOX, -KOY + KY, -KOX + KX1, -KOY, -KOX + KX2, -KOY + KY, -KOX + KX1, -KOY + 2*KY};
		int[] triangles = new int[] {0,1,2, 0,3,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(kiteDartPuzzle, 0.33f, 0.5f, coords, 2, triangles, color1, 0));
		
		coords = new float[] {-DaOX + DaX1, -DaOY + DaY, -DaOX , -DaOY, -DaOX + DaX2, -DaOY + DaY, -DaOX, -DaOY + 2*DaY};
		triangles = new int[] {0,1,2, 0,3,2};
		Color color2 = Color.CYAN;
		puzzlePieces.add(new PuzzlePiece(kiteDartPuzzle, 0.66f, 0.5f, coords, 2, triangles, color2, 1));
		
		kiteDartPuzzle.initiate();
	}
	
	
	
	private void createRhombPuzzle() {
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 2);
		
		int[][][] matches = new int[][][] {{{0,1,0,3, 0,3,0,1, 1,2,3,2, 3,2,1,2}, {0,1,3,2, 0,3,3,0, 1,2,1,0, 3,2,1,2}},
				 {{3,2,0,1, 3,0,0,3, 1,0,1,2, 1,2,3,2}, {0,1,2,1, 2,1,0,1, 0,3,2,3, 2,3,0,3}}};
		
		rhombPuzzle = new Puzzle(2, puzzlePieces, matches);
		
		float[] coords = new float[] {(-WIDTH - LSLIDE)/2, -LHEIGHT/2, (WIDTH - LSLIDE)/2, -LHEIGHT/2, (WIDTH + LSLIDE)/2, LHEIGHT/2, (-WIDTH + LSLIDE)/2, LHEIGHT/2};
		int[] triangles = new int[] {0,1,2, 0,3,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(rhombPuzzle, 0.33f, 0.5f, coords, 2, triangles, color1, 0));
		
		coords = new float[] {(-WIDTH - SSLIDE)/2, -SHEIGHT/2, (WIDTH - SSLIDE)/2, -SHEIGHT/2, (WIDTH + SSLIDE)/2, SHEIGHT/2, (-WIDTH + SSLIDE)/2, SHEIGHT/2};
		triangles = new int[] {0,1,2, 0,3,2};
		Color color2 = Color.CYAN;
		puzzlePieces.add(new PuzzlePiece(rhombPuzzle, 0.66f, 0.5f, coords, 2, triangles, color2, 1));
		
		rhombPuzzle.initiate();
	}
	
	
	
	private void createOriPuzzle() {
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 3);
		
		int[][][] matches = new int[][][] {{{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,5, 0,1,5,4, 
											 0,1,5,6, 0,1,6,5, 0,1,6,7, 0,1,7,6, 0,1,7,8, 0,1,8,7, 0,1,8,9, 0,1,9,8, 0,1,9,0, 0,1,0,9, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,5, 1,2,5,4, 
											 1,2,5,6, 1,2,6,5, 1,2,6,7, 1,2,7,6, 1,2,7,8, 1,2,8,7, 1,2,8,9, 1,2,9,8, 1,2,9,0, 1,2,0,9, 
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,5, 2,3,5,4, 
											 2,3,5,6, 2,3,6,5, 2,3,6,7, 2,3,7,6, 2,3,7,8, 2,3,8,7, 2,3,8,9, 2,3,9,8, 2,3,9,0, 2,3,0,9, 
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,5, 3,4,5,4, 
											 3,4,5,6, 3,4,6,5, 3,4,6,7, 3,4,7,6, 3,4,7,8, 3,4,8,7, 3,4,8,9, 3,4,9,8, 3,4,9,0, 3,4,0,9, 
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,5, 4,0,5,4, 
											 4,0,5,6, 4,0,6,5, 4,0,6,7, 4,0,7,6, 4,0,7,8, 4,0,8,7, 4,0,8,9, 4,0,9,8, 4,0,9,0, 4,0,0,9},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,5, 0,1,5,4, 0,1,5,6, 0,1,6,5, 0,1,6,0, 0,1,0,6,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,5, 1,2,5,4, 1,2,5,6, 1,2,6,5, 1,2,6,0, 1,2,0,6,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,5, 2,3,5,4, 2,3,5,6, 2,3,6,5, 2,3,6,0, 2,3,0,6,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,5, 3,4,5,4, 3,4,5,6, 3,4,6,5, 3,4,6,0, 3,4,0,6,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,5, 4,0,5,4, 4,0,5,6, 4,0,6,5, 4,0,6,0, 4,0,0,6}, 
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,0, 3,4,0,3,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,0, 4,0,0,3}}, 
												 
										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											 {}, 
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,6,0, 0,1,0,6,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,6,0, 1,2,0,6,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,6,0, 2,3,0,6,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,6,0, 3,4,0,6,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,6,0, 4,0,0,6}, 
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,0, 3,4,0,3,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,0, 4,0,0,3}},
											 
										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											 {}, {}, {}},

										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,5,0,1, 4,5,1,0, 4,5,1,2, 4,5,2,1, 4,5,2,3, 4,5,3,2, 4,5,3,4, 4,5,4,3, 4,5,4,0, 4,5,0,4,
											 5,6,0,1, 5,6,1,0, 5,6,1,2, 5,6,2,1, 5,6,2,3, 5,6,3,2, 5,6,3,4, 5,6,4,3, 5,6,4,0, 5,6,0,4,
											 6,7,0,1, 6,7,1,0, 6,7,1,2, 6,7,2,1, 6,7,2,3, 6,7,3,2, 6,7,3,4, 6,7,4,3, 6,7,4,0, 6,7,0,4,
											 7,8,0,1, 7,8,1,0, 7,8,1,2, 7,8,2,1, 7,8,2,3, 7,8,3,2, 7,8,3,4, 7,8,4,3, 7,8,4,0, 7,8,0,4,
											 8,9,0,1, 8,9,1,0, 8,9,1,2, 8,9,2,1, 8,9,2,3, 8,9,3,2, 8,9,3,4, 8,9,4,3, 8,9,4,0, 8,9,0,4,
											 9,0,0,1, 9,0,1,0, 9,0,1,2, 9,0,2,1, 9,0,2,3, 9,0,3,2, 9,0,3,4, 9,0,4,3, 9,0,4,0, 9,0,0,4},
										   	 {}, {}, {}, {}, {}},
											 
										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,5,0,1, 4,5,1,0, 4,5,1,2, 4,5,2,1, 4,5,2,3, 4,5,3,2, 4,5,3,4, 4,5,4,3, 4,5,4,0, 4,5,0,4,
											 5,6,0,1, 5,6,1,0, 5,6,1,2, 5,6,2,1, 5,6,2,3, 5,6,3,2, 5,6,3,4, 5,6,4,3, 5,6,4,0, 5,6,0,4,
											 6,0,0,1, 6,0,1,0, 6,0,1,2, 6,0,2,1, 6,0,2,3, 6,0,3,2, 6,0,3,4, 6,0,4,3, 6,0,4,0, 6,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 6,0,0,1, 6,0,1,0, 6,0,1,2, 6,0,2,1, 6,0,2,3, 6,0,3,2, 6,0,3,4, 6,0,4,3, 6,0,4,0, 6,0,0,4},
										   	 {}, {}, {}, {}},	
										   	 
										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,4, 3,0,4,3, 3,0,4,0, 3,0,0,4},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,4, 3,0,4,3, 3,0,4,0, 3,0,0,4},
										   	 {}, {}, {}, {}}};
		
		oriPuzzle = new Puzzle(6, puzzlePieces, matches);
		
		float[] coords = new float[] {-X1/2, (-Y1 - Y2)/2, X1/2, (-Y1 - Y2)/2, X1/2 + X2, (Y1 - Y2)/2, -X1/2 + X3, (Y1 + Y2)/2, -X1/2 - X2, (Y1 - Y2)/2};
		int[] triangles = new int[] {0,1,2, 2,3,4, 0,4,2};
		Color color1 = Color.RED;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.25f, 0.8f, coords, 3, triangles, color1, 0));
		
		Color color2 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.25f, 0.5f, coords, 3, triangles, color2, 1));
		
		Color color3 = Color.GREEN;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.25f, 0.2f, coords, 3, triangles, color3, 2));
		
		coords = new float[] {-OX, -OY, -OX + SX1, -OY + SY3, -OX + 2*SX1, -OY, -OX + 2*SX1 - SX2, -OY + SY2, -OX + 2*SX1 + SX3, -OY + SY1 - SY2,
				-OX + SX1 + SX2, -OY + SY1 - SY2, -OX + SX1, -OY + SY1, -OX + SX1 - SX2, -OY + SY1 - SY2, -OX - SX3, -OY + SY1 - SY2, -OX + SX2, -OY + SY2};
		triangles = new int[] {0,6,3, 8,4,1, 2,3,1, 5,7,9};
		Color color4 = Color.YELLOW;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.7f, 0.65f, coords, 4, triangles, color4, 3));
		
		coords = new float[] {-BOX, -BOY, -BOX + 2*BX1, -BOY, -BOX + 2*BX1 + BX2, -BOY + BY2, -BOX + 2*BX1 - BX3, -BOY + BY2, -BOX + BX1, -BOY + BY1, -BOX + BX3, -BOY + BY2, -BOX - BX2, -BOY + BY2};
		triangles = new int[] {0,4,1, 0,6,5, 1,2,3};
		Color color5 = Color.MAGENTA;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.7f, 0.3f, coords, 3, triangles, color5, 4));
		
		coords = new float[] {0, -DOY, DX, -DOY + DY, 0, -DOY + 2*DY, -DX, -DOY + DY};
		triangles = new int[] {0,1,3, 2,1,3};
		Color color6 = Color.CYAN;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.45f, 0.55f, coords, 2, triangles, color6, 5));
		
		oriPuzzle.initiate();
	}
}











	public void save() {
		Json json = new Json();
		Array<SavePiece> savePieces = oriPuzzle.save();
		Array<SavePuzzlePiece> puzzlePieces = new Array<SavePuzzlePiece>(false, 6);
		
		int[][][] matches = new int[][][] {{{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,5, 0,1,5,4, 
			 0,1,5,6, 0,1,6,5, 0,1,6,7, 0,1,7,6, 0,1,7,8, 0,1,8,7, 0,1,8,9, 0,1,9,8, 0,1,9,0, 0,1,0,9, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,5, 1,2,5,4, 
			 1,2,5,6, 1,2,6,5, 1,2,6,7, 1,2,7,6, 1,2,7,8, 1,2,8,7, 1,2,8,9, 1,2,9,8, 1,2,9,0, 1,2,0,9, 
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,5, 2,3,5,4, 
			 2,3,5,6, 2,3,6,5, 2,3,6,7, 2,3,7,6, 2,3,7,8, 2,3,8,7, 2,3,8,9, 2,3,9,8, 2,3,9,0, 2,3,0,9, 
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,5, 3,4,5,4, 
			 3,4,5,6, 3,4,6,5, 3,4,6,7, 3,4,7,6, 3,4,7,8, 3,4,8,7, 3,4,8,9, 3,4,9,8, 3,4,9,0, 3,4,0,9, 
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,5, 4,0,5,4, 
			 4,0,5,6, 4,0,6,5, 4,0,6,7, 4,0,7,6, 4,0,7,8, 4,0,8,7, 4,0,8,9, 4,0,9,8, 4,0,9,0, 4,0,0,9},
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,5, 0,1,5,4, 0,1,5,6, 0,1,6,5, 0,1,6,0, 0,1,0,6,
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,5, 1,2,5,4, 1,2,5,6, 1,2,6,5, 1,2,6,0, 1,2,0,6,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,5, 2,3,5,4, 2,3,5,6, 2,3,6,5, 2,3,6,0, 2,3,0,6,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,5, 3,4,5,4, 3,4,5,6, 3,4,6,5, 3,4,6,0, 3,4,0,6,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,5, 4,0,5,4, 4,0,5,6, 4,0,6,5, 4,0,6,0, 4,0,0,6}, 
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,0, 3,4,0,3,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,0, 4,0,0,3}}, 
				 
		   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
			 {}, 
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,6,0, 0,1,0,6,
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,6,0, 1,2,0,6,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,6,0, 2,3,0,6,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,6,0, 3,4,0,6,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,6,0, 4,0,0,6}, 
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,0, 3,4,0,3,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,0, 4,0,0,3}},
			 
		   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
			 {}, {}, {}},

		   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,5,0,1, 4,5,1,0, 4,5,1,2, 4,5,2,1, 4,5,2,3, 4,5,3,2, 4,5,3,4, 4,5,4,3, 4,5,4,0, 4,5,0,4,
			 5,6,0,1, 5,6,1,0, 5,6,1,2, 5,6,2,1, 5,6,2,3, 5,6,3,2, 5,6,3,4, 5,6,4,3, 5,6,4,0, 5,6,0,4,
			 6,7,0,1, 6,7,1,0, 6,7,1,2, 6,7,2,1, 6,7,2,3, 6,7,3,2, 6,7,3,4, 6,7,4,3, 6,7,4,0, 6,7,0,4,
			 7,8,0,1, 7,8,1,0, 7,8,1,2, 7,8,2,1, 7,8,2,3, 7,8,3,2, 7,8,3,4, 7,8,4,3, 7,8,4,0, 7,8,0,4,
			 8,9,0,1, 8,9,1,0, 8,9,1,2, 8,9,2,1, 8,9,2,3, 8,9,3,2, 8,9,3,4, 8,9,4,3, 8,9,4,0, 8,9,0,4,
			 9,0,0,1, 9,0,1,0, 9,0,1,2, 9,0,2,1, 9,0,2,3, 9,0,3,2, 9,0,3,4, 9,0,4,3, 9,0,4,0, 9,0,0,4},
		   	 {}, {}, {}, {}, {}},
			 
		   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
			 4,5,0,1, 4,5,1,0, 4,5,1,2, 4,5,2,1, 4,5,2,3, 4,5,3,2, 4,5,3,4, 4,5,4,3, 4,5,4,0, 4,5,0,4,
			 5,6,0,1, 5,6,1,0, 5,6,1,2, 5,6,2,1, 5,6,2,3, 5,6,3,2, 5,6,3,4, 5,6,4,3, 5,6,4,0, 5,6,0,4,
			 6,0,0,1, 6,0,1,0, 6,0,1,2, 6,0,2,1, 6,0,2,3, 6,0,3,2, 6,0,3,4, 6,0,4,3, 6,0,4,0, 6,0,0,4},
			{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 6,0,0,1, 6,0,1,0, 6,0,1,2, 6,0,2,1, 6,0,2,3, 6,0,3,2, 6,0,3,4, 6,0,4,3, 6,0,4,0, 6,0,0,4},
		   	 {}, {}, {}, {}},	
		   	 
		   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,4, 3,0,4,3, 3,0,4,0, 3,0,0,4},
		    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
			 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
			 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
			 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,4, 3,0,4,3, 3,0,4,0, 3,0,0,4},
		   	 {}, {}, {}, {}}};

		
		float[] coords = new float[] {-X1/2, (-Y1 - Y2)/2, X1/2, (-Y1 - Y2)/2, X1/2 + X2, (Y1 - Y2)/2, -X1/2 + X3, (Y1 + Y2)/2, -X1/2 - X2, (Y1 - Y2)/2};
		int[] triangles = new int[] {0,1,2, 2,3,4, 0,4,2};
		Color color1 = Color.RED;
		puzzlePieces.add(new SavePuzzlePiece(0.25f, 0.8f, coords, triangles, color1, 0));
		
		Color color2 = Color.BLUE;
		puzzlePieces.add(new SavePuzzlePiece(0.25f, 0.5f, coords, triangles, color2, 1));
		
		Color color3 = Color.GREEN;
		puzzlePieces.add(new SavePuzzlePiece(0.25f, 0.2f, coords, triangles, color3, 2));
		
		coords = new float[] {-OX, -OY, -OX + SX1, -OY + SY3, -OX + 2*SX1, -OY, -OX + 2*SX1 - SX2, -OY + SY2, -OX + 2*SX1 + SX3, -OY + SY1 - SY2,
		-OX + SX1 + SX2, -OY + SY1 - SY2, -OX + SX1, -OY + SY1, -OX + SX1 - SX2, -OY + SY1 - SY2, -OX - SX3, -OY + SY1 - SY2, -OX + SX2, -OY + SY2};
		triangles = new int[] {0,6,3, 8,4,1, 2,3,1, 5,7,9};
		Color color4 = Color.YELLOW;
		puzzlePieces.add(new SavePuzzlePiece(0.7f, 0.65f, coords, triangles, color4, 3));
		
		coords = new float[] {-BOX, -BOY, -BOX + 2*BX1, -BOY, -BOX + 2*BX1 + BX2, -BOY + BY2, -BOX + 2*BX1 - BX3, -BOY + BY2, -BOX + BX1, -BOY + BY1, -BOX + BX3, -BOY + BY2, -BOX - BX2, -BOY + BY2};
		triangles = new int[] {0,4,1, 0,6,5, 1,2,3};
		Color color5 = Color.MAGENTA;
		puzzlePieces.add(new SavePuzzlePiece(0.7f, 0.3f, coords, triangles, color5, 4));
		
		coords = new float[] {0, -DOY, DX, -DOY + DY, 0, -DOY + 2*DY, -DX, -DOY + DY};
		triangles = new int[] {0,1,3, 2,1,3};
		Color color6 = Color.CYAN;
		puzzlePieces.add(new SavePuzzlePiece(0.45f, 0.55f, coords, triangles, color6, 5));
		
		
		
		SavePuzzle save = new SavePuzzle(savePieces, puzzlePieces, matches);

		FileHandle saveFile = Gdx.files.local("data/ori_puzzle.txt");
		String saveString = json.toJson(save, SavePuzzle.class);
		saveFile.writeString(saveString, false);
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	private void createOriPuzzle() {
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 6);
		
		int[][][] matches = new int[][][] {{{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,5, 0,1,5,4, 
											 0,1,5,6, 0,1,6,5, 0,1,6,7, 0,1,7,6, 0,1,7,8, 0,1,8,7, 0,1,8,9, 0,1,9,8, 0,1,9,0, 0,1,0,9, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,5, 1,2,5,4, 
											 1,2,5,6, 1,2,6,5, 1,2,6,7, 1,2,7,6, 1,2,7,8, 1,2,8,7, 1,2,8,9, 1,2,9,8, 1,2,9,0, 1,2,0,9, 
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,5, 2,3,5,4, 
											 2,3,5,6, 2,3,6,5, 2,3,6,7, 2,3,7,6, 2,3,7,8, 2,3,8,7, 2,3,8,9, 2,3,9,8, 2,3,9,0, 2,3,0,9, 
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,5, 3,4,5,4, 
											 3,4,5,6, 3,4,6,5, 3,4,6,7, 3,4,7,6, 3,4,7,8, 3,4,8,7, 3,4,8,9, 3,4,9,8, 3,4,9,0, 3,4,0,9, 
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,5, 4,0,5,4, 
											 4,0,5,6, 4,0,6,5, 4,0,6,7, 4,0,7,6, 4,0,7,8, 4,0,8,7, 4,0,8,9, 4,0,9,8, 4,0,9,0, 4,0,0,9},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,5, 0,1,5,4, 0,1,5,6, 0,1,6,5, 0,1,6,0, 0,1,0,6,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,5, 1,2,5,4, 1,2,5,6, 1,2,6,5, 1,2,6,0, 1,2,0,6,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,5, 2,3,5,4, 2,3,5,6, 2,3,6,5, 2,3,6,0, 2,3,0,6,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,5, 3,4,5,4, 3,4,5,6, 3,4,6,5, 3,4,6,0, 3,4,0,6,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,5, 4,0,5,4, 4,0,5,6, 4,0,6,5, 4,0,6,0, 4,0,0,6}, 
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,0, 3,4,0,3,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,0, 4,0,0,3}}, 
												 
										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											 {}, 
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,6,0, 0,1,0,6,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,6,0, 1,2,0,6,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,6,0, 2,3,0,6,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,6,0, 3,4,0,6,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,6,0, 4,0,0,6}, 
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,0, 3,4,0,3,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,0, 4,0,0,3}},
											 
										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,0,0,1, 4,0,1,0, 4,0,1,2, 4,0,2,1, 4,0,2,3, 4,0,3,2, 4,0,3,4, 4,0,4,3, 4,0,4,0, 4,0,0,4},
											 {}, {}, {}},

										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,5,0,1, 4,5,1,0, 4,5,1,2, 4,5,2,1, 4,5,2,3, 4,5,3,2, 4,5,3,4, 4,5,4,3, 4,5,4,0, 4,5,0,4,
											 5,6,0,1, 5,6,1,0, 5,6,1,2, 5,6,2,1, 5,6,2,3, 5,6,3,2, 5,6,3,4, 5,6,4,3, 5,6,4,0, 5,6,0,4,
											 6,7,0,1, 6,7,1,0, 6,7,1,2, 6,7,2,1, 6,7,2,3, 6,7,3,2, 6,7,3,4, 6,7,4,3, 6,7,4,0, 6,7,0,4,
											 7,8,0,1, 7,8,1,0, 7,8,1,2, 7,8,2,1, 7,8,2,3, 7,8,3,2, 7,8,3,4, 7,8,4,3, 7,8,4,0, 7,8,0,4,
											 8,9,0,1, 8,9,1,0, 8,9,1,2, 8,9,2,1, 8,9,2,3, 8,9,3,2, 8,9,3,4, 8,9,4,3, 8,9,4,0, 8,9,0,4,
											 9,0,0,1, 9,0,1,0, 9,0,1,2, 9,0,2,1, 9,0,2,3, 9,0,3,2, 9,0,3,4, 9,0,4,3, 9,0,4,0, 9,0,0,4},
										   	 {}, {}, {}, {}, {}},
											 
										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,4,0,1, 3,4,1,0, 3,4,1,2, 3,4,2,1, 3,4,2,3, 3,4,3,2, 3,4,3,4, 3,4,4,3, 3,4,4,0, 3,4,0,4,
											 4,5,0,1, 4,5,1,0, 4,5,1,2, 4,5,2,1, 4,5,2,3, 4,5,3,2, 4,5,3,4, 4,5,4,3, 4,5,4,0, 4,5,0,4,
											 5,6,0,1, 5,6,1,0, 5,6,1,2, 5,6,2,1, 5,6,2,3, 5,6,3,2, 5,6,3,4, 5,6,4,3, 5,6,4,0, 5,6,0,4,
											 6,0,0,1, 6,0,1,0, 6,0,1,2, 6,0,2,1, 6,0,2,3, 6,0,3,2, 6,0,3,4, 6,0,4,3, 6,0,4,0, 6,0,0,4},
											{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 6,0,0,1, 6,0,1,0, 6,0,1,2, 6,0,2,1, 6,0,2,3, 6,0,3,2, 6,0,3,4, 6,0,4,3, 6,0,4,0, 6,0,0,4},
										   	 {}, {}, {}, {}},	
										   	 
										   {{0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,4, 3,0,4,3, 3,0,4,0, 3,0,0,4},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,4, 0,1,4,3, 0,1,4,0, 0,1,0,4, 
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,4, 1,2,4,3, 1,2,4,0, 1,2,0,4,
											 2,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,4, 2,3,4,3, 2,3,4,0, 2,3,0,4,
											 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,4, 3,0,4,3, 3,0,4,0, 3,0,0,4},
										   	 {}, {}, {}, {}}};
		
		oriPuzzle = new Puzzle(6, puzzlePieces, matches);
		
		float[] coords = new float[] {-X1/2, (-Y1 - Y2)/2, X1/2, (-Y1 - Y2)/2, X1/2 + X2, (Y1 - Y2)/2, -X1/2 + X3, (Y1 + Y2)/2, -X1/2 - X2, (Y1 - Y2)/2};
		int[] triangles = new int[] {0,1,2, 2,3,4, 0,4,2};
		Color color1 = Color.RED;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.25f, 0.8f, coords, 3, triangles, color1, 0));
		
		Color color2 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.25f, 0.5f, coords, 3, triangles, color2, 1));
		
		Color color3 = Color.GREEN;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.25f, 0.2f, coords, 3, triangles, color3, 2));
		
		coords = new float[] {-OX, -OY, -OX + SX1, -OY + SY3, -OX + 2*SX1, -OY, -OX + 2*SX1 - SX2, -OY + SY2, -OX + 2*SX1 + SX3, -OY + SY1 - SY2,
				-OX + SX1 + SX2, -OY + SY1 - SY2, -OX + SX1, -OY + SY1, -OX + SX1 - SX2, -OY + SY1 - SY2, -OX - SX3, -OY + SY1 - SY2, -OX + SX2, -OY + SY2};
		triangles = new int[] {0,6,3, 8,4,1, 2,3,1, 5,7,9};
		Color color4 = Color.YELLOW;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.7f, 0.65f, coords, 4, triangles, color4, 3));
		
		coords = new float[] {-BOX, -BOY, -BOX + 2*BX1, -BOY, -BOX + 2*BX1 + BX2, -BOY + BY2, -BOX + 2*BX1 - BX3, -BOY + BY2, -BOX + BX1, -BOY + BY1, -BOX + BX3, -BOY + BY2, -BOX - BX2, -BOY + BY2};
		triangles = new int[] {0,4,1, 0,6,5, 1,2,3};
		Color color5 = Color.MAGENTA;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.7f, 0.3f, coords, 3, triangles, color5, 4));
		
		coords = new float[] {0, -DOY, DX, -DOY + DY, 0, -DOY + 2*DY, -DX, -DOY + DY};
		triangles = new int[] {0,1,3, 2,1,3};
		Color color6 = Color.CYAN;
		puzzlePieces.add(new PuzzlePiece(oriPuzzle, 0.45f, 0.55f, coords, 2, triangles, color6, 5));
		
		oriPuzzle.initiate();
	}
	
	
	
	
	
	
	
	
	
	
	
		private void createRhombPuzzle() {
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 2);
		
		int[][][] matches = new int[][][] {{{0,1,0,3, 0,3,0,1, 1,2,3,2, 3,2,1,2}, {0,1,3,2, 0,3,3,0, 1,2,1,0, 3,2,1,2}},
				 {{3,2,0,1, 3,0,0,3, 1,0,1,2, 1,2,3,2}, {0,1,2,1, 2,1,0,1, 0,3,2,3, 2,3,0,3}}};
		
		rhombPuzzle = new Puzzle(2, puzzlePieces, matches);
		
		float[] coords = new float[] {(-WIDTH - LSLIDE)/2, -LHEIGHT/2, (WIDTH - LSLIDE)/2, -LHEIGHT/2, (WIDTH + LSLIDE)/2, LHEIGHT/2, (-WIDTH + LSLIDE)/2, LHEIGHT/2};
		int[] triangles = new int[] {0,1,2, 0,3,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(rhombPuzzle, 0.33f, 0.5f, coords, 2, triangles, color1, 0));
		
		coords = new float[] {(-WIDTH - SSLIDE)/2, -SHEIGHT/2, (WIDTH - SSLIDE)/2, -SHEIGHT/2, (WIDTH + SSLIDE)/2, SHEIGHT/2, (-WIDTH + SSLIDE)/2, SHEIGHT/2};
		triangles = new int[] {0,1,2, 0,3,2};
		Color color2 = Color.CYAN;
		puzzlePieces.add(new PuzzlePiece(rhombPuzzle, 0.66f, 0.5f, coords, 2, triangles, color2, 1));
		
		rhombPuzzle.initiate();
	}
	
	
	
	
	
	
	
	
		private void createKiteDartPuzzle() {
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 2);
		
		int[][][] matches = new int[][][] {{{1,2,1,2, 1,2,3,2, 2,3,2,3, 2,3,2,1, 0,1,0,1, 0,1,0,3, 0,3,0,3, 0,3,0,1}, 
											{0,1,1,0, 0,1,3,0, 0,3,1,0, 0,3,3,0, 2,1,1,2, 2,1,3,2, 2,3,1,2, 2,3,3,2}},
											
				 						   {{0,1,1,0, 0,1,3,0, 0,3,1,0, 0,3,3,0, 2,1,1,2, 2,1,3,2, 2,3,1,2, 2,3,3,2}, 
										    {0,1,0,1, 0,1,0,3, 0,3,0,3, 0,3,0,1}}};
		
		kiteDartPuzzle = new Puzzle(2, puzzlePieces, matches);
		
		float[] coords = new float[] {-KOX, -KOY + KY, -KOX + KX1, -KOY, -KOX + KX2, -KOY + KY, -KOX + KX1, -KOY + 2*KY};
		int[] triangles = new int[] {0,1,2, 0,3,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(kiteDartPuzzle, 0.33f, 0.5f, coords, 2, triangles, color1, 0));
		
		coords = new float[] {-DaOX + DaX1, -DaOY + DaY, -DaOX , -DaOY, -DaOX + DaX2, -DaOY + DaY, -DaOX, -DaOY + 2*DaY};
		triangles = new int[] {0,1,2, 0,3,2};
		Color color2 = Color.CYAN;
		puzzlePieces.add(new PuzzlePiece(kiteDartPuzzle, 0.66f, 0.5f, coords, 2, triangles, color2, 1));
		
		kiteDartPuzzle.initiate();
	}
	
	
	
	
	
	
	
		private void createPixelPuzzle() {
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 1);
		
		int[][][] matches = new int[][][] {{{0,1,3,2, 1,2,0,3, 3,2,0,1, 0,3,1,2}}};
		
		pixelPuzzle = new ColourPuzzle(1, puzzlePieces, matches);
		
		float[] coords = new float[] {-SQUARE, -SQUARE, SQUARE, -SQUARE, SQUARE, SQUARE, -SQUARE, SQUARE};
		int[] triangles = new int[] {0,1,2, 0,3,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(pixelPuzzle, 0.25f, 0.5f, coords, 2, triangles, color1, 0));
		
		pixelPuzzle.initiate();
	}
	
	
	
	
	
	
		private void createClassicPuzzle() {
		
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 10);
		
		int[][][] matches = new int[][][] {{{0,1,0,1, 0,1,1,0, 0,1,2,0, 0,1,0,2,
											 1,2,1,2, 1,2,2,1,
											 2,0,0,1, 2,0,1,0, 2,0,2,0, 2,0,0,2},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 2,0,0,1, 2,0,1,0, 2,0,1,2, 2,0,2,1, 2,0,2,3, 2,0,3,2, 2,0,3,0, 2,0,0,3}},
											 
										   {{0,1,0,1, 0,1,1,0, 0,1,2,0, 0,1,0,2,
											 1,2,0,1, 1,2,1,0, 1,2,2,0, 1,2,0,2,
											 2,3,0,1, 2,3,1,0, 2,3,2,0, 2,3,0,2,
											 3,0,0,1, 3,0,1,0, 3,0,2,0, 3,0,0,2},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
											 3,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
											 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,0, 3,0,0,3}}};

		
		classicPuzzle = new OriginalPuzzle(10, puzzlePieces, matches);
		

		
		float[] coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		int[] triangles = new int[] {0,1,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.15f, 0.7f, coords, 1, triangles, color1, 0));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color2 = Color.GREEN;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.35f, 0.7f, coords, 1, triangles, color2, 1));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color3 = Color.YELLOW;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.15f, 0.45f, coords, 1, triangles, color3, 2));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color4 = Color.RED;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.35f, 0.45f, coords, 1, triangles, color4, 3));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color5 = Color.CYAN;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.15f, 0.2f, coords, 1, triangles, color5, 4));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color6 = Color.MAGENTA;
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.35f, 0.2f, coords, 1, triangles, color6, 5));
		
		
		coords = new float[] {-(SQUARE + RY)/2, -RY/2, (SQUARE - RY)/2, -RY/2, (SQUARE + RY)/2, RY/2, (RY - SQUARE)/2, RY/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.6f, 0.7f, coords, 2, triangles, color1, 6));
		
		coords = new float[] {-(SQUARE + RY)/2, -RY/2, (SQUARE - RY)/2, -RY/2, (SQUARE + RY)/2, RY/2, (RY - SQUARE)/2, RY/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.8f, 0.7f, coords, 2, triangles, color2, 7));
		
		coords = new float[] {-(SQUARE + RY)/2, -RY/2, (SQUARE - RY)/2, -RY/2, (SQUARE + RY)/2, RY/2, (RY - SQUARE)/2, RY/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.6f, 0.45f, coords, 2, triangles, color3, 8));
		
		coords = new float[] {-(SQUARE + RY)/2, -RY/2, (SQUARE - RY)/2, -RY/2, (SQUARE + RY)/2, RY/2, (RY - SQUARE)/2, RY/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new PuzzlePiece(classicPuzzle, 0.8f, 0.45f, coords, 2, triangles, color4, 9));
		
		classicPuzzle.initiate();
	}
	
	
	
	
	
	
	
	
		private void createReflectPuzzle(int ref) {
		
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 10);
		
		int[][][] matches = new int[][][] {{{0,1,0,1, 0,1,1,0, 0,1,2,0, 0,1,0,2,
											 1,2,1,2, 1,2,2,1,
											 2,0,0,1, 2,0,1,0, 2,0,2,0, 2,0,0,2},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 2,0,0,1, 2,0,1,0, 2,0,1,2, 2,0,2,1, 2,0,2,3, 2,0,3,2, 2,0,3,0, 2,0,0,3}},
											 
										   {{0,1,0,1, 0,1,1,0, 0,1,2,0, 0,1,0,2,
											 1,2,0,1, 1,2,1,0, 1,2,2,0, 1,2,0,2,
											 2,3,0,1, 2,3,1,0, 2,3,2,0, 2,3,0,2,
											 3,0,0,1, 3,0,1,0, 3,0,2,0, 3,0,0,2},
										    {0,1,0,1, 0,1,1,0, 0,1,1,2, 0,1,2,1, 0,1,2,3, 0,1,3,2, 0,1,3,0, 0,1,0,3,
											 1,2,0,1, 1,2,1,0, 1,2,1,2, 1,2,2,1, 1,2,2,3, 1,2,3,2, 1,2,3,0, 1,2,0,3,
											 3,3,0,1, 2,3,1,0, 2,3,1,2, 2,3,2,1, 2,3,2,3, 2,3,3,2, 2,3,3,0, 2,3,0,3,
											 3,0,0,1, 3,0,1,0, 3,0,1,2, 3,0,2,1, 3,0,2,3, 3,0,3,2, 3,0,3,0, 3,0,0,3}}};

		
		reflectPuzzle = new ReflectPuzzle(10, puzzlePieces, matches);
		

		
		float[] coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		int[] triangles = new int[] {0,1,2};
		Color color1 = Color.BLUE;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.15f, 0.7f, coords, 1, triangles, color1, 0, ref, SQUARE/3, SQUARE/3));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color2 = Color.GREEN;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.35f, 0.7f, coords, 1, triangles, color2, 1, ref, SQUARE/3, SQUARE/3));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color3 = Color.YELLOW;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.15f, 0.45f, coords, 1, triangles, color3, 2, ref, SQUARE/3, SQUARE/3));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color4 = Color.RED;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.35f, 0.45f, coords, 1, triangles, color4, 3, ref, SQUARE/3, SQUARE/3));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color5 = Color.CYAN;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.15f, 0.2f, coords, 1, triangles, color5, 4, ref, SQUARE/3, SQUARE/3));
		
		coords = new float[] {-SQUARE/3, -SQUARE/3, 2*SQUARE/3, -SQUARE/3, -SQUARE/3, 2*SQUARE/3};
		triangles = new int[] {0,1,2};
		Color color6 = Color.MAGENTA;
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.35f, 0.2f, coords, 1, triangles, color6, 5, ref, SQUARE/3, SQUARE/3));
		
		
		coords = new float[] {-(SQUARE + RY)/2, -RY/2, (SQUARE - RY)/2, -RY/2, (SQUARE + RY)/2, RY/2, (RY - SQUARE)/2, RY/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.6f, 0.7f, coords, 2, triangles, color1, 6, ref, (SQUARE + RY)/2, RY/2));
		
		coords = new float[] {-(SQUARE + RY)/2, -RY/2, (SQUARE - RY)/2, -RY/2, (SQUARE + RY)/2, RY/2, (RY - SQUARE)/2, RY/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.8f, 0.7f, coords, 2, triangles, color2, 7, ref, (SQUARE + RY)/2, RY/2));
		
		coords = new float[] {-(SQUARE + RY)/2, -RY/2, (SQUARE - RY)/2, -RY/2, (SQUARE + RY)/2, RY/2, (RY - SQUARE)/2, RY/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.6f, 0.45f, coords, 2, triangles, color3, 8, ref, (SQUARE + RY)/2, RY/2));
		
		coords = new float[] {-(SQUARE + RY)/2, -RY/2, (SQUARE - RY)/2, -RY/2, (SQUARE + RY)/2, RY/2, (RY - SQUARE)/2, RY/2};
		triangles = new int[] {0,1,2, 0,3,2};
		puzzlePieces.add(new ReflectPuzzlePiece(reflectPuzzle, 0.8f, 0.45f, coords, 2, triangles, color4, 9, ref, (SQUARE + RY)/2, RY/2));
		
		reflectPuzzle.initiate();
	}
	
	
	
	
	
	





----- 03.03.14 ----- 

-------------- BUGFIX --------------

Loading ReflectPieces does not work.		

There were a couple of issues, firstly, since I was using == and not .equals() when comparing strings, the Classic, Reflect and Pixel puzzles were
not being started with the correct WorldRenderer. 
The updated code looks like this:

	public void play() {
		Puzzle puzzle = puzzles.get(gameMode);
		
		if (gameMode.equals(CLASSIC) || gameMode.equals(REFLECT))
			setScreen(new StaticGameScreen(this, puzzle));
		else if (gameMode.equals(PIXELS))
			setScreen(new ColourGameScreen(this, puzzle));
		else 	
			setScreen(new GameScreen(this, puzzle));
	}


Secondly, the loading method needed to be overridden in the ReflectPuzzle class, since the creation of ReflectPieces involves a translation and
this interferes with the 'create, rotate and translate' method of loading pieces. The solution was to use a new create method, which called a new
creation method in the ReflectPuzzlePiece, this method differs only in that it performs no translation, and calls spawn() rather than spawn_().


	@Override
	public void load(Array<SavePiece> savePieces) {
		Iterator<SavePiece> iter = savePieces.iterator();
		SavePiece s;
		Piece p;
		while (iter.hasNext()) {
			s = iter.next();
			p = createLoad(s.id);
			p.rotate(s.rot);
			p.translateWOC(s.transX, s.transY);
		}
	}
	
	private Piece createLoad(int id) {
		ReflectPuzzlePiece pp = (ReflectPuzzlePiece) puzzlePieces.get(id);
		return pp.createLoad();
	}


And the ReflectPuzzlePiece method:

	public ReflectPiece createLoad() {
		Polygon temp;
		Polygon polygon;
		Array<Polygon> tris = new Array<Polygon> (false, noTriangles);
		
		polygon = new Polygon(coords);
		for (int i = 0; i < noTriangles; i++) {
			temp = new Polygon(new float[] {coords[triangles[3*i]*2], coords[triangles[3*i]*2 + 1], coords[triangles[3*i + 1]*2], coords[triangles[3*i + 1]*2 + 1],
													coords[triangles[3*i + 2]*2], coords[triangles[3*i + 2]*2 + 1]});
			tris.add(temp);
		}
		
		Array<ReflectPiece> refPieces = new Array<ReflectPiece>(false, 4);
		ReflectPiece piece =  new ReflectPiece(puzzle, polygon, tris, 0, color, id, 0, MozaicPlayer.trans, ref, refPieces);
		
		createReflections(refPieces);
		
		piece.spawn();
		return piece;
	}
	
	
Finally, the save() method needed to be overriden, I had forgotten to change the save method so that it only saves those pieces which are used
to define the reflections, the method is now as follows:

	@Override
	public Array<SavePiece> save() {
		Iterator<Piece> iter = getIterator();
		Piece p;
		Array<SavePiece> savePieces = new Array<SavePiece>(pieces.size);
		while (iter.hasNext()) {
			p = iter.next();
			if (((ReflectPiece) p).getRefs().first() == p)
				savePieces.add(new SavePiece(p.getID(), p.getTransX(), p.getTransY(), p.getRotation()));
		}
		return savePieces;
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	private FlickPuzzle createFlickPuzzle() {
		Array<PuzzlePiece> puzzlePieces = new Array<PuzzlePiece>(false, 6);

		int[][][] matches = new int[][][] {
				{
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 0, 4, 0, 0, 4 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 0, 4, 0, 0, 4 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 0, 4, 0, 0, 4 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 5, 0, 1, 5, 4, 0, 1, 5, 6, 0, 1, 6, 5, 0, 1,
								6, 7, 0, 1, 7, 6, 0, 1, 7, 8, 0, 1, 8, 7, 0, 1,
								8, 9, 0, 1, 9, 8, 0, 1, 9, 0, 0, 1, 0, 9, 1, 2,
								0, 1, 1, 2, 1, 0, 1, 2, 1, 2, 1, 2, 2, 1, 1, 2,
								2, 3, 1, 2, 3, 2, 1, 2, 3, 4, 1, 2, 4, 3, 1, 2,
								4, 5, 1, 2, 5, 4, 1, 2, 5, 6, 1, 2, 6, 5, 1, 2,
								6, 7, 1, 2, 7, 6, 1, 2, 7, 8, 1, 2, 8, 7, 1, 2,
								8, 9, 1, 2, 9, 8, 1, 2, 9, 0, 1, 2, 0, 9, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 5, 2, 3, 5, 4, 2, 3, 5, 6, 2, 3, 6, 5, 2, 3,
								6, 7, 2, 3, 7, 6, 2, 3, 7, 8, 2, 3, 8, 7, 2, 3,
								8, 9, 2, 3, 9, 8, 2, 3, 9, 0, 2, 3, 0, 9, 3, 4,
								0, 1, 3, 4, 1, 0, 3, 4, 1, 2, 3, 4, 2, 1, 3, 4,
								2, 3, 3, 4, 3, 2, 3, 4, 3, 4, 3, 4, 4, 3, 3, 4,
								4, 5, 3, 4, 5, 4, 3, 4, 5, 6, 3, 4, 6, 5, 3, 4,
								6, 7, 3, 4, 7, 6, 3, 4, 7, 8, 3, 4, 8, 7, 3, 4,
								8, 9, 3, 4, 9, 8, 3, 4, 9, 0, 3, 4, 0, 9, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 5, 4, 0, 5, 4, 4, 0, 5, 6, 4, 0, 6, 5, 4, 0,
								6, 7, 4, 0, 7, 6, 4, 0, 7, 8, 4, 0, 8, 7, 4, 0,
								8, 9, 4, 0, 9, 8, 4, 0, 9, 0, 4, 0, 0, 9 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 5, 0, 1, 5, 4, 0, 1, 5, 6, 0, 1, 6, 5, 0, 1,
								6, 0, 0, 1, 0, 6, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 5, 1, 2, 5, 4, 1, 2,
								5, 6, 1, 2, 6, 5, 1, 2, 6, 0, 1, 2, 0, 6, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 5, 2, 3, 5, 4, 2, 3, 5, 6, 2, 3, 6, 5, 2, 3,
								6, 0, 2, 3, 0, 6, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 5, 3, 4, 5, 4, 3, 4,
								5, 6, 3, 4, 6, 5, 3, 4, 6, 0, 3, 4, 0, 6, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 5, 4, 0, 5, 4, 4, 0, 5, 6, 4, 0, 6, 5, 4, 0,
								6, 0, 4, 0, 0, 6 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 0, 0, 1, 0, 3, 1, 2,
								0, 1, 1, 2, 1, 0, 1, 2, 1, 2, 1, 2, 2, 1, 1, 2,
								2, 3, 1, 2, 3, 2, 1, 2, 3, 0, 1, 2, 0, 3, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 0, 2, 3, 0, 3, 3, 4,
								0, 1, 3, 4, 1, 0, 3, 4, 1, 2, 3, 4, 2, 1, 3, 4,
								2, 3, 3, 4, 3, 2, 3, 4, 3, 0, 3, 4, 0, 3, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 0, 4, 0, 0, 3 } },

				{
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 0, 4, 0, 0, 4 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 0, 4, 0, 0, 4 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 0, 4, 0, 0, 4 },
						{},
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								6, 0, 0, 1, 0, 6, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 6, 0, 1, 2, 0, 6, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								6, 0, 2, 3, 0, 6, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 6, 0, 3, 4, 0, 6, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								6, 0, 4, 0, 0, 6 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 0, 0, 1, 0, 3, 1, 2,
								0, 1, 1, 2, 1, 0, 1, 2, 1, 2, 1, 2, 2, 1, 1, 2,
								2, 3, 1, 2, 3, 2, 1, 2, 3, 0, 1, 2, 0, 3, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 0, 2, 3, 0, 3, 3, 4,
								0, 1, 3, 4, 1, 0, 3, 4, 1, 2, 3, 4, 2, 1, 3, 4,
								2, 3, 3, 4, 3, 2, 3, 4, 3, 0, 3, 4, 0, 3, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 0, 4, 0, 0, 3 } },

				{
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 0, 4, 0, 0, 4 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 0, 4, 0, 0, 4 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 0,
								0, 1, 4, 0, 1, 0, 4, 0, 1, 2, 4, 0, 2, 1, 4, 0,
								2, 3, 4, 0, 3, 2, 4, 0, 3, 4, 4, 0, 4, 3, 4, 0,
								4, 0, 4, 0, 0, 4 }, {}, {}, {} },

				{
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 5,
								0, 1, 4, 5, 1, 0, 4, 5, 1, 2, 4, 5, 2, 1, 4, 5,
								2, 3, 4, 5, 3, 2, 4, 5, 3, 4, 4, 5, 4, 3, 4, 5,
								4, 0, 4, 5, 0, 4, 5, 6, 0, 1, 5, 6, 1, 0, 5, 6,
								1, 2, 5, 6, 2, 1, 5, 6, 2, 3, 5, 6, 3, 2, 5, 6,
								3, 4, 5, 6, 4, 3, 5, 6, 4, 0, 5, 6, 0, 4, 6, 7,
								0, 1, 6, 7, 1, 0, 6, 7, 1, 2, 6, 7, 2, 1, 6, 7,
								2, 3, 6, 7, 3, 2, 6, 7, 3, 4, 6, 7, 4, 3, 6, 7,
								4, 0, 6, 7, 0, 4, 7, 8, 0, 1, 7, 8, 1, 0, 7, 8,
								1, 2, 7, 8, 2, 1, 7, 8, 2, 3, 7, 8, 3, 2, 7, 8,
								3, 4, 7, 8, 4, 3, 7, 8, 4, 0, 7, 8, 0, 4, 8, 9,
								0, 1, 8, 9, 1, 0, 8, 9, 1, 2, 8, 9, 2, 1, 8, 9,
								2, 3, 8, 9, 3, 2, 8, 9, 3, 4, 8, 9, 4, 3, 8, 9,
								4, 0, 8, 9, 0, 4, 9, 0, 0, 1, 9, 0, 1, 0, 9, 0,
								1, 2, 9, 0, 2, 1, 9, 0, 2, 3, 9, 0, 3, 2, 9, 0,
								3, 4, 9, 0, 4, 3, 9, 0, 4, 0, 9, 0, 0, 4 }, {},
						{}, {}, {}, {} },

				{
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 4, 0, 1, 3, 4, 1, 0, 3, 4,
								1, 2, 3, 4, 2, 1, 3, 4, 2, 3, 3, 4, 3, 2, 3, 4,
								3, 4, 3, 4, 4, 3, 3, 4, 4, 0, 3, 4, 0, 4, 4, 5,
								0, 1, 4, 5, 1, 0, 4, 5, 1, 2, 4, 5, 2, 1, 4, 5,
								2, 3, 4, 5, 3, 2, 4, 5, 3, 4, 4, 5, 4, 3, 4, 5,
								4, 0, 4, 5, 0, 4, 5, 6, 0, 1, 5, 6, 1, 0, 5, 6,
								1, 2, 5, 6, 2, 1, 5, 6, 2, 3, 5, 6, 3, 2, 5, 6,
								3, 4, 5, 6, 4, 3, 5, 6, 4, 0, 5, 6, 0, 4, 6, 0,
								0, 1, 6, 0, 1, 0, 6, 0, 1, 2, 6, 0, 2, 1, 6, 0,
								2, 3, 6, 0, 3, 2, 6, 0, 3, 4, 6, 0, 4, 3, 6, 0,
								4, 0, 6, 0, 0, 4 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 6, 0,
								0, 1, 6, 0, 1, 0, 6, 0, 1, 2, 6, 0, 2, 1, 6, 0,
								2, 3, 6, 0, 3, 2, 6, 0, 3, 4, 6, 0, 4, 3, 6, 0,
								4, 0, 6, 0, 0, 4 }, {}, {}, {}, {} },

				{
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 0, 0, 1, 3, 0, 1, 0, 3, 0,
								1, 2, 3, 0, 2, 1, 3, 0, 2, 3, 3, 0, 3, 2, 3, 0,
								3, 4, 3, 0, 4, 3, 3, 0, 4, 0, 3, 0, 0, 4 },
						{ 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 2, 0, 1, 2, 1, 0, 1,
								2, 3, 0, 1, 3, 2, 0, 1, 3, 4, 0, 1, 4, 3, 0, 1,
								4, 0, 0, 1, 0, 4, 1, 2, 0, 1, 1, 2, 1, 0, 1, 2,
								1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 2, 3, 2, 1, 2,
								3, 4, 1, 2, 4, 3, 1, 2, 4, 0, 1, 2, 0, 4, 2, 3,
								0, 1, 2, 3, 1, 0, 2, 3, 1, 2, 2, 3, 2, 1, 2, 3,
								2, 3, 2, 3, 3, 2, 2, 3, 3, 4, 2, 3, 4, 3, 2, 3,
								4, 0, 2, 3, 0, 4, 3, 0, 0, 1, 3, 0, 1, 0, 3, 0,
								1, 2, 3, 0, 2, 1, 3, 0, 2, 3, 3, 0, 3, 2, 3, 0,
								3, 4, 3, 0, 4, 3, 3, 0, 4, 0, 3, 0, 0, 4 }, {},
						{}, {}, {} } };

		FlickPuzzle flickPuzzle = new FlickPuzzle(6, puzzlePieces, matches, true);

		float[] coords = new float[] { -X1 / 2, (-Y1 - Y2) / 2, X1 / 2,
				(-Y1 - Y2) / 2, X1 / 2 + X2, (Y1 - Y2) / 2, -X1 / 2 + X3,
				(Y1 + Y2) / 2, -X1 / 2 - X2, (Y1 - Y2) / 2 };
		int[] triangles = new int[] { 0, 1, 2, 2, 3, 4, 0, 4, 2 };
		Color color1 = Color.RED;
		puzzlePieces.add(new FlickPuzzlePiece(flickPuzzle, 0.25f, 0.8f, coords, 3,
				triangles, color1, 0, 2));

		Color color2 = Color.BLUE;
		puzzlePieces.add(new FlickPuzzlePiece(flickPuzzle, 0.25f, 0.5f, coords, 3,
				triangles, color2, 1, 2));

		Color color3 = Color.GREEN;
		puzzlePieces.add(new FlickPuzzlePiece(flickPuzzle, 0.25f, 0.2f, coords, 3,
				triangles, color3, 2, 2));

		coords = new float[] { -OX, -OY, -OX + SX1, -OY + SY3, -OX + 2 * SX1,
				-OY, -OX + 2 * SX1 - SX2, -OY + SY2, -OX + 2 * SX1 + SX3,
				-OY + SY1 - SY2, -OX + SX1 + SX2, -OY + SY1 - SY2, -OX + SX1,
				-OY + SY1, -OX + SX1 - SX2, -OY + SY1 - SY2, -OX - SX3,
				-OY + SY1 - SY2, -OX + SX2, -OY + SY2 };
		triangles = new int[] { 0, 6, 3, 8, 4, 1, 2, 3, 1, 5, 7, 9 };
		Color color4 = Color.YELLOW;
		puzzlePieces.add(new FlickPuzzlePiece(flickPuzzle, 0.7f, 0.65f, coords, 4,
				triangles, color4, 3, 3));

		coords = new float[] { -BOX, -BOY, -BOX + 2 * BX1, -BOY,
				-BOX + 2 * BX1 + BX2, -BOY + BY2, -BOX + 2 * BX1 - BX3,
				-BOY + BY2, -BOX + BX1, -BOY + BY1, -BOX + BX3, -BOY + BY2,
				-BOX - BX2, -BOY + BY2 };
		triangles = new int[] { 0, 4, 1, 0, 6, 5, 1, 2, 3 };
		Color color5 = Color.MAGENTA;
		puzzlePieces.add(new FlickPuzzlePiece(flickPuzzle, 0.7f, 0.3f, coords, 3,
				triangles, color5, 4, 2));

		coords = new float[] { 0, -DOY, DX, -DOY + DY, 0, -DOY + 2 * DY, -DX,
				-DOY + DY };
		triangles = new int[] { 0, 1, 3, 2, 1, 3 };
		Color color6 = Color.CYAN;
		puzzlePieces.add(new FlickPuzzlePiece(flickPuzzle, 0.45f, 0.55f, coords, 2,
				triangles, color6, 5, 1));

		flickPuzzle.initiate();
		return flickPuzzle;
	}
	
	
	
	
	
	
	
	
-------------- BOUNCING PUZZLE --------------
	
Mostly implemented, the physics needs some bugfixing, the area needs to be larger, more pieces need to be available, gravity should be adjustable.
Don't forget to make it so there are no issues with releasing the mouse in the black area.

SNAPSHOT 0.4.2	

Lots of issues fixed, including the aformentioned releasing of the mouse in the black area. The same mechanism used for this ensures pieces released while overlapping
the edge of the screen are deleted after a time, to save memory. I also fixed a bug caused by pieces not tracking if they are touching the edge of the screen, meaning they
would repeatedly detect collisions with the walls and move back and forward infinitely. 
I also changed the way the collision of pieces works, so that only one of the two pieces performs the calculation.
In FlickPuzzle I overrode snap and overlaps. The changes to snap mean that the piece that is snapped to also has it's velocity etc. set to 0. The changes to overlaps
were just to ensure that the piece does not overlap the edges either.

The only noticable remaining bug is that pieces regularly overlap when snapping is performed (might have been fixed?).

Include velocity cap? Include rotation cap? Make rotation setting easier, just by swiping left/right?	
			


 
-------------- IDEAS --------------

For deciding what to snap to, have a 'state' enumeration variable which decides based on the type of shape and current rotation.
8 triangle states, 4 rhombus states.

Could have a class / classes which take / hold the state and take the coordinates of the object and decide what to do.

Snap to between pieces - if edges are close enough? Search for compatible pieces in locations?

It might be better to implement corner snapping in a similar manner to edge snapping, and/or possibly combine the two processes.

I want to change the way overlapping happens, not just collide, bounce back on release...
Perhaps move a faded shape and then move the actual shape on release.

The behaviour of the dragging still needs to be changed slightly, on release I would like the piece to be snapped to any nearby suitable positions
This might be a good thing to put in the translate method, and also in the rotation method. It will be necessary to make sure the snap-to doesn't
leave the translated piece overlapping a third piece.

Sound effect on shape release. Seperate sound effects for successful and unsuccessful?

Make game work on devices with differing resolutions:
	retrieve using Gdx.graphics.getWidth()...
	
Have shapes ready to be dragged onto main screen at bottom, 'dragging' a shape and not leaving
the white area results in the shape being rotated 90 degrees. 

Dragging a shape from the main screen to the bottom area results in the shape being 'deleted' and
if we allow finite shapes to be chosen, a shape of that kind is added to the pile.

Need to get new open source sound effects. Create own in sfxr?
Create successful non-snap drag sound, rotation sound, fail sound, deletion sound.

Examine how polygons are implemented, debug, make reflection.

Need to update SnapTo to work with symmetries > 4 

Stop pieces from being picked up from underMouse() when they are not yet spawned.

Update SnapTo to deal with RefRhombus.

Could implement SnapTo as returning the value that the dragging object needs to be translated by, rather
than performing the translation itself and simply returning a boolean.

Abstract methods from RefTriangle and RefRhombus into a RefPiece class extending ClassicPiece.

Have replace take dragging as an argument, and have a replace(PenrosePiece piece), replace(ClassicPiece piece) etc...

Create zoom for Penrose puzzle, use libgdx camera features?

Make sprites with lines representing possible penrose matches instead of drawing triangles.

All Penrose games (those with free rotation) currently allow rotation to create overlapping shapes, I would
prefer different behaviour.

Create new main menu, allowing full functionality.

Allow the options to be changed during game.

Buttons etc need to be a function of device size, rather than fixed sizes.

Implement session saving.

Change so that instead of Play we have Resume when a session has begun and not been reset.

Need to implement camera scrolling.

---- (0.2.3 REHAUL START) ----

Extra polygon to allow a standard method for getVerts().

Move most of the 'constructing' to higher levels (the Piece class).

OriginalPiece can have different draw method, use null/empty Array for triangles.

Define OriginalPieces with 'Penrose camera' except with zoom/scroll disabled.

---- (0.2.3 REHAUL END) ----

Improve SnapTo by eliminating shapes that are obviously too far away, e.g. take a sample vertex and ignore if far enough away.

Overlaps should ignore pieces clearly too far away, just as SnapTo should.

Parameterise snapping and move to Piece class.

---- (0.3.1 OVERHAUL START) ----

Work out precisely what is required to define each shape, e.g. angles/lengths.
Define methods which take this input and create the shapes.
Figure out how to convert a text file.

Generic shape file (main issue so far seems to be the SnapTo definitions (could maybe require that a group of shapes are defined instead,
including their interactions?)).

Lots of square pieces, pixellated picture...

ReflectPiece needs alternate snapping??

---- (0.3.1 OVERHAUL END) ----

Free float method, choose (penrose) piece, set rotation, set velocity, bounces around until it reaches another shape and they snap together.
Each piece performs a timestep and then the snapping/bouncing calculations run.

Get Rhombs working with sprites again.

Only need to apply texture filters once per texture??


--


TOM'S IDEAS (REPORT)

Literature on game creation techniques, android techniques.

User evaluations, add to android market and give to James/Steven/Phoebe etc.

--


GERAINT'S IDEAS (PROBABLY WON'T DO; ALTHOUGH HAVE A LOOK IF FEASIBLE...)

Make own implementation instead of translation and rotation using polygons
e.g. have a set of vertices and these are shared by the polygons and used in getVerts

--

Integrate the new puzzles with the rest. **DONE**
[0.5.0]


Implement android controls. **DONE BUT NOT TESTED**




rotation somewhat works, but needs behaviour at the end of rotation **DONE** - could have the inputhandler behaviour only under touchup???
rotation also needs to be disabled for the pixel puzzle - and enabled for the flicking puzzle **DONE**

zooming seems to work, but only for the original penrose puzzle **DONE**
AT THE TIME THE GESTURELISTENER IS INITIATED, THE PUZZLE'S WORLD RENDERER IS THE INCORRECT ONE! DERPDERPDERPDERP

the most recently dragged piece can be dragged from anywhere on the screen -- actually just panning -_-

rotating seems to 'clone' the piece... I believe this is to do with the input initially being perceived as a drag by InputHandler, before being blocked by the GestureListener **FIXED**
when rotating it is possible to move a second piece with the second finger...
SPECIFICS: 
if a piece is being dragged and then the second finger is put on an a second piece in order to begin rotating the first piece,
the first piece duplicates and breaks the game.
when placing the first finger on blank space, then placing the second finger on a piece in order to zoom, the second piece 
moves around as if being dragged.
*BOTH FIXED* 		if (pointer == 0) { ...


Then put it all together with proper behaviour, add reset button (under Settings?) which resets the save file and puzzles.
Perform quick bug check then distribute.



***
Issues with reflect puzzle and flick puzzle - going ahead with distribution plans
***



create new splash screen. -- May not bother having a splash screen at all...

Rotational symmetries...?

Find new music?? Probably not.



Allow loading of user defined puzzles?
Create Helper program which creates puzzles?
[0.6.0]


Should we override the rotation methods in OriginalPiece as well?
Should we override methods at all?

Calculate precise dMax for optimisation, analyse usefulness of change from 'naive' implementation to this one.

Store maxSnap in the matches array?



*** MUSINGS ***

Need to make it so the limits on the number of pieces are enforced when loading a Classic game.
Or do I...? One could argue that the only reason the pieces were limited in the original puzzle was because having excess pieces
would be rather pointless and induce an extra cost. However with a virtual puzzle, it actually saves cost to not limit the number
of each piece allowed to be used in a puzzle.

The lines show additional impossible placements, which my SnapTo code does not account for. However, I feel there is no better way
to implement this than I have currently done. It would be useful to have a check that both sides of the shape match up, but hard to
implement, and hardly necessary. It would be possible to eliminate some snappings altogether, since they never result in a larger
shape being 'creatable', however I think removing those would be confusing to users and detrimental to the game.

ReflectPiece messy, very different from other puzzles.

Check for incompatible bordering on e.g. penrose P1?

WHAT ABOUT IF WE SNAP TO A NON-REFPIECE PIECE AND ALSO A REFPIECE...?
SHOULD BE FINE AS LONG AS WE PRIORITISE SNAPPING TO NON-REFPIECE...

Have an instance of the Puzzle class for each game mode. Store in MozaicPlayer. Puzzle class has much of the static behaviour
that Piece had (but not static, obviously). Piece is a concrete class. PuzzlePiece is like the factory classes for the pieces.

Talk about converting floats to decimals and back (when saving/loading to/from a text file), and why this is so insignificant it is okay. (mention zoom limit)

Talk about the possibilities of allowing pieces to snap together if they have sides of matching length, removing the requirement of the 3D array.

Test for memory leakage on (in particular) the FlickPuzzle.


*** NO LONGER RELEVANT ***

RhombLarge and RhombSmall have essentially identical code. Is it worth having 2 separate classes??

The constructor which takes origins is identical for all classes (not used by ref classes), and therefore could be abstracted to Piece.
If not, it could be changed to private.

Have an abstract class for convex pieces? Probably not, can only extend from a single class.

Could use same method used for replace for snap()...

Does SnapTo only require snap4x, since y always appears to happen first???
Why do we have to multiply the value by 2 in snap4_??


*** COMPLEX AND COMPUTATIONALLY EXPENSIVE - PROBABLY WON'T IMPLEMENT ***
Look into 3D gfx.


*** DIFFICULT IN CURRENT MODEL - PROBABLY WON'T IMPLEMENT ***
Consider having asymmetric and symmetric pieces in same 'world', would require SnapTo to check each reflected piece.
			
Have a lock/unlock button, which makes connected polygons act as a single object/separate objects.

-------------- BUGS --------------

Clicking on a black area of the screen results in a crash.

The method for checking for overlaps only works sometimes.

Rotation sometimes occurs when it shouldn't, as it results in overlapping shapes.

Issues with the clone method. -- Changed implementation of replacing shapes to no longer use a cloning method.			

Origins not where they should be.

Shapes spawn in 'incorrect' positions when a different size screen is used.

Doesn't work correctly with Android coordinate systems. -- Changed value in AndroidManifest.xml to 'Portrait'.

If one piece fails to rotate because of a self collision, the others do not undo.

SnapTo seems to fail when the distance between the pieces is larger.

Arrow, Kite, Rhombus and Triangle are having compile errors. -- I copied the code and created new classes using it.

Pieces are being deleted when below MozaicPlayer.trans on the zooming camera.

When pieces near their original positions, the new piece in that location shows up
and can be interacted with.

Modes other than PenroseRhomb do not allow pieces to be moved.

Pieces would not rotate after a different piece was deleted, until a piece was left-clicked again.

Rhombus xy and x-y reflections have incorrect orientations.

The following message appears on exit: "AL lib: alc_cleanup: 1 device not closed"

Kite/Dart (P2) snapping is not working.

Translations failing when pieces dragged 'below 0' after zooming out.

Issues with spawn pieces appearing.

Camera scrolling is 'backwards'.

Every time a game is 'esc'ed from and resumed, another set of initial pieces is created.

Now upon loading the initial pieces are not created.

Loading ReflectPieces does not work.		

--

The checkboxes appear to be different sizes from each other (due to blending?)

Only works for screens with height > width

By moving pieces slowly, it is possible to get one to snap off the edge of the screen. See screenshot of 04.12.13	
			
Issues with Penrose P3 on macbook.			
(Need to scale sprite based on screen width)

